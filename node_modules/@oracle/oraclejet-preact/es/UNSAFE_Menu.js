/* @oracle/oraclejet-preact: 14.1.0 */
import { _ as __rest } from './tslib.es6-821b2d99.js';
import { jsx, jsxs } from 'preact/jsx-runtime';
import { Layer } from './UNSAFE_Layer.js';
import { getClientHints } from './utils/PRIVATE_clientHints.js';
import { useRef as useRef$1, useCallback as useCallback$1, forwardRef } from 'preact/compat';
import "./UNSAFE_Menu.css";
import { Floating } from './UNSAFE_Floating.js';
import { useCallback, useRef, useState, useEffect, useContext, useMemo, useLayoutEffect } from 'preact/hooks';
import { useCollectionFocusRing } from './hooks/PRIVATE_useCollectionFocusRing.js';
import { mergeProps } from './utils/UNSAFE_mergeProps.js';
import { classNames } from './utils/UNSAFE_classNames.js';
import { createContext } from 'preact';
import { useOutsideClick } from './hooks/UNSAFE_useOutsideClick.js';
import { u as useModal } from './useModal-beb96266.js';
import { Text } from './UNSAFE_Text.js';
import { useHover } from './hooks/UNSAFE_useHover.js';
import { useId } from './hooks/UNSAFE_useId.js';
import { usePress } from './hooks/UNSAFE_usePress.js';
import { Divider } from './UNSAFE_Divider.js';
import './index-8cf878d9.js';
import './hooks/UNSAFE_useUser.js';
import './UNSAFE_Environment.js';
import './utils/PRIVATE_floatingUtils.js';
import './utils/PRIVATE_refUtils.js';
import './utils/UNSAFE_arrayUtils.js';
import './utils/UNSAFE_mergeInterpolations.js';
import './_curry1-ab762f3c.js';
import './_curry3-77af75f1.js';
import './_curry2-9cf34233.js';
import './_has-e54ed87c.js';
import './hooks/UNSAFE_useToggle.js';

/**
 * @license
 * Copyright (c) %FIRST_YEAR% %CURRENT_YEAR%, Oracle and/or its affiliates.
 * Licensed under The Universal Permissive License (UPL), Version 1.0
 * as shown at https://oss.oracle.com/licenses/upl/
 * @ignore
 */
/**
 * Context used to pass menu information without having to pass it to menu children props.
 * We want to communicate information down to any interested menu item children.
 */
const MenuContext = createContext({
    onClose: () => null,
    currentKey: undefined,
    showFocusRing: false
});

/**
 * @license
 * Copyright (c) %FIRST_YEAR% %CURRENT_YEAR%, Oracle and/or its affiliates.
 * The Universal Permissive License (UPL), Version 1.0
 * as shown at https://oss.oracle.com/licenses/upl/
 * @ignore
 */
/**
 * Hook for handling current key update due to user interaction including keyboard navigation.
 *
 * @param keyExtractor function to extract the key based on the provided element
 * @param getPrevKey function to get the previous key based on the current key
 * @param getNextKey function to get the next key based on the current key
 * @param getFirstVisibleKey function to get the key of the first available item
 * @param getLastVisibleKey function to get the key of the last available item
 * @param currentKey the current key
 * @param onChange function to invoke if the current key has changed
 * @returns
 */
function useMenuCurrentKey(keyExtractor, getPrevKey, getNextKey, getFirstVisibleKey, getLastVisibleKey, currentKey, onChange) {
    const onKeyDown = useCallback((event) => {
        if (onChange) {
            // TODO: support horizontal layout on icon menu (left/right arrow key)
            if (event.key === 'ArrowDown' && !event.shiftKey) {
                const nextKey = getNextKey();
                if (nextKey && currentKey != nextKey) {
                    onChange({ value: nextKey });
                }
                event.preventDefault();
            }
            else if (event.key === 'ArrowUp' && !event.shiftKey) {
                const prevKey = getPrevKey();
                if (prevKey && currentKey != prevKey) {
                    onChange({ value: prevKey });
                }
                event.preventDefault();
            }
            else if (event.key === 'Home') {
                const firstKey = getFirstVisibleKey();
                if (firstKey && currentKey != firstKey) {
                    onChange({ value: firstKey });
                }
                event.preventDefault();
            }
            else if (event.key === 'End') {
                const lastKey = getLastVisibleKey();
                if (lastKey && currentKey != lastKey) {
                    onChange({ value: lastKey });
                }
                event.preventDefault();
            }
        }
    }, [currentKey, getNextKey, getPrevKey, onChange, getFirstVisibleKey, getLastVisibleKey]);
    //Capture needed since usePress stop propagation, what produces not triggering this event.
    //We can't stop propagation here, because if we do that, usePress onClick will not be triggered.
    const onClickCapture = useCallback((event) => {
        if (onChange && !event.shiftKey) {
            const nextKey = keyExtractor(event.target);
            if (nextKey && currentKey != nextKey) {
                onChange({ value: nextKey });
            }
        }
    }, [currentKey, keyExtractor, onChange]);
    const currentKeyProps = onChange == null ? {} : { onClickCapture, onKeyDown };
    return { currentKeyProps };
}

/**
 * @license
 * Copyright (c) %FIRST_YEAR% %CURRENT_YEAR%, Oracle and/or its affiliates.
 * Licensed under The Universal Permissive License (UPL), Version 1.0
 * as shown at https://oss.oracle.com/licenses/upl/
 * @ignore
 */
/**
 * Returns the key from the item element
 */
const getKey = (item) => {
    // Key is set on data-oj-menu-item-key on each menuItem. To get this key from the
    // the actual menuItem we need to do a kebab to camel-case conversion.
    return item.dataset['ojMenuItemKey'];
};
/**
 * A helper function that return the key of the first available item.
 */
const getFirstVisibleKey = (root) => {
    if (root) {
        const firstItem = root.querySelector('[data-oj-menu-item-key]');
        if (firstItem) {
            const key = getKey(firstItem);
            if (key) {
                return key;
            }
        }
    }
    return null;
};
/**
 * A helper function that return the key of the last available item.
 */
const getLastVisibleKey = (root) => {
    if (root) {
        const items = root.querySelectorAll('[data-oj-menu-item-key]');
        const lastItem = items[items.length - 1];
        if (lastItem) {
            const key = getKey(lastItem);
            if (key) {
                return key;
            }
        }
    }
    return null;
};
/**
 * A helper function that returns the key of the previous or the next item
 * given the specified current key
 */
const getPrevNextKey = (root, isPrev, currentKey) => {
    return () => {
        if (root) {
            const items = Array.from(root.querySelectorAll('[data-oj-menu-item-key]'));
            const currentKeyIndex = items.findIndex((item) => getKey(item) === currentKey);
            let nextIndex = currentKeyIndex + (isPrev ? -1 : 1);
            const itemsLastIndex = items.length - 1;
            if (nextIndex < 0) {
                nextIndex = itemsLastIndex;
            }
            if (nextIndex > itemsLastIndex) {
                nextIndex = 0;
            }
            return getKey(items[nextIndex]) || null;
        }
        return null;
    };
};
/**
 * A helper function to get the key from an element
 */
const keyExtractor = (element) => {
    const item = element.closest('[data-oj-menu-item-key]');
    if (item) {
        const key = getKey(item);
        return key === undefined ? null : key;
    }
    return null;
};
/**
 * Function to get the corresponding keyboard behavior to close the menu.
 */
const getKeyboardCloseProps = (onClose) => {
    const onKeyDown = (event) => {
        if (event.key === 'Tab') {
            onClose === null || onClose === void 0 ? void 0 : onClose({ reason: 'dismissed' });
            event.preventDefault(); //TODO: Revisit this since we should let focus be at its natural flow, quick solution for now to focus correct item in main use case
        }
        else if (event.key === 'Escape') {
            onClose === null || onClose === void 0 ? void 0 : onClose({ reason: 'dismissed' });
        }
    };
    return { onKeyDown };
};
/**
 * Function to get the corresponding specific behavior for clicking/touching down menuContainer
 */
const getMenuPointerDown = () => {
    const onPointerDown = (event) => {
        //We just want to prevent default when element that was
        //pressed down was not a menu item. Using this flag removes issues
        //related to focus visibilty on "long press"
        const nextKey = keyExtractor(event.target);
        if (!nextKey) {
            event.preventDefault();
        }
    };
    return { onPointerDown };
};

const styles$4 = {
  menuContainer: "j91n3a",
  dropdownMenuContainer: "_1dohnnf",
  sheetMenuContainer: "_78wq11"
};
const MenuContainer = ({
  children,
  onClose,
  accessibleLabel,
  initialFocus = 'menu',
  display
}) => {
  const menuContainerRef = useRef(null);
  const initialFocusRef = useRef(initialFocus);
  const [currentKey, setCurrentKey] = useState();
  const [possibleFocus, setPossibleFocus] = useState('pending');
  const changeKey = useCallback(detail => {
    setCurrentKey(detail.value);
    setPossibleFocus('firstItem');
  }, []);
  const [showFocusRing, focusRingProps] = useCollectionFocusRing(elem => {
    var _a;

    return !!((_a = menuContainerRef.current) === null || _a === void 0 ? void 0 : _a.contains(elem));
  }, ['ArrowUp', 'ArrowDown'], elem => {
    const nextKey = keyExtractor(elem);
    return !!nextKey;
  });
  const {
    currentKeyProps
  } = useMenuCurrentKey(element => keyExtractor(element), getPrevNextKey(menuContainerRef.current, true, currentKey), getPrevNextKey(menuContainerRef.current, false, currentKey), () => getFirstVisibleKey(menuContainerRef.current), () => getLastVisibleKey(menuContainerRef.current), currentKey, changeKey);
  useEffect(() => {
    const menuContainer = menuContainerRef.current;

    if (menuContainer) {
      if (initialFocusRef.current === 'menu') {
        // At this point floating has visibility set as hidden, so also menuContainer. Settimeout added so menuContainer
        // is visible at that point and can be focused
        setTimeout(() => {
          menuContainer.focus();
        }, 0);
        setPossibleFocus('menu');
      } else {
        const firstItemKey = getFirstVisibleKey(menuContainerRef.current);

        if (firstItemKey) {
          changeKey({
            value: firstItemKey
          });
        } else {
          setPossibleFocus('menu');
        }
      }
    }
  }, [initialFocusRef, changeKey]); // TODO - Reuse a dropdown component instead of creating floating by ourselves.

  return jsx("div", Object.assign({
    ref: menuContainerRef,
    tabIndex: possibleFocus === 'firstItem' ? -1 : 0,
    role: "menu",
    "aria-label": accessibleLabel,
    class: classNames([styles$4.menuContainer, styles$4[`${display}MenuContainer`]])
  }, mergeProps(focusRingProps, currentKeyProps, getMenuPointerDown(), getKeyboardCloseProps(onClose)), {
    children: jsx(MenuContext.Provider, Object.assign({
      value: {
        onClose,
        currentKey,
        showFocusRing
      }
    }, {
      children: children
    }))
  }));
};

const styles$3 = {
  // TODO: Handle vertical and horizontal overflow. Get rid of maxWidth on a next drop so horizontal and also vertical flow is handled correctly.
  // It's hard to relay just in css, we might need to relay on some kind of observer. Maybe should be handled on Floating/Dropdown component.
  base: "_18mgcg8"
};
const DropdownMenu = _a => {
  var {
    anchorRef,
    onClose
  } = _a,
      dropdownMenuProps = __rest(_a, ["anchorRef", "onClose"]);

  const floatingRef = useRef$1(null);
  const useOutsideClickHandler = useCallback$1(e => {
    onClose === null || onClose === void 0 ? void 0 : onClose({
      reason: 'outsideClick',
      target: e.target
    });
  }, [onClose]);
  useOutsideClick({
    ref: [floatingRef],
    handler: useOutsideClickHandler
  });
  return jsx(Floating, Object.assign({
    class: styles$3.base,
    ref: floatingRef,
    anchorRef: anchorRef,
    placement: "bottom-start",
    offsetValue: {
      mainAxis: 4,
      crossAxis: 0
    }
  }, {
    children: jsx("div", Object.assign({
      style: {
        minWidth: `${anchorRef.current && anchorRef.current.offsetWidth > MENU_MIN_WIDTH ? anchorRef.current.offsetWidth : MENU_MIN_WIDTH}px`
      }
    }, {
      children: jsx(MenuContainer, Object.assign({}, Object.assign({
        onClose
      }, dropdownMenuProps), {
        display: "dropdown"
      }))
    }))
  }));
};
const MENU_MIN_WIDTH = 200;

/**
 * @license
 * Copyright (c) %FIRST_YEAR% %CURRENT_YEAR%, Oracle and/or its affiliates.
 * Licensed under The Universal Permissive License (UPL), Version 1.0
 * as shown at https://oss.oracle.com/licenses/upl/
 * @ignore
 */
/*This "private" hook will live until we end up stating a final decision on useSwipe hook.
For that hook to work, element that use it has to set touch-action:none;, since pointer events
are canceled once a touch action is going to be handled by the browser. This works for most
of the components that don't scroll. But if the component scroll, there is a need for the browser to
handle scroll which is imposible with a hook just using pointer events.
*/
function useMenuSwipe(onSwipe, { threshold = 10, maximumTime = 300, tolerance = 50, isDisabled = false } = {
    threshold: 10,
    maximumTime: 300,
    tolerance: 50,
    isDisabled: false
}) {
    const ref = useRef({
        pointerDownId: 0,
        startTime: null,
        prevpageX: 0,
        prevpageY: 0,
        elementScrollTop: 0
    });
    const clearSwipe = useCallback(() => {
        ref.current = {
            pointerDownId: null,
            startTime: 0,
            prevpageX: 0,
            prevpageY: 0,
            elementScrollTop: 0
        };
    }, []);
    const onTouchStart = useCallback((e) => {
        const touchobj = e.changedTouches[0];
        if (!ref.current.pointerDownId) {
            ref.current = {
                pointerDownId: touchobj.identifier,
                startTime: e.timeStamp,
                prevpageX: touchobj.pageX,
                prevpageY: touchobj.pageY,
                elementScrollTop: e.currentTarget.scrollTop
            };
        }
        else {
            clearSwipe();
        }
    }, [clearSwipe]);
    const onTouchEnd = useCallback((ev) => {
        const touchobj = ev.changedTouches[0];
        if (touchobj.identifier === ref.current.pointerDownId) {
            if (ref.current.startTime && ev.timeStamp - ref.current.startTime < maximumTime) {
                if (touchobj.pageY - ref.current.prevpageY > threshold &&
                    Math.abs(touchobj.pageX - ref.current.prevpageX) <= tolerance &&
                    ref.current.elementScrollTop === 0) {
                    onSwipe === null || onSwipe === void 0 ? void 0 : onSwipe({ direction: 'down' });
                }
            }
        }
        // state would be reset to its original state whether swipe is completed or cancelled
        clearSwipe();
    }, [threshold, onSwipe, clearSwipe, maximumTime, tolerance]);
    const swipeProps = isDisabled
        ? {}
        : {
            /** event handlers to spread on the target element. */
            onTouchStart,
            onTouchEnd,
            ontouchcancel: clearSwipe
        };
    return {
        swipeProps
    };
}

const styles$2 = {
  modalWrapper: "pv4inq",
  modalContainer: "x62vcr",
  sheetMenuContainerWrapper: "_10ke6sd",
  modalBackdrop: "_1w64tom"
};

const ModalWrapper = ({
  children
}) => jsx("div", Object.assign({
  class: styles$2.modalWrapper
}, {
  children: children
}));

const ModalContainer = forwardRef(({
  children
}, ref) => jsx("div", Object.assign({
  class: styles$2.modalContainer,
  ref: ref
}, {
  children: children
}))); //ModalBackdrop on modal folder not setting the style on oj-c enviroment
//Creating it here so we don't see that issue

const ModalBackdrop = () => jsx("div", {
  class: styles$2.modalBackdrop
});

const SheetMenu = _a => {
  var {
    onClose
  } = _a,
      menuProps = __rest(_a, ["onClose"]);

  useEffect(() => {
    // We set the overflow body as hidden when mounted and revert to original overflow value when is
    // unmounted. This is done to don't allow backgound being scrolled
    // This will be handled by modal/popup when ready
    const initialOverflow = document.body.style.overflow;
    document.body.style.overflow = 'hidden';
    return () => {
      document.body.style.overflow = initialOverflow;
    };
  }, []);
  const dismissHandler = useCallback(() => {
    onClose === null || onClose === void 0 ? void 0 : onClose({
      reason: 'dismissed'
    });
  }, [onClose]);
  const {
    modalRef
  } = useModal({
    isOpen: true,
    onBackdropClick: dismissHandler
  }); //TODO: Use useSwipe when it works on components that could scroll.

  const {
    swipeProps
  } = useMenuSwipe(dismissHandler); // TODO: For now we are mimicking current modal but using a "different position setting" (using absolute positioning instead of flex).
  // Have to use modal/popup component directly instead doing this composition when that component could satisfy our requirments.

  return jsxs(ModalWrapper, {
    children: [jsx(ModalBackdrop, {}), jsx(ModalContainer, Object.assign({
      ref: modalRef
    }, {
      children: jsx("div", Object.assign({
        class: styles$2.sheetMenuContainerWrapper
      }, swipeProps, {
        children: jsx(MenuContainer, Object.assign({}, Object.assign(Object.assign({}, menuProps), {
          onClose
        }), {
          display: "sheet"
        }))
      }))
    }))]
  });
};

const { deviceType } = getClientHints();
const isMobile = deviceType === 'phone';
const Menu = (_a) => {
    var { isOpen, anchorRef } = _a, menuProps = __rest(_a, ["isOpen", "anchorRef"]);
    // TODO - Reuse a dropdown component instead of creating floating by ourselves.
    return !isOpen ? null : (jsx(Layer, Object.assign({ logicalParentRef: anchorRef }, { children: isMobile ? jsx(SheetMenu, Object.assign({}, menuProps)) : jsx(DropdownMenu, Object.assign({}, Object.assign({ anchorRef }, menuProps))) })));
};

/**
 * @license
 * Copyright (c) %FIRST_YEAR% %CURRENT_YEAR%, Oracle and/or its affiliates.
 * Licensed under The Universal Permissive License (UPL), Version 1.0
 * as shown at https://oss.oracle.com/licenses/upl/
 * @ignore
 */
/**
 * Utility hook for consuming the MenuContext
 *
 * @returns The value of MenuContext provider
 */
function useMenuContext() {
    return useContext(MenuContext);
}

const styles$1 = {
  menuItemContainer: "_17876eg",
  focused: "qinu8s",
  variant: {
    default: {
      menuItemContainer: "_8kqhsa",
      hover: "_1pghquj",
      pseudohover: "a3k8sy"
    },
    destructive: {
      menuItemContainer: "_18l9dkr",
      hover: "_123woi2",
      pseudohover: "gfxxfs"
    }
  },
  iconLabelContainer: "_1homfv4",
  labelContainer: "_1rmwgrq",
  iconContainer: "_1hyxnw0",
  startIconContainer: "cl4q1q",
  endIconContainer: "yx2cjf",
  disabledContainer: "_54xf9b"
};
function MenuItem(props) {
  return jsx(BaseMenuItem, Object.assign({}, props, {
    role: "menuitem"
  }));
}
const isHybrid = getClientHints().hoverSupport === 'events';
function BaseMenuItem({
  label,
  onAction,
  startIcon,
  endIcon,
  role,
  isChecked,
  isDisabled = false,
  variant = 'default'
}) {
  const {
    onClose,
    currentKey,
    showFocusRing
  } = useMenuContext();
  const uniqueID = useId();
  const id = useMemo(() => `oj-menu-item-${uniqueID}`, [uniqueID]);
  const isCurrent = currentKey === id;
  const menuItemRef = useRef(null);
  const {
    hoverProps,
    isHover
  } = useHover({
    isDisabled: !isHybrid
  });

  const handleItemSelection = () => {
    onClose === null || onClose === void 0 ? void 0 : onClose({
      reason: 'itemAction'
    });
    onAction === null || onAction === void 0 ? void 0 : onAction();
  };

  const {
    pressProps
  } = usePress(handleItemSelection, {
    isDisabled
  });
  useLayoutEffect(() => {
    var _a;

    if (isCurrent) {
      (_a = menuItemRef.current) === null || _a === void 0 ? void 0 : _a.focus();
    }
  }, [isCurrent]);
  const menuItemContainerClasses = classNames([styles$1.menuItemContainer, !isDisabled && styles$1.variant[variant].menuItemContainer, isDisabled && styles$1.disabledContainer, !isHybrid && !isDisabled && styles$1.variant[variant].pseudohover, isHybrid && isHover && !isDisabled && styles$1.variant[variant].hover, isCurrent && !!showFocusRing && styles$1.focused]);
  const startIconContainerClasses = classNames([styles$1.iconLabelContainer, styles$1.iconContainer, styles$1.startIconContainer]);
  const labelContainerClasses = classNames([styles$1.iconLabelContainer, styles$1.labelContainer]);
  const endIconContainerClasses = classNames([styles$1.iconLabelContainer, styles$1.iconContainer, styles$1.endIconContainer]);
  return jsxs("a", Object.assign({
    ref: menuItemRef,
    class: menuItemContainerClasses
  }, mergeProps(hoverProps, pressProps), {
    role: role,
    "data-oj-menu-item-key": id
  }, isDisabled && {
    'aria-disabled': true
  }, role !== 'menuitem' && {
    'aria-checked': isChecked
  }, {
    tabIndex: isCurrent ? 0 : -1
  }, {
    children: [startIcon && jsx("span", Object.assign({
      class: startIconContainerClasses
    }, {
      children: startIcon
    })), jsx("span", Object.assign({
      class: labelContainerClasses
    }, {
      children: jsx(Text, Object.assign({
        variant: "inherit",
        size: "md"
      }, {
        children: label
      }))
    })), endIcon && jsx("span", Object.assign({
      class: endIconContainerClasses
    }, {
      children: endIcon
    }))]
  }));
}

const styles = {
  menuDividerContainer: "_1of8jrz"
};
function MenuDivider() {
  return jsx("div", Object.assign({
    class: styles.menuDividerContainer
  }, {
    children: jsx(Divider, {})
  }));
}

export { Menu, MenuDivider, MenuItem };
/*  */
//# sourceMappingURL=UNSAFE_Menu.js.map
