/* @oracle/oraclejet-preact: 14.1.0 */
import { useRef, useEffect, useState, useCallback, useLayoutEffect } from 'preact/hooks';
import { jsx } from 'preact/jsx-runtime';
import { useId } from './UNSAFE_useId.js';
import { Floating } from '../UNSAFE_Floating.js';
import { Layer } from '../UNSAFE_Layer.js';
import { useHover } from './UNSAFE_useHover.js';
import { useFocus } from './UNSAFE_useFocus.js';
import { useTouch } from './UNSAFE_useTouch.js';
import { mergeProps } from '../utils/UNSAFE_mergeProps.js';
import { stringLiteralArray } from '../utils/UNSAFE_arrayUtils.js';
import { _ as __rest } from '../tslib.es6-821b2d99.js';
import { useAnimation } from './UNSAFE_useAnimation.js';
import "./UNSAFE_useTooltip.css";
import { classNames } from '../utils/UNSAFE_classNames.js';
import 'preact/compat';
import '../index-8cf878d9.js';
import './UNSAFE_useUser.js';
import '../UNSAFE_Environment.js';
import 'preact';
import '../utils/PRIVATE_floatingUtils.js';
import '../utils/PRIVATE_refUtils.js';
import './UNSAFE_useOutsideClick.js';
import './UNSAFE_useToggle.js';

const styles = {
  wrapper: "exwey6",
  inner: "_1cbf3q6",
  base: "_1o7y3bd",
  datatip: "_1d2cvbp"
};
const TooltipContent = _a => {
  var {
    children,
    isOpen,
    isDatatip,
    onTransitionEnd
  } = _a,
      props = __rest(_a, ["children", "isOpen", "isDatatip", "onTransitionEnd"]);

  const uniqueID = useId();
  const wrapperRef = useRef(null);
  const popoverRef = useRef(null);
  const {
    nodeRef
  } = useAnimation(isOpen ? 'mounted' : 'unmounted', {
    animationStates: {
      mounted: _node => {
        const childNode = _node.firstChild;
        return {
          from: {
            maxHeight: '0',
            opacity: '0%'
          },
          to: {
            maxHeight: `${childNode === null || childNode === void 0 ? void 0 : childNode.offsetHeight}px`,
            opacity: isDatatip ? '100%' : '95%'
          },
          options: {
            duration: isDatatip ? 1 : 100,
            easing: [0.0, 0.0, 0.2, 1]
          }
        };
      },
      unmounted: _node => {
        return {
          from: {
            opacity: isDatatip ? '100%' : '95%'
          },
          to: {
            maxHeight: '0',
            opacity: '0%'
          },
          options: {
            duration: isDatatip ? 1 : 100,
            easing: [0.0, 0.0, 0.2, 1]
          }
        };
      }
    },
    isAnimatedOnMount: true,
    onAnimationEnd: () => onTransitionEnd === null || onTransitionEnd === void 0 ? void 0 : onTransitionEnd()
  }); // Set up initial wrapper height so Tooltip can animate from the bottom to the top

  useEffect(() => {
    var _a, _b;

    if (wrapperRef.current && ((_a = popoverRef.current) === null || _a === void 0 ? void 0 : _a.offsetHeight)) {
      wrapperRef.current.style.height = `${(_b = popoverRef.current) === null || _b === void 0 ? void 0 : _b.offsetHeight}px`;
    }
  }, []);
  return jsx("div", Object.assign({
    ref: wrapperRef,
    id: uniqueID,
    role: "tooltip",
    class: styles.wrapper
  }, {
    children: jsx("div", Object.assign({
      ref: nodeRef,
      class: classNames([styles.inner])
    }, props, {
      children: jsx("div", Object.assign({
        ref: popoverRef,
        class: classNames([styles.base, isDatatip ? styles.datatip : ''])
      }, {
        children: children
      }))
    }))
  }));
};

const positions = stringLiteralArray([
    'start',
    'top-start',
    'top',
    'top-end',
    'end',
    'bottom-end',
    'bottom',
    'bottom-start'
]);
const positionToPlacement = (position) => {
    let placement = 'bottom';
    switch (position) {
        case 'top':
        case 'end':
        case 'bottom':
        case 'start':
            placement = position;
            break;
        case 'top-end':
            placement = 'top-end-corner';
            break;
        case 'bottom-end':
            placement = 'bottom-end-corner';
            break;
        case 'bottom-start':
            placement = 'bottom-start-corner';
            break;
        case 'top-start':
            placement = 'top-start-corner';
            break;
    }
    return placement;
};
const anchorTos = stringLiteralArray(['element', 'pointer']);
const useTooltipControlled = ({ text, isOpen = false, variant = 'tooltip', position = 'bottom', isDisabled = false, anchor = { x: 'element', y: 'element' }, offset = { mainAxis: 0, crossAxis: 0 }, onToggle }) => {
    const disabled = isDisabled || !text;
    const isInitialRenderState = useRef(true);
    const [state, setState] = useState(!disabled && isOpen ? 'mounting' : 'unmounted');
    const [needsUpdate, setNeedsUpdate] = useState(false);
    setNeedsUpdate(false);
    const isDatatip = variant === 'datatip';
    const isInitialRenderTrigger = useRef(true);
    const { hoverProps, isHover } = useHover({});
    const { touchProps, isTouch } = useTouch({ isDisabled }); // TODO replace by useLongPress actionhook
    // we only care about keyboard focus, don't enable useFocus hook if isHover or isTouch are active
    const { focusProps, isFocus } = useFocus({ isDisabled: isHover || isTouch });
    const { hoverProps: popoverHoverProps, isHover: popoverIsHover } = useHover({ isDisabled });
    const isPointer = anchor.x === 'pointer' || anchor.y === 'pointer';
    const uniqueID = useId();
    const targetRef = useRef(null);
    const coordsRef = useRef({ x: 0, y: 0 });
    // if anchor is set to pointer and target does not have keyboard focus, use coords
    const usedRef = isPointer && !isFocus ? coordsRef : targetRef;
    const delay = isDatatip ? 0 : 250;
    const toggleTimeoutRef = useRef(null);
    const updateTimeoutRef = useRef(null);
    const toggleTimeoutClear = () => {
        if (toggleTimeoutRef.current) {
            clearTimeout(toggleTimeoutRef.current);
        }
    };
    const updateTimeoutClear = () => {
        if (updateTimeoutRef.current) {
            clearTimeout(updateTimeoutRef.current);
        }
    };
    const updateState = useCallback((open) => {
        if (open) {
            // At least one toggle event is set to true
            switch (state) {
                case 'unmounting':
                case 'unmounted':
                    setState('mountPending'); // Set mount pending state if tooltip is unmounted or in unmounting transition
                    break;
                case 'unmountPending':
                    toggleTimeoutClear();
                    setState('mounted'); // Clear timers immediately and keep the tooltip mounted
                    break;
            }
        }
        else {
            // No toggle events are set to true
            switch (state) {
                case 'mounting':
                case 'mounted':
                    setState('unmountPending'); // Set unmount pending state if tooltip is mounted or in mounting transition
                    break;
                case 'mountPending':
                    toggleTimeoutClear();
                    setState('unmounted'); // Unmount tooltip immediately if mounting is pending
                    break;
            }
        }
    }, [state]);
    useEffect(() => {
        if (isInitialRenderState.current) {
            // On onitial render do not trigger rerender
            isInitialRenderState.current = false;
            return;
        }
        setState(isOpen ? 'mounting' : 'unmounting');
    }, [isOpen]);
    useEffect(() => {
        if (isInitialRenderTrigger.current) {
            // On onitial render do not trigger rerender
            isInitialRenderTrigger.current = false;
            return;
        }
        // When pointer is used, handleMouseMove method is responsible for state updates
        // until the tooltip is mounted
        if (isPointer && isHover && state === 'unmounted') {
            return;
        }
        updateTimeoutClear();
        // isHover and popoverIsHover may change rapidly as the pointer moves between the target
        // and tooltip. Need to wait for changes to settle to avoid flashing.
        updateTimeoutRef.current = setTimeout(() => {
            updateState(isHover || isFocus || popoverIsHover || isTouch);
        }, 20);
    }, [isHover, isFocus, popoverIsHover, isTouch, isPointer, state, updateState]);
    /*
     In some cases, several state transitions can occur at once. Due to the asynchronous nature
     of hooks, this can create a race condition. For example, when the cursor leaves the target
     element and immediately moves to the tooltip itself, the following sequence occurs:
     1. isHover is set to false and a new render is triggered
     2. The state is set to 'unmountPending' and a new render is triggered
     3. Pending timeout is set
     4. isHover is set to true and a new render is triggered
     5. Pending timeout is cleared
     However, sometimes the timeout is cleared before it is set. The useLayoutEffect prevents this
     race condition by always scheduling the timeout synchronously.
    */
    useLayoutEffect(() => {
        if (state === 'mountPending' || state === 'unmountPending') {
            toggleTimeoutRef.current = setTimeout(() => onToggle === null || onToggle === void 0 ? void 0 : onToggle({ value: state === 'mountPending' }), delay);
        }
    }, [state, delay, onToggle]);
    const handleMouseMove = (event) => {
        var _a;
        // we only want track mouse move while the state is 'unmounted' or when moving a 'mounted' datatip
        if (state !== 'unmounted' && !(variant === 'datatip' && state === 'mounted')) {
            return;
        }
        const targetRect = (_a = targetRef === null || targetRef === void 0 ? void 0 : targetRef.current) === null || _a === void 0 ? void 0 : _a.getBoundingClientRect();
        // Tooltip maintains static offset from left side of window
        const distanceX = document.body.scrollLeft + ((targetRect === null || targetRect === void 0 ? void 0 : targetRect.left) || 0) + ((targetRect === null || targetRect === void 0 ? void 0 : targetRect.width) || 0);
        // Tooltip maintains static offset from top side of the window
        const distanceY = document.body.scrollTop + ((targetRect === null || targetRect === void 0 ? void 0 : targetRect.top) || 0) + ((targetRect === null || targetRect === void 0 ? void 0 : targetRect.height) || 0);
        // Display tooltip at the mouse position if both anchors are set to pointer
        const x = anchor.x === 'pointer' ? event.clientX : distanceX;
        const y = anchor.y === 'pointer' ? event.clientY : distanceY;
        if (state === 'mounted') {
            coordsRef.current = { x, y };
            if (needsUpdate !== true)
                setNeedsUpdate(true);
        }
        else if (state === 'unmounted') {
            toggleTimeoutClear();
            toggleTimeoutRef.current = setTimeout(() => {
                if (state === 'unmounted') {
                    coordsRef.current = { x, y };
                    onToggle === null || onToggle === void 0 ? void 0 : onToggle({ value: true });
                }
            }, delay);
        }
    };
    const focusInitProps = {
        onFocus: (event) => {
            if (event.eventPhase === Event.AT_TARGET ||
                (event.eventPhase === Event.BUBBLING_PHASE && isDatatip)) {
                targetRef.current = event.target;
            }
        }
    };
    const hoverInitProps = {
        onMouseEnter: (event) => {
            if (event.eventPhase === Event.AT_TARGET ||
                (event.eventPhase === Event.BUBBLING_PHASE && isDatatip)) {
                targetRef.current = event.target;
            }
        }
    };
    let actionableProps;
    if (disabled) {
        actionableProps = mergeProps(hoverProps, focusProps, hoverInitProps, focusInitProps);
    }
    else {
        const anchorInitProps = Object.assign({ 'aria-describedby': uniqueID }, (isPointer && {
            onMouseLeave: () => {
                if (state === 'mounting') {
                    return;
                }
                toggleTimeoutClear();
            },
            onMouseMove: (event) => {
                if (event.eventPhase === Event.AT_TARGET ||
                    (event.eventPhase === Event.BUBBLING_PHASE && isDatatip)) {
                    handleMouseMove(event);
                }
            }
        }));
        actionableProps = mergeProps(hoverProps, focusProps, touchProps, hoverInitProps, focusInitProps, anchorInitProps);
    }
    // No need to process tooltip if disabled or no text is provided
    // Include actionableProps to detect mouseenter in components
    // hovered state won't update unless actionableProps are already present in the component when mouse enters
    if (disabled) {
        toggleTimeoutClear();
        return {
            tooltipContent: null,
            tooltipProps: actionableProps
        };
    }
    const placement = positionToPlacement(position);
    const handleTransitionEnd = () => {
        if (state === 'mounting') {
            setState('mounted');
        }
        if (state === 'unmounting') {
            setState('unmounted');
        }
    };
    const renderContent = (jsx(Layer, Object.assign({ logicalParentRef: targetRef }, { children: jsx(Floating, Object.assign({ anchorRef: usedRef, placement: placement, offsetValue: offset }, { children: jsx(TooltipContent, Object.assign({ isOpen: ['mounting', 'mounted', 'unmountPending'].includes(state) }, popoverHoverProps, { isDatatip: isDatatip, onTransitionEnd: handleTransitionEnd }, { children: text })) })) })));
    return {
        tooltipContent: !['unmounted', 'mountPending'].includes(state) && renderContent,
        tooltipProps: actionableProps
    };
};

const useTooltip = ({ text, position = 'bottom', isDisabled = false, anchor = { x: 'element', y: 'element' }, offset = { mainAxis: 0, crossAxis: 0 }, variant = 'tooltip' }) => {
    const [isOpen, setIsOpen] = useState(false);
    const disabled = isDisabled || !text;
    const { tooltipContent, tooltipProps } = useTooltipControlled({
        text,
        isOpen,
        position,
        isDisabled: disabled,
        offset,
        anchor,
        variant,
        onToggle: ({ value }) => setIsOpen(value)
    });
    return {
        tooltipContent,
        tooltipProps
    };
};

/**
 * @license
 * Copyright (c) %FIRST_YEAR% %CURRENT_YEAR%, Oracle and/or its affiliates.
 * The Universal Permissive License (UPL), Version 1.0
 * as shown at https://oss.oracle.com/licenses/upl/
 * @ignore
 */

export { useTooltip, useTooltipControlled };
/*  */
//# sourceMappingURL=UNSAFE_useTooltip.js.map
