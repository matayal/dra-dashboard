/* @oracle/oraclejet-preact: 14.1.0 */
import { _ as __rest } from './tslib.es6-821b2d99.js';
import { jsx, jsxs } from 'preact/jsx-runtime';
import { Fragment } from 'preact';
import { useRef, useState, useEffect } from 'preact/hooks';
import "./UNSAFE_RatingGauge.css";
import { classNames } from './utils/UNSAFE_classNames.js';
import { findThreshold, getThresholdColorFromValue } from './utils/PRIVATE_meterUtils.js';
import { useUser } from './hooks/UNSAFE_useUser.js';
import { useTooltipControlled } from './hooks/UNSAFE_useTooltip.js';
import { mergeProps } from './utils/UNSAFE_mergeProps.js';
import { useTabbableMode } from './hooks/UNSAFE_useTabbableMode.js';
import './utils/UNSAFE_dvtCommonUtils.js';
import './UNSAFE_Environment.js';
import './UNSAFE_Layer.js';
import 'preact/compat';
import './hooks/UNSAFE_useId.js';
import './UNSAFE_Floating.js';
import './index-8cf878d9.js';
import './utils/PRIVATE_floatingUtils.js';
import './utils/PRIVATE_refUtils.js';
import './hooks/UNSAFE_useOutsideClick.js';
import './utils/UNSAFE_arrayUtils.js';
import './hooks/UNSAFE_useHover.js';
import './hooks/UNSAFE_useToggle.js';
import './hooks/UNSAFE_useFocus.js';
import './hooks/UNSAFE_useTouch.js';
import './hooks/UNSAFE_useAnimation.js';

function getValue(pageX, max, step, dimensionsRef, isRtl) {
    const dimensions = dimensionsRef.current;
    if (!dimensions || dimensions.width === 0) {
        return -1;
    }
    const width = pageX - dimensions.x;
    const val = (max * (isRtl ? dimensions.width - width : width)) / dimensions.width;
    const numSteps = val / step;
    return numSteps < 0.5 ? 0 : Math.ceil(numSteps) * step;
}
function getDimensions(element) {
    if (!element) {
        return {
            width: 0,
            x: 0
        };
    }
    const rect = element.getBoundingClientRect();
    return {
        width: Math.round(rect.width),
        x: Math.round(rect.x + window.scrollX)
    };
}
/**
 * Returns the aria properties of the rating gauge.
 * @param value The value of the rating gauge.
 * @param max The maximum value of the rating gauge.
 * @param valueText The default aria value text for the rating gauge.
 * @param accessibleLabel The aria label of the rating gauge.
 * @param ariaLabelledby The ariaLabelledBy of the rating gauge.
 * @param thresholds The thresholds values for the rating gauge.
 * @returns The aria properties of the rating gauge.
 */
function getRatingAriaProps(value, max, accessibleLabel, ariaLabelledby, isDisabled, isReadonly, thresholds, tooltip) {
    const currentThreshold = findThreshold(value, thresholds);
    const ariaValueText = (currentThreshold === null || currentThreshold === void 0 ? void 0 : currentThreshold.accessibleLabel)
        ? `${value} ${currentThreshold.accessibleLabel}`
        : `${value}`;
    const accessibleLabelText = accessibleLabel
        ? accessibleLabel
        : tooltip && isReadonly && !isDisabled
            ? tooltip
            : undefined;
    return {
        'aria-label': accessibleLabelText,
        'aria-valuenow': `${value}`,
        'aria-valuetext': ariaValueText,
        'aria-valuemax': `${max}`,
        'aria-labelledby': ariaLabelledby,
        'aria-disabled': isDisabled ? true : undefined,
        'aria-readonly': isReadonly && !isDisabled ? true : undefined,
        'aria-valuemin': '0',
        role: 'slider'
    };
}
/**
 * Returns whether the color is a valid enum.
 * @param color The color in rating gauge.
 * @returns true if the color enum is supported. false otherwise.
 */
function isColorEnum(color) {
    return color === 'neutral' ||
        color === 'gold' ||
        color === 'danger' ||
        color === 'warning' ||
        color === 'success'
        ? true
        : false;
}

const RatingStar = ({
  isSelected,
  isDisabled,
  isReadOnly,
  color
}) => {
  const selectionState = isSelected ? 'selected' : 'unselected';
  const disabledState = isDisabled && 'Disabled';
  const readonlyState = isReadOnly && 'Readonly';
  const styleStatePrefix = `${selectionState}${disabledState || readonlyState || ''}`;
  const innerStyleClass = ratingStarStyles[`${styleStatePrefix}Color`];
  const outerStyleClass = ratingStarStyles[`${styleStatePrefix}BorderColor`];
  const isEnum = isColorEnum(color);
  const customColors = !isEnum ? {
    '--oj-c-PRIVATE-DO-NOT-USE-rating-gauge-color-selected': color,
    '--oj-c-PRIVATE-DO-NOT-USE-rating-gauge-border-color-selected': color,
    '--oj-c-PRIVATE-DO-NOT-USE-rating-gauge-color-selected-readonly': color
  } : undefined;
  return jsx("svg", Object.assign({
    viewBox: "0 0 36 36",
    height: "100%",
    width: "100%",
    style: customColors,
    class: classNames([ratingStarStyles.base, isEnum ? `oj-c-rating-gauge-${color}` : ''])
  }, {
    children: jsxs("g", {
      children: [jsx("path", {
        class: innerStyleClass,
        d: "m18 1 5.0061 11.9524 12.9939 1.0344-9.9 8.4215 3.0246 12.5917-11.1246-6.7476-11.12461 6.7476 3.02461-12.5917-9.9-8.4215 12.9939-1.0344z"
      }), jsx("path", {
        class: outerStyleClass,
        d: "m23.0061 12.9524-5.0061-11.9524-5.0061 11.9524-12.9939 1.0344 9.9 8.4215-3.02461 12.5917 11.12461-6.7476 11.1246 6.7476-3.0246-12.5917 9.9-8.4215zm10.5043 1.8394-8.5262 7.2528 2.6077 10.8562-9.5919-5.818-9.59192 5.818 2.60772-10.8562-8.52615-7.2528 11.19115-.891 4.3192-10.31227 4.3192 10.31227z"
      })]
    })
  }));
};

const ratingStarStyles = {
  base: "_1t7j7kq",
  selectedColor: "erg4r7",
  selectedBorderColor: "_1jxczo3",
  unselectedColor: "pdvq87",
  unselectedBorderColor: "_1out344",
  selectedReadonlyColor: "_1hct8wt",
  selectedReadonlyBorderColor: "zucwzu",
  unselectedReadonlyColor: "p89yuo",
  unselectedReadonlyBorderColor: "_1u1qtw0",
  selectedDisabledColor: "_805gic",
  unselectedDisabledColor: "_595z2y",
  selectedDisabledBorderColor: "bzdbbf",
  unselectedDisabledBorderColor: "up74mb"
};

const RatingGaugeItem = ({
  fillRatio,
  isDisabled,
  isReadonly,
  color
}) => {
  const {
    direction
  } = useUser();
  const isRtl = direction === 'rtl';

  if (fillRatio === 1 || fillRatio === 0) {
    return jsx(RatingStar, {
      isSelected: fillRatio === 1,
      isDisabled: isDisabled,
      isReadOnly: isReadonly,
      color: color
    });
  } // if fillRatio is not 1 or zero, absolutely position selected star above the
  // unselected star and clip both to form partially selected star.


  return jsxs(Fragment, {
    children: [jsx("div", Object.assign({
      class: fractionalStar.base,
      style: {
        clipPath: `inset(0% ${isRtl ? (1 - fillRatio) * 100 : 0}% 0% ${isRtl ? 0 : fillRatio * 100}%)`
      }
    }, {
      children: jsx(RatingStar, {
        isSelected: false,
        isDisabled: isDisabled,
        isReadOnly: isReadonly,
        color: color
      })
    })), jsx("div", Object.assign({
      class: fractionalStar.base,
      style: {
        clipPath: `inset(0% ${isRtl ? 0 : (1 - fillRatio) * 100}% 0% ${isRtl ? (1 - fillRatio) * 100 : 0}%)`
      }
    }, {
      children: jsx(RatingStar, {
        isSelected: true,
        isDisabled: isDisabled,
        isReadOnly: isReadonly,
        color: color
      })
    }))]
  });
};

const fractionalStar = {
  base: "_1jc9xk2"
};

/**
 * @license
 * Copyright (c) %FIRST_YEAR% %CURRENT_YEAR%, Oracle and/or its affiliates.
 * The Universal Permissive License (UPL), Version 1.0
 * as shown at https://oss.oracle.com/licenses/upl/
 * @ignore
 */
const useEvents = (max, step, value, rootRef, dimensionsRef, isInteractive, onCommit, onInput) => {
    const currentInput = useRef();
    const { direction } = useUser();
    if (!isInteractive) {
        return {};
    }
    const isRtl = direction === 'rtl';
    const handleInput = (inputValue) => {
        onInput === null || onInput === void 0 ? void 0 : onInput({ value: inputValue });
        currentInput.current = inputValue;
    };
    const cancelEvent = (event) => {
        event.preventDefault();
        event.stopPropagation();
    };
    const pointerUpHandler = (event) => {
        const val = getValue(event.pageX, max, step, dimensionsRef, isRtl);
        if (val !== -1) {
            onCommit === null || onCommit === void 0 ? void 0 : onCommit({ value: val });
        }
    };
    // When the document or rating gauge parent scrolls, we need to update the dimensionRef.current.x.
    // Instead of updating it for every scroll event, recalculate the dims the first time mouse enters
    // so we get fresh dimension value.
    const pointerEnterHandler = () => {
        dimensionsRef.current = getDimensions(rootRef.current);
    };
    const hoverHandler = (event) => {
        const val = getValue(event.pageX, max, step, dimensionsRef, isRtl);
        if (val !== -1 && val != currentInput.current) {
            handleInput(val);
        }
    };
    const blurHandler = () => {
        onCommit === null || onCommit === void 0 ? void 0 : onCommit({ value: value });
    };
    const pointerLeaveHandler = () => {
        handleInput(undefined);
    };
    const keyDownHandler = (event) => {
        const key = event.key;
        switch (key) {
            case 'Tab':
                return;
            case 'ArrowDown':
                handleInput(Math.max(0, value - step));
                break;
            case 'ArrowUp':
                handleInput(Math.min(max, value + step));
                break;
            case 'ArrowLeft': {
                const inputValue = isRtl ? Math.min(max, value + step) : Math.max(0, value - step);
                handleInput(inputValue);
                break;
            }
            case 'ArrowRight': {
                const inputValue = isRtl ? Math.max(0, value - step) : Math.min(max, value + step);
                handleInput(inputValue);
                break;
            }
        }
        cancelEvent(event);
    };
    const keyUpHandler = (event) => {
        const key = event.key;
        switch (key) {
            case 'Enter':
                onCommit === null || onCommit === void 0 ? void 0 : onCommit({ value: value });
                break;
            case 'Tab':
                handleInput(value);
                break;
            case 'Home':
                handleInput(0);
                break;
            case 'End':
                handleInput(max);
                break;
        }
        cancelEvent(event);
    };
    return {
        onPointerUp: pointerUpHandler,
        onBlur: blurHandler,
        onPointerMove: hoverHandler,
        onKeyUp: keyUpHandler,
        onKeyDown: keyDownHandler,
        onPointerLeave: pointerLeaveHandler,
        onPointerEnter: pointerEnterHandler
    };
};

function useTooltipOrDatatip({ max, value, isReadonly, isDisabled, tooltip, datatip, thresholds, ariaDescribedBy, width }) {
    var _a;
    const [isOpen, setIsOpen] = useState(false);
    const tooltipVariant = isReadonly && !isDisabled ? 'tooltip' : 'datatip';
    let disabled = isDisabled ||
        !((tooltipVariant === 'tooltip' && tooltip) || (tooltipVariant === 'datatip' && datatip));
    const datatipIndex = Math.max(1, Math.ceil(value));
    const offset = tooltipVariant === 'tooltip' ? 0 : ((datatipIndex - Math.ceil(max / 2)) * width) / max;
    let text = tooltipVariant === 'tooltip' ? tooltip : datatip;
    if (!text && thresholds && !isDisabled) {
        text = (_a = findThreshold(value, thresholds)) === null || _a === void 0 ? void 0 : _a.accessibleLabel;
        disabled = false;
    }
    const { tooltipContent, tooltipProps } = useTooltipControlled({
        text,
        isOpen,
        anchor: {
            x: 'element',
            y: 'element'
        },
        position: 'bottom',
        offset: {
            mainAxis: 8,
            crossAxis: offset
        },
        isDisabled: disabled,
        onToggle: ({ value }) => setIsOpen(value),
        variant: tooltipVariant
    });
    tooltipProps['aria-describedby'] = [ariaDescribedBy, tooltipProps['aria-describedby']]
        .filter(Boolean)
        .join(' ');
    return {
        tooltipContent,
        tooltipProps
    };
}

/**
 * A rating gauge displays information graphically, typically displaying or accepting user feedback on a product or service.
 */

function RatingGauge(_a) {
  var {
    max = 5,
    value = 0,
    size = 'md',
    color = 'neutral',
    step = 1,
    isReadonly,
    isDisabled
  } = _a,
      props = __rest(_a, ["max", "value", "size", "color", "step", "isReadonly", "isDisabled"]);

  const rootRef = useRef(null);
  const dimensionsRef = useRef(getDimensions(null));
  const isInteractive = !isReadonly && !isDisabled; // Since the dimension are compute lazily after render, store width and x in ref
  // This is used to identify hovered and clicked star.
  // width of the gauge depends on size and max so passing them as dependencies for useEffect

  useEffect(() => {
    dimensionsRef.current = getDimensions(rootRef.current);
  }, [size, max]);
  const eventProps = useEvents(max, step, value, rootRef, dimensionsRef, isInteractive, props.onCommit, props.onInput);
  const {
    tooltipContent,
    tooltipProps
  } = useTooltipOrDatatip({
    max,
    value,
    isReadonly,
    isDisabled,
    tooltip: props.tooltip,
    datatip: props.datatip,
    thresholds: props.thresholds,
    width: dimensionsRef.current.width,
    ariaDescribedBy: props.ariaDescribedBy
  });
  const ariaProps = getRatingAriaProps(value, max, props.accessibleLabel, props.ariaLabelledBy, isDisabled, isReadonly, props.thresholds, props.tooltip);
  const mergedEventProps = mergeProps(eventProps, tooltipProps);
  color = getThresholdColorFromValue(value, color, props.thresholds);
  const {
    isTabbable
  } = useTabbableMode();
  return jsxs(Fragment, {
    children: [jsx("div", Object.assign({}, ariaProps, {
      ref: rootRef,
      class: classNames([ratingStyles.base, isInteractive ? ratingStyles.interactive : undefined]),
      tabIndex: isTabbable && !isDisabled ? 0 : -1
    }, mergedEventProps, {
      children: [...Array(max)].map((_, index) => {
        const fillRatio = Math.min(Math.max(0, value - index), 1);
        return jsx("div", Object.assign({
          className: classNames([ratingStyles[size], ratingStyles.item])
        }, {
          children: jsx(RatingGaugeItem, {
            fillRatio: fillRatio,
            isDisabled: isDisabled,
            isReadonly: isReadonly,
            color: color
          })
        }));
      })
    })), tooltipContent]
  });
}
const ratingStyles = {
  base: "_1fj0k1z",
  interactive: "rjkqg4",
  lg: "_11u8p91",
  md: "_15bduhr",
  sm: "_17epsf2",
  item: "_1f8kk8e"
};

export { RatingGauge };
/*  */
//# sourceMappingURL=UNSAFE_RatingGauge.js.map
