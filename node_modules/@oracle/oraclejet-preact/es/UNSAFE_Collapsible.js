/* @oracle/oraclejet-preact: 14.1.0 */
import { jsx, jsxs, Fragment as Fragment$1 } from 'preact/jsx-runtime';
import { useCallback, useState, useRef, useEffect } from 'preact/hooks';
import { useId } from './hooks/UNSAFE_useId.js';
import { Fragment } from 'preact';
import "./UNSAFE_Collapsible.css";
import { classNames } from './utils/UNSAFE_classNames.js';
import { Flex } from './UNSAFE_Flex.js';
import { Divider } from './UNSAFE_Divider.js';
import { CollapseIcon } from './UNSAFE_ThemedIcons.js';
import { IcoChevronDown as SvgIcoChevronDown, IcoChevronUp as SvgIcoChevronUp } from './UNSAFE_Icons.js';
import { usePress } from './hooks/UNSAFE_usePress.js';
import { useAnimation } from './hooks/UNSAFE_useAnimation.js';
import './tslib.es6-821b2d99.js';
import './utils/UNSAFE_interpolations/dimensions.js';
import './utils/UNSAFE_arrayUtils.js';
import './utils/UNSAFE_size.js';
import './_curry1-ab762f3c.js';
import './utils/UNSAFE_mergeInterpolations.js';
import './_curry3-77af75f1.js';
import './_curry2-9cf34233.js';
import './_has-e54ed87c.js';
import './utils/UNSAFE_interpolations/boxalignment.js';
import './keys-6f2f2841.js';
import './utils/UNSAFE_interpolations/flexbox.js';
import './utils/UNSAFE_interpolations/flexitem.js';
import './UNSAFE_Icon.js';
import './hooks/UNSAFE_useTooltip.js';
import './UNSAFE_Floating.js';
import 'preact/compat';
import './index-8cf878d9.js';
import './hooks/UNSAFE_useUser.js';
import './UNSAFE_Environment.js';
import './UNSAFE_Layer.js';
import './utils/PRIVATE_floatingUtils.js';
import './utils/PRIVATE_refUtils.js';
import './hooks/UNSAFE_useOutsideClick.js';
import './hooks/UNSAFE_useHover.js';
import './hooks/UNSAFE_useToggle.js';
import './hooks/UNSAFE_useFocus.js';
import './hooks/UNSAFE_useTouch.js';
import './utils/UNSAFE_mergeProps.js';
import './hooks/UNSAFE_useTheme.js';

/**
 * Header icon subcomponent
 */
const CollapsibleHeaderIcon = ({ isExpanded, iconPosition }) => {
    const startIcon = iconPosition === 'start' && isExpanded ? SvgIcoChevronDown : CollapseIcon;
    const endIcon = iconPosition === 'end' && isExpanded ? SvgIcoChevronUp : SvgIcoChevronDown;
    const Icon = iconPosition === 'start' ? startIcon : endIcon;
    return jsx(Icon, { size: "6x" });
};

const styles$1 = {
  base: "_2jyr9e",
  expanded: "_1ml1kiv",
  disabled: "_1c0td7o",
  divider: "_9a6uct"
};
const childrenStylesBase = {
  base: "_1yoqog3",
  iconStart: "_5obyd7",
  iconEnd: "_1w1udn6"
};
/**
 * Header subcomponent
 */

const CollapsibleHeader = ({
  children,
  id,
  contentId,
  isDisabled,
  isExpanded,
  iconPosition,
  variant = 'basic',
  toggleHandler
}) => {
  const classes = classNames([styles$1.base, variant === 'horizontal-rule' && styles$1.divider, isExpanded && variant !== 'horizontal-rule' && styles$1.expanded, isDisabled && styles$1.disabled]);
  const childrenClasses = classNames([childrenStylesBase.base, iconPosition === 'end' && childrenStylesBase.iconEnd, iconPosition === 'start' && childrenStylesBase.iconStart]);
  const pressHandler = useCallback(event => {
    toggleHandler(event.target);
  }, [toggleHandler]);
  const {
    pressProps
  } = usePress(pressHandler, {
    isDisabled,
    isRepeat: false
  });

  const getHeader = () => jsxs(Fragment, {
    children: [iconPosition === 'end' && jsx("div", Object.assign({
      className: childrenClasses
    }, {
      children: children
    })), jsx(CollapsibleHeaderIcon, {
      iconPosition: iconPosition,
      isExpanded: isExpanded
    }), iconPosition === 'start' && jsx("div", Object.assign({
      className: childrenClasses
    }, {
      children: children
    }))]
  });

  return jsxs(Fragment$1, {
    children: [jsx("div", Object.assign({
      role: 'button',
      "aria-controls": contentId,
      "aria-expanded": isExpanded,
      id: id,
      tabIndex: 0,
      className: classes
    }, pressProps, {
      children: jsx(Flex, Object.assign({
        align: "center",
        justify: iconPosition === 'start' ? 'start' : 'between'
      }, {
        children: getHeader()
      }))
    })), variant === 'horizontal-rule' && jsx(Divider, {})]
  });
};

const styles = "_1ri29hl";
const CollapsibleContent = ({
  children,
  id,
  isExpanded,
  onTransitionEnd
}) => {
  const [state, setState] = useState(isExpanded ? 'expanding' : 'unmounted');
  /**
   * 1. On initial render, Preact sets style.maxHeight field to 0 or 'none'.
   * 2. During expanding animation, useAnimation hook uses WAAPI to animate the maxHeight out
   *    to the expanded value.
   * 3. On subsequent re-renders, Preact does never updates the style.maxHeight value
   *    because even though we are telling Preact that maxHeight should be 0 or 'none', Preact
   *    considers the maxHeight value is 0 or 'none' as it is not aware that we changed this value
   *    in step 2. So from Preact's perspective there is no difference.
   */

  const contentInitialStyle = useRef({
    overflowY: 'hidden',
    maxHeight: isExpanded ? 'none' : '0'
  });
  useEffect(() => {
    // Ignore state update on initial render
    if (state === 'unmounted' && !isExpanded) {
      return;
    }

    setState(isExpanded ? 'expanding' : 'collapsing');
  }, [isExpanded, state]);
  const {
    nodeRef
  } = useAnimation(state, {
    animationStates,
    onAnimationEnd: ({
      animationState
    }) => {
      if (animationState === 'collapsing') {
        setState('unmounted');
      }

      onTransitionEnd === null || onTransitionEnd === void 0 ? void 0 : onTransitionEnd();
    }
  });
  return jsx("div", Object.assign({
    className: styles,
    ref: nodeRef,
    id: id,
    tabIndex: -1,
    style: contentInitialStyle.current,
    "aria-hidden": !isExpanded || undefined
  }, {
    children: state !== 'unmounted' && children
  }));
};
/**
 * The transition from collapsed to expanded works as follows:
 * 1. When the component is initially rendered in the collapsed state, we
 *    explicitly set maxHeight and overflowY from "to" configuration.
 * 2. When the expanded prop changes from false to true, we first mount the content children.
 * 3. Once this is mounted we trigger an animation updating animationState value of useAnimationHook.
 * 4. Configuration is represented inside hook. Passed config depends if previous animation was completed or not.
 *    We could check that based on node.style.maxHeight.
 *
 * The transition from expanded to collapsed is similar:
 * 1. We trigger an animation updating animationState value of useAnimationHook.
 * 2. Once animation is completed, with the help of end config,we set max-Height as 'none'.
 *    This will allow us to keep adding content.
 * 3. Once this is done, onAnimationEnd is called(as 'from collapsed to expanded"). Here, content children are unmouunted.
 */

const animationStates = {
  expanding: node => ({
    to: {
      maxHeight: `${node.scrollHeight}px`
    },
    options: {
      duration: 400
    },
    end: {
      maxHeight: 'none'
    }
  }),
  collapsing: node => Object.assign(Object.assign({}, node.style.maxHeight === 'none' && {
    from: {
      maxHeight: `${node.scrollHeight}px`
    }
  }), {
    to: {
      maxHeight: '0'
    },
    options: {
      duration: 400
    }
  })
};

/**
 * A collapsible displays a header that can be expanded to show its content.
 */
const Collapsible = ({ id, header, children, isDisabled = false, isExpanded = false, iconPosition = 'start', variant = 'basic', onToggle, onTransitionEnd }) => {
    const rootRef = useRef(null);
    const uniqueID = useId();
    const headerId = `oj-collapsible-header-${uniqueID}`;
    const contentId = `oj-collapsible-content-${uniqueID}`;
    /**
     * Function handling toggle and invoking callback for collapsing/expanding
     */
    const toggleHandler = useCallback((target) => {
        if (isDisabled) {
            return;
        }
        onToggle === null || onToggle === void 0 ? void 0 : onToggle({
            value: !isExpanded,
            target
        });
    }, [isDisabled, onToggle, isExpanded]);
    /**
     * Function that is triggerd when animation ends
     */
    const transitionEndHandler = useCallback(() => {
        onTransitionEnd === null || onTransitionEnd === void 0 ? void 0 : onTransitionEnd({
            value: isExpanded
        });
    }, [onTransitionEnd, isExpanded]);
    return (jsxs("div", Object.assign({ id: id, ref: rootRef }, { children: [jsx(CollapsibleHeader, Object.assign({ id: headerId, contentId: contentId, toggleHandler: toggleHandler, isDisabled: isDisabled, isExpanded: isExpanded, iconPosition: iconPosition, variant: variant }, { children: header })), jsx(CollapsibleContent, Object.assign({ id: contentId, isExpanded: isExpanded, onTransitionEnd: transitionEndHandler }, { children: children }))] })));
};

/**
 * @license
 * Copyright (c) %FIRST_YEAR% %CURRENT_YEAR%, Oracle and/or its affiliates.
 * The Universal Permissive License (UPL), Version 1.0
 * as shown at https://oss.oracle.com/licenses/upl/
 * @ignore
 */

export { Collapsible };
/*  */
//# sourceMappingURL=UNSAFE_Collapsible.js.map
