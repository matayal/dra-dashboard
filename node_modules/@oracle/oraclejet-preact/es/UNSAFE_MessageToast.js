/* @oracle/oraclejet-preact: 14.1.0 */
import { jsx, jsxs } from 'preact/jsx-runtime';
import "./UNSAFE_MessageToast.css";
import { useRef, useState, useImperativeHandle, useCallback, useEffect, useMemo } from 'preact/hooks';
import { EnvironmentProvider } from './UNSAFE_Environment.js';
import { useMessageFocusManager } from './hooks/PRIVATE_useMessagesFocusManager.js';
import { useBreakpointValues } from './hooks/UNSAFE_useBreakpointValues.js';
import { useTranslationBundle } from './hooks/UNSAFE_useTranslationBundle.js';
import { MessagesManager, Message, getRendererWithoutIndex } from './PRIVATE_Message.js';
import { MessageLayer } from './PRIVATE_MessageLayer.js';
import { Flex } from './UNSAFE_Flex.js';
import { FocusTrap } from './UNSAFE_FocusTrap.js';
import { LiveRegion } from './UNSAFE_LiveRegion.js';
import { stringLiteralArray } from './utils/UNSAFE_arrayUtils.js';
import { classNames } from './utils/UNSAFE_classNames.js';
import 'preact';
import './UNSAFE_Layer.js';
import 'preact/compat';
import './hooks/UNSAFE_useBreakpoints.js';
import './utils/PRIVATE_timer.js';
import './UNSAFE_Button.js';
import './UNSAFE_BaseButton.js';
import './tslib.es6-821b2d99.js';
import './hooks/UNSAFE_usePress.js';
import './hooks/UNSAFE_useHover.js';
import './hooks/UNSAFE_useToggle.js';
import './hooks/UNSAFE_useActive.js';
import './utils/UNSAFE_interpolations/dimensions.js';
import './utils/UNSAFE_size.js';
import './_curry1-ab762f3c.js';
import './utils/UNSAFE_mergeInterpolations.js';
import './_curry3-77af75f1.js';
import './_curry2-9cf34233.js';
import './_has-e54ed87c.js';
import './utils/PRIVATE_clientHints.js';
import './hooks/UNSAFE_useTabbableMode.js';
import './utils/UNSAFE_mergeProps.js';
import './UNSAFE_ThemedIcons.js';
import './UNSAFE_Icons.js';
import './UNSAFE_Icon.js';
import './hooks/UNSAFE_useTooltip.js';
import './hooks/UNSAFE_useId.js';
import './UNSAFE_Floating.js';
import './index-8cf878d9.js';
import './hooks/UNSAFE_useUser.js';
import './utils/PRIVATE_floatingUtils.js';
import './utils/PRIVATE_refUtils.js';
import './hooks/UNSAFE_useOutsideClick.js';
import './hooks/UNSAFE_useFocus.js';
import './hooks/UNSAFE_useTouch.js';
import './hooks/UNSAFE_useAnimation.js';
import './hooks/UNSAFE_useTheme.js';
import './utils/UNSAFE_getLocale.js';
import './utils/UNSAFE_stringUtils.js';
import './utils/UNSAFE_logger.js';
import './utils/UNSAFE_soundUtils.js';
import './PRIVATE_TransitionGroup.js';
import './hooks/UNSAFE_useMessagesContext.js';
import './utils/UNSAFE_interpolations/boxalignment.js';
import './keys-6f2f2841.js';
import './utils/UNSAFE_interpolations/flexbox.js';
import './utils/UNSAFE_interpolations/flexitem.js';
import './UNSAFE_WindowOverlay.js';
import './utils/PRIVATE_tabbableUtils.js';

// https://jira.oraclecorp.com/jira/browse/JET-54212

const positions = stringLiteralArray(['top', 'top-left', 'top-right', 'top-start', 'top-end', 'bottom', 'bottom-left', 'bottom-right', 'bottom-start', 'bottom-end']);
const messageToastStyles = {
  base: "_25074t"
};
/**
 * Animation states for toast messages
 * TODO: Get this from theme context provider
 */

const animationStates = {
  entering: node => ({
    from: {
      transform: `translate(0, ${node.offsetHeight}px)`,
      opacity: 1
    },
    to: {
      transform: 'translate(0, 0)',
      opacity: 1
    },
    end: {
      transform: 'unset',
      opacity: 1
    },
    options: {
      duration: 250
    }
  }),
  exiting: {
    from: {
      opacity: 1
    },
    to: {
      opacity: 0
    },
    end: {
      opacity: 0
    },
    options: {
      duration: 250
    }
  }
};
const initialAnimationStyles = {
  opacity: 0
};
function MessageToast({
  data,
  detailRendererKey,
  iconRendererKey,
  renderers,
  onClose,
  offset,
  position
}) {
  var _a, _b, _c, _d;

  const messagesRef = useRef(new Map());
  const autoFocusRef = useRef(null);
  const containerDivRef = useRef(null);
  const focusHandleRef = useRef(null);
  const [liveRegionText, setLiveRegionText] = useState();
  const [shouldRender, setShouldRender] = useState(data.length > 0);
  const [shouldTrapFocus, setShouldTrapFocus] = useState(false);
  const translations = useTranslationBundle('@oracle/oraclejet-preact'); // We need a ref that holds the current & previous data length, as the exiting
  // node will always call handleNextFocus with previous data.
  // As in TransitionGroup, when an item is removed from the data, a new vnode
  // will not be created instead previous vnode will be used. So, the new handleNextFocus
  // will not be called when the old vnode exits. Thus, we will be using a ref
  // to always get the correct current data length.

  const dataLengthRef = useRef(data.length);
  const prevDataLengthRef = useRef(0); // Update the data length ref

  dataLengthRef.current = data.length; // Update the focusHandleRef

  useImperativeHandle(focusHandleRef, () => ({
    focus: () => {
      var _a; // Only trigger focus if the component is rendering messages


      if (data.length) {
        // set the autoFocus ref to the first message and enable the focus trap
        // this will automatically focus the first message
        autoFocusRef.current = (_a = messagesRef.current.get(data[0].key)) !== null && _a !== void 0 ? _a : null;
        setShouldTrapFocus(true);
        return true;
      }

      return false;
    },
    contains: element => {
      var _a, _b; // Only invoke method if the component is rendering messages


      if (data.length && element) {
        return (_b = (_a = containerDivRef.current) === null || _a === void 0 ? void 0 : _a.contains(element)) !== null && _b !== void 0 ? _b : false;
      }

      return false;
    }
  }), [data]); // Register handlers for focus management

  const {
    controller,
    handlers
  } = useMessageFocusManager(focusHandleRef, {
    onFocus: useCallback(() => {
      setLiveRegionText(translations.message_navigationFromMessagesRegion());
    }, [translations]),
    onFocusLeave: useCallback(() => {
      // disable trap which should revert the focus back to the last focused item
      setShouldTrapFocus(false);
    }, [])
  }, {
    // we do not want the focus manager to handle Esc key as we handle it using the
    // FocusTrap here
    handleEscapeKey: false
  });
  /**
   * Handles focus when a message is closed and animated away from the DOM
   * @param key The key of the message
   * @param index The index of the message
   */

  const handleNextFocus = useCallback((_key, index, closedMessageNode) => {
    var _a;

    const isClosedMessageFocused = closedMessageNode === null || closedMessageNode === void 0 ? void 0 : closedMessageNode.contains(document.activeElement); // If there are no messages, do not render anything. As the old messages
    // are still in the DOM, use the data count to determine what to do next as it
    // represents the next state.

    if (dataLengthRef.current === 0) {
      setShouldRender(false);
      setShouldTrapFocus(false); // If the current message holds focus, then restore previous focus

      if (isClosedMessageFocused) {
        // As we have FocusTrap, trying to restore focus now will simply result in focus being pulled
        // back again. So, we restore the focus in the next tick so that the rendering will have been
        // done in the microtask.
        setImmediate(() => controller.restorePriorFocus());
      }

      return;
    } // In TransitionGroup, when an item is removed from the data, a new vnode
    // will not be created instead previous vnode will be used. So, the new handleNextFocus
    // will not be called when the old vnode exits. Thus, all the deps will not be pointing to
    // the current references, rather they will be pointing to the ones where this vnode
    // last existed in the data.
    // This means, the data will contain the closing message as well. But, all the ref objects
    // still point to the most up-to-date values. With that in mind, we will be evaluating the
    // following values.


    const renderedMessagesCount = data.length; // Now that this message is closed, focus the next message that will take this index. If no
    // message will take this message's index, then it means that this is the last message. If
    // that is the case, focus the message at the previous index.
    // Use the count of the messages that are currently shown in the UI (current state including
    // the message that will be removed). This way we can get the correct item from the data
    // as it will contain the closing message as well.

    const nextMessageIndexToFocus = index + 1 < renderedMessagesCount ? index + 1 : index - 1; // if next message is available then transfer the focus to the next element

    if (nextMessageIndexToFocus > -1 && isClosedMessageFocused) {
      const nextMessageKey = data[nextMessageIndexToFocus].key;
      (_a = messagesRef.current.get(nextMessageKey)) === null || _a === void 0 ? void 0 : _a.focus();
    }
  }, [controller, data]); // We will be using a function based ref to store the refs in the Map

  const setHTMLDivElement = useCallback( // TODO: use ramda.curry here (currently it is throwing ts error when used with generics)
  key => {
    return ref => messagesRef.current.set(key, ref);
  }, []); // Prioritize this component whenever the data changes and
  // the new data has at least one message

  useEffect(() => {
    const previousDataLength = prevDataLengthRef.current;
    prevDataLengthRef.current = data.length; // if there are messages that need to be rendered now, then do the following deeds:
    // 1. set the shouldRender flag
    // 2. set the live region
    // 3. prioritize this message component to be the latest

    if (data.length) {
      // set state to render content whenever the data is not empty
      setShouldRender(true);

      if (data.length > previousDataLength) {
        // Only when having a new message, update the aria-live area with the
        // text to indicate how to get the focus to the new message.
        setLiveRegionText(translations.message_navigationToMessagesRegion());
      }

      controller.prioritize();
      return;
    } // if there were messages and now removed, then set the live region to
    // announce this information


    if (previousDataLength) {
      setLiveRegionText(translations.messageToast_allMessagesClosed());
      return;
    } // When there are no messages, clear the live region so that
    // the navigation text will be read when a new message appear


    setLiveRegionText('');
  }, [controller, data.length, translations]); // determine responsive max-width

  const maxWidth = useBreakpointValues({
    sm: '--oj-c-PRIVATE-DO-NOT-USE-message-toast-max-width-sm',
    md: '--oj-c-PRIVATE-DO-NOT-USE-message-toast-max-width-md',
    lg: '--oj-c-PRIVATE-DO-NOT-USE-message-toast-max-width-lg'
  }); // without offset, the messages will be hugging the vertical edges of the screen
  // so we will set a default offset.vertical value (any offset from the props will be
  // added to this).

  const paddedOffset = useBreakpointValues({
    sm: {
      horizontal: typeof offset === 'number' ? offset : (_a = offset === null || offset === void 0 ? void 0 : offset.horizontal) !== null && _a !== void 0 ? _a : 0,
      vertical: 16 + (typeof offset === 'number' ? offset : (_b = offset === null || offset === void 0 ? void 0 : offset.horizontal) !== null && _b !== void 0 ? _b : 0)
    },
    lg: {
      horizontal: typeof offset === 'number' ? offset : (_c = offset === null || offset === void 0 ? void 0 : offset.horizontal) !== null && _c !== void 0 ? _c : 0,
      vertical: 24 + (typeof offset === 'number' ? offset : (_d = offset === null || offset === void 0 ? void 0 : offset.horizontal) !== null && _d !== void 0 ? _d : 0)
    }
  }); // TODO: move this to the individual components.
  // Cannot do this as of now, as doing do results in oj-message-banner not working.

  const messageTranslations = useMemo(() => ({
    close: translations.close(),
    confirmation: translations.confirmation(),
    error: translations.error(),
    info: translations.info(),
    warning: translations.warn()
  }), [translations]);
  const rootClasses = classNames([messageToastStyles.base, // by default the toast messages are dark, so add the required classes
  'oj-c-colorscheme-dark', 'oj-color-invert']); // When both shouldRender flag is false and no data to render, do not render
  // anything except the live region

  if (!shouldRender && data.length === 0) {
    return jsx(LiveRegion, {
      children: liveRegionText
    });
  }

  return jsxs(EnvironmentProvider, Object.assign({
    environment: {
      colorScheme: 'dark'
    }
  }, {
    children: [jsx(MessageLayer, Object.assign({
      offset: paddedOffset,
      position: position
    }, {
      children: jsx("div", Object.assign({
        class: rootClasses,
        ref: containerDivRef,
        tabIndex: -1
      }, handlers, {
        children: jsx(FocusTrap, Object.assign({
          autoFocusRef: autoFocusRef,
          isDisabled: !shouldTrapFocus
        }, {
          children: jsx(Flex, Object.assign({
            direction: "column",
            gap: "1x",
            align: "center",
            maxWidth: maxWidth
          }, {
            children: jsx(MessagesManager, Object.assign({
              animationStates: animationStates,
              initialAnimationStyles: initialAnimationStyles,
              data: data,
              onMessageWillRemove: handleNextFocus
            }, {
              children: ({
                index,
                item
              }) => jsx(Message, {
                messageRef: setHTMLDivElement(item.key),
                item: item,
                detailRenderer: getRendererWithoutIndex(item, detailRendererKey, renderers),
                iconRenderer: getRendererWithoutIndex(item, iconRendererKey, renderers),
                index: index,
                onClose: onClose,
                translations: messageTranslations,
                variant: "toast"
              }, item.key)
            }))
          }))
        }))
      }))
    })), jsx(LiveRegion, {
      children: liveRegionText
    })]
  }));
}

/**
 * @license
 * Copyright (c) %FIRST_YEAR% %CURRENT_YEAR%, Oracle and/or its affiliates.
 * The Universal Permissive License (UPL), Version 1.0
 * as shown at https://oss.oracle.com/licenses/upl/
 * @ignore
 */

export { MessageToast };
/*  */
//# sourceMappingURL=UNSAFE_MessageToast.js.map
