/* @oracle/oraclejet-preact: 14.1.0 */
import { _ as __rest } from './tslib.es6-821b2d99.js';
import { jsx, jsxs } from 'preact/jsx-runtime';
import { ButtonLayout } from './UNSAFE_Button.js';
import './UNSAFE_ThemedIcons.js';
import { Menu } from './UNSAFE_Menu.js';
import { BaseButton } from './UNSAFE_BaseButton.js';
import { classNames } from './utils/UNSAFE_classNames.js';
import { TabbableModeContext } from './hooks/UNSAFE_useTabbableMode.js';
import { dimensionInterpolations } from './utils/UNSAFE_interpolations/dimensions.js';
import { mergeInterpolations } from './utils/UNSAFE_mergeInterpolations.js';
import "./UNSAFE_SplitMenuButton.css";
import { forwardRef } from 'preact/compat';
import { useState, useCallback, useRef, useImperativeHandle } from 'preact/hooks';
import { IcoNavDown as SvgIcoNavDown } from './UNSAFE_Icons.js';
import './hooks/UNSAFE_usePress.js';
import './hooks/UNSAFE_useHover.js';
import './hooks/UNSAFE_useToggle.js';
import './hooks/UNSAFE_useActive.js';
import './utils/UNSAFE_arrayUtils.js';
import './utils/UNSAFE_size.js';
import './_curry1-ab762f3c.js';
import './_curry3-77af75f1.js';
import './_curry2-9cf34233.js';
import './_has-e54ed87c.js';
import './utils/PRIVATE_clientHints.js';
import 'preact';
import './utils/UNSAFE_mergeProps.js';
import './UNSAFE_Icon.js';
import './hooks/UNSAFE_useTooltip.js';
import './hooks/UNSAFE_useId.js';
import './UNSAFE_Floating.js';
import './index-8cf878d9.js';
import './hooks/UNSAFE_useUser.js';
import './UNSAFE_Environment.js';
import './UNSAFE_Layer.js';
import './utils/PRIVATE_floatingUtils.js';
import './utils/PRIVATE_refUtils.js';
import './hooks/UNSAFE_useOutsideClick.js';
import './hooks/UNSAFE_useFocus.js';
import './hooks/UNSAFE_useTouch.js';
import './hooks/UNSAFE_useAnimation.js';
import './hooks/UNSAFE_useTheme.js';
import './hooks/PRIVATE_useCollectionFocusRing.js';
import './useModal-beb96266.js';
import './UNSAFE_Text.js';
import './UNSAFE_Divider.js';

const compStyles = {
  divider: "c1h60y",
  disabledDivider: "uux5cg",
  icon: "t21kt4",
  root: "_1nrm1ys",
  childrenMargins: "_1qzg7e1"
};
const menuButtonStyling = ['embedded', 'min', 'noBorderRadiusStart'];
const menuButtonActiveStyling = [...menuButtonStyling, 'active'];
const actionbuttonStyling = ['embedded', 'fill', 'noBorderRadiusEnd'];
const actionButtonActiveStyling = [...actionbuttonStyling, 'active'];
const interpolations = [...Object.values(dimensionInterpolations)];
const styleInterpolations = mergeInterpolations(interpolations);
/**
 * A SplitMenuButton is a combined action and menu button.
 */

const SplitMenuButton = forwardRef((_a, ref) => {
  var {
    children,
    label = '',
    variant = 'outlined',
    isDisabled = false,
    size = 'md',
    onAction
  } = _a,
      props = __rest(_a, ["children", "label", "variant", "isDisabled", "size", "onAction"]);

  const [isMenuOpen, setIsMenuOpen] = useState(false);
  const [isActive, setIsActive] = useState(false);

  const _b = styleInterpolations(props),
        {
    class: cls
  } = _b,
        styles = __rest(_b, ["class"]); // SPACE or ENTER on root area invokes action, as does CLICK/TAP on LEFT SIDE ACTION AREA
  // DOWN ARROW invokes menu, as does CLICK/TAP on RIGHT SIDE MENU AREA


  const onKeyDown = useCallback(event => {
    if (event.key === ' ' || event.key === 'Enter') {
      setIsActive(true);
    } else if (event.key == 'ArrowDown') {
      !isDisabled && setIsMenuOpen(menuOpen => !menuOpen); // Prevent page scroll for down arrow, user definitely wanted to show menu in this case.
      // Don't prevent other keypress defaults, as user may want to hold SPACE down to scroll page.

      event.preventDefault();
    }
  }, [isDisabled, setIsMenuOpen, setIsActive]);
  const onKeyUp = useCallback(event => {
    if (event.key === ' ' || event.key === 'Enter') {
      !isDisabled && onAction && onAction();
      setIsActive(false);
    }
  }, [isDisabled, onAction, setIsActive]);
  const onBlur = useCallback(() => {
    setIsActive(false);
  }, [setIsActive]);

  const _ref = useRef(null);

  useImperativeHandle(ref, () => _ref.current, [_ref]);

  const menuHandler = () => {
    setIsMenuOpen(!isMenuOpen);
  };

  const handleClose = e => {
    var _a; //Focus has to be set on the launcher when menu is dismissed or
    //item is "selected"


    if (e.reason === 'dismissed' || e.reason === 'itemAction') {
      (_a = _ref.current) === null || _a === void 0 ? void 0 : _a.focus();
    }

    setIsMenuOpen(false);
  };

  const dividerStyles = classNames([compStyles.divider, isDisabled && compStyles.disabledDivider]);
  const rootStyles = classNames([compStyles.root]); // Using Span for top button allows us to avoid :hover state rendering by
  // taking advantage of :enabled not on spans

  const rootButton = () => {
    return jsx(BaseButton, Object.assign({
      elementDetails: {
        type: 'span'
      },
      ref: _ref,
      isDisabled: isDisabled,
      styling: ['container', 'min'],
      variant: variant,
      size: size,
      accessibleLabel: label,
      ariaRoledescription: "split menu button, press down arrow to invoke menu",
      ariaExpanded: isMenuOpen
    }, {
      children: jsxs(TabbableModeContext.Provider, Object.assign({
        value: {
          isTabbable: false
        }
      }, {
        children: [jsx(BaseButton, Object.assign({
          elementDetails: {
            type: 'span'
          },
          variant: variant,
          styling: getActionButtonStyling(isActive),
          size: size,
          isDisabled: isDisabled,
          ariaHidden: true,
          onAction: onAction
        }, {
          children: label
        })), jsx("div", {
          class: `${dividerStyles}`
        }), jsx(BaseButton, Object.assign({
          elementDetails: {
            type: 'span'
          },
          variant: variant,
          styling: getMenuButtonStyling(isMenuOpen),
          size: size,
          isDisabled: isDisabled,
          ariaHidden: true,
          onAction: menuHandler
        }, {
          children: jsx(ButtonLayout, {
            display: "icons",
            startIcon: jsx(SvgIcoNavDown, {}),
            size: size,
            styling: "embedded"
          })
        }))]
      }))
    }));
  };

  if (isDisabled) {
    return jsx("span", Object.assign({
      role: "toolbar",
      class: `${rootStyles} ${cls}`,
      style: styles
    }, {
      children: rootButton()
    }));
  } else {
    return jsxs("span", Object.assign({
      role: "toolbar",
      class: `${rootStyles} ${cls}`,
      style: styles,
      onKeyDown: !isDisabled && onKeyDown,
      onKeyUp: onKeyUp,
      onBlur: onBlur
    }, {
      children: [rootButton(), jsx(Menu, Object.assign({
        anchorRef: _ref,
        isOpen: isMenuOpen,
        onClose: handleClose
      }, {
        children: jsx("span", Object.assign({
          className: compStyles.childrenMargins
        }, {
          children: children
        }))
      }))]
    }));
  }
});

function getMenuButtonStyling(isActive) {
  return isActive ? menuButtonActiveStyling : menuButtonStyling;
}

function getActionButtonStyling(isActive) {
  return isActive ? actionButtonActiveStyling : actionbuttonStyling;
}

export { SplitMenuButton };
/*  */
//# sourceMappingURL=UNSAFE_SplitMenuButton.js.map
