/* @oracle/oraclejet-preact: 14.1.0 */
import { jsx, jsxs } from 'preact/jsx-runtime';
import { Fragment } from 'preact';
import { forwardRef, useRef, useCallback, useEffect } from 'preact/compat';
import { classNames } from './utils/UNSAFE_classNames.js';
import "./UNSAFE_FocusTrap.css";
import { focusOn, focusWithin, focusOnEnd, focusOnStart, getActiveElement, isTabbableElement } from './utils/PRIVATE_tabbableUtils.js';
import './_curry1-ab762f3c.js';
import './_curry2-9cf34233.js';
import './_curry3-77af75f1.js';

const styles = {
  guard: "_12fuqvg"
};
/**
 * Styled FocusTrap sub-component to render non-visible focus guards
 */

const FocusGuard = forwardRef(({
  onFocus
}, guardRef) => {
  return jsx("div", {
    class: styles.guard,
    onFocus: onFocus,
    ref: guardRef,
    tabIndex: 0
  });
});

/**
 * Trap focus within a DOM node.  When a user hits Tab or Shift+Tab, focus remains in the focus trap.
 */

const FocusTrap = ({
  autoFocusRef,
  children,
  isDisabled = false,
  restoreFocusRef
}) => {
  const trapRef = useRef(null);
  const startGuardRef = useRef(null);
  const endGuardRef = useRef(null);
  const lastActiveElementRef = useRef(null); // classes to be set on the children wrapper

  const classes = classNames([childrenStyles]);
  /**
   * contain focus if trap is enabled, and target is not already contained
   *
   * calling cases for side-effect of setting focus
   *   - on initial mount of (enabled) trap, where target is not inside trap
   *   - on enabling of a disabled trap, where target is not inside trap
   *   - target of click event is outside of trap.
   */

  const conditionallyContainFocus = useCallback(target => {
    const trap = trapRef.current; //  short-circuit, if trap or target not valid

    if (isDisabled || !trap || !target) return; // just update ref if, target already has focus

    if (target && hasFocus([trap, startGuardRef.current, endGuardRef.current], target)) {
      lastActiveElementRef.current = target;
      return;
    } // set focus to last active tab-stop if lastElement is defined and inside trap


    if (lastActiveElementRef.current) {
      focusOn(lastActiveElementRef.current);
    } else {
      // otherwise just contain focus within trap as target is outside enabled trap and we have no last-known tab-stop
      focusWithin(trap);
    }
  }, [isDisabled]); // loop focus

  const handleStartGuardOnFocus = event => {
    if (isDisabled || !trapRef.current) return;
    focusOnEnd(trapRef.current); // prevent scroll jump and bubbling this event up as a focus event

    event.stopPropagation();
    event.preventDefault();
  };

  const handleEndGuardOnFocus = event => {
    if (isDisabled || !trapRef.current) return;
    focusOnStart(trapRef.current); // prevent scroll jump and bubbling guard event up as a focus event

    event.stopPropagation();
    event.preventDefault();
  };

  const handleTrapOnFocus = event => {
    lastActiveElementRef.current = event.target;
  }; // handle initial render or re-render as enabled


  useEffect(() => {
    const trap = trapRef.current;
    if (!trap || isDisabled) return;
    const originalActiveElement = getActiveElement(trap); // init focus

    if (autoFocusRef && autoFocusRef.current) {
      focusOn(autoFocusRef.current);
    } else {
      conditionallyContainFocus(originalActiveElement);
    }

    const restoreFocusRefForCleanup = restoreFocusRef;
    return () => {
      if (restoreFocusRefForCleanup === false) return;
      restoreFocusAfterUnmount((restoreFocusRefForCleanup === null || restoreFocusRefForCleanup === void 0 ? void 0 : restoreFocusRefForCleanup.current) || originalActiveElement);
    };
  }, [autoFocusRef, conditionallyContainFocus, isDisabled, restoreFocusRef]);
  return jsxs(Fragment, {
    children: [!isDisabled && jsx(FocusGuard, {
      onFocus: handleStartGuardOnFocus,
      ref: startGuardRef
    }), jsx("div", Object.assign({
      onFocus: handleTrapOnFocus,
      ref: trapRef,
      class: classes
    }, {
      children: children
    })), !isDisabled && jsx(FocusGuard, {
      onFocus: handleEndGuardOnFocus,
      ref: endGuardRef
    })]
  });
}; // setTimeout ensures that unmount lifecycle has completed

const restoreFocusAfterUnmount = element => {
  if (element && isTabbableElement(element)) {
    setTimeout(() => {
      focusOn(element);
    }, 0);
  }
}; // is focus already contained?


const hasFocus = (elements, target) => {
  if (elements.length === 0) return false;
  const activeElement = target !== null && target !== void 0 ? target : getActiveElement(elements[0]);
  return elements.some(el => el === activeElement || (el === null || el === void 0 ? void 0 : el.contains(activeElement)));
}; // remove margins from children


const childrenStyles = "bviofz";

/**
 * @license
 * Copyright (c) %FIRST_YEAR% %CURRENT_YEAR%, Oracle and/or its affiliates.
 * The Universal Permissive License (UPL), Version 1.0
 * as shown at https://oss.oracle.com/licenses/upl/
 * @ignore
 */

export { FocusTrap };
/*  */
//# sourceMappingURL=UNSAFE_FocusTrap.js.map
