/* @oracle/oraclejet-preact: 14.1.0 */
import { jsxs, jsx } from 'preact/jsx-runtime';
import { useRef, useState, useLayoutEffect, useCallback, useMemo } from 'preact/hooks';
import { forwardRef } from 'preact/compat';
import { o as offset, b, D, L, m, k, u as useFloating, N } from './index-8cf878d9.js';
import { mergeRefs } from './utils/PRIVATE_refUtils.js';
import { useOutsideClick } from './hooks/UNSAFE_useOutsideClick.js';
import { useUser } from './hooks/UNSAFE_useUser.js';
import './utils/PRIVATE_floatingUtils.js';
import './utils/UNSAFE_arrayUtils.js';
import './UNSAFE_Environment.js';
import 'preact';
import './UNSAFE_Layer.js';

const FloatingTail = forwardRef(({}, arrowRef) => {
    return (jsxs("div", Object.assign({ ref: arrowRef }, { children: [" ", jsx("div", {}), " "] })));
});
function renderTail(data, anchorRef, arrowRef, tail, isRtl) {
    var _a, _b;
    if (tail === 'simple' && data.arrow) {
        const { x, y, centerOffset } = data.arrow;
        const arrowEl = arrowRef.current;
        const arrowSize = 7;
        const arrowSizeCorner = 6;
        const arrowInnerEl = (_a = arrowRef.current) === null || _a === void 0 ? void 0 : _a.querySelector('div');
        const arrowInnerSize = 5;
        const arrowInnerSizeCorner = 5;
        const arrowCommonStyle = {
            position: 'absolute',
            width: '0px',
            height: '0px'
        };
        let anchorRefHeight = 0;
        let anchorRefWidth = 0;
        const current = anchorRef.current;
        // @ts-ignore. Type 'Element | Coords' issues
        // Property 'x' does not exist on type 'Element'.
        // Property 'y' does not exist on type 'Element'.
        const isAnchorRefElement = (current === null || current === void 0 ? void 0 : current.x) === undefined && (current === null || current === void 0 ? void 0 : current.y) === undefined;
        if (isAnchorRefElement) {
            // @ts-ignore. Property 'getBoundingClientRect' does not exist on type 'Coords'.
            anchorRefHeight = Math.round(current.getBoundingClientRect().height);
            // @ts-ignore. Property 'getBoundingClientRect' does not exist on type 'Coords'.
            anchorRefWidth = Math.round((_b = anchorRef.current) === null || _b === void 0 ? void 0 : _b.getBoundingClientRect().width);
        }
        const isCornerVerticalPlacement = isAnchorRefElement ?
            Math.abs(centerOffset) >= anchorRefHeight / 2 - arrowSize / 2 :
            ['start-top-corner', 'start-bottom-corner', 'end-top-corner', 'end-bottom-corner'].includes(data.origPlacement);
        const isCornerHorizontalPlacement = isAnchorRefElement ?
            Math.abs(centerOffset) >= anchorRefWidth / 2 - arrowSize / 2 :
            ['top-start-corner', 'top-end-corner', 'bottom-start-corner', 'bottom-end-corner'].includes(data.origPlacement);
        const isCenter = centerOffset === 0;
        const isCenterOffsetPositive = centerOffset > 0;
        // Set styles of the arrow
        setElementStyle(arrowCommonStyle, arrowEl);
        setElementStyle(arrowCommonStyle, arrowInnerEl);
        // Set sizes of the arrow
        setArrowSizes(isCornerVerticalPlacement || isCornerHorizontalPlacement);
        // Corner vs. normal arrow
        function setArrowSizes(isCornerPlacement) {
            // Outer arrow (shadow)
            const arrowFinalSize = isCornerPlacement ? arrowSizeCorner : arrowSize;
            setArrowStyle({
                borderTop: `${getSize(arrowFinalSize)} solid rgba(var(--oj-c-PRIVATE-DO-NOT-USE-palette-neutral-rgb-90), 0.1)`,
                borderRight: getTransparentBorder(arrowFinalSize),
                borderLeft: getTransparentBorder(arrowFinalSize)
            });
            // Inner arrow
            const arrowInnerFinalSize = isCornerPlacement ? arrowInnerSizeCorner : arrowInnerSize;
            setArrowInnerStyle({
                borderTop: `${getSize(arrowInnerFinalSize)} solid var(--oj-c-PRIVATE-DO-NOT-USE-popup-bg-color)`,
                borderRight: `${getTransparentBorder(arrowInnerFinalSize)}`,
                borderLeft: `${getTransparentBorder(arrowInnerFinalSize)}`,
            });
        }
        function setElementStyle(style, element) {
            //@ts-ignore - regarding types arrowEl.style is not under our control
            Object.assign(element === null || element === void 0 ? void 0 : element.style, style);
        }
        function setArrowStyle(style) {
            setElementStyle(style, arrowEl);
        }
        function setArrowInnerStyle(style) {
            setElementStyle(style, arrowInnerEl);
        }
        function getTurn(eighth) {
            return `rotate(${(eighth) * 45}deg)`;
        }
        function getSize(size) {
            return `${size}px`;
        }
        function getTransparentBorder(size) {
            return `${getSize(size)} solid transparent`;
        }
        const placementArr = data.placement.split('-');
        const side = placementArr[0];
        switch (side) {
            case 'top':
                setArrowTop();
                break;
            case 'end':
                isRtl ? setArrowStart() : setArrowEnd();
                break;
            case 'bottom':
                setArrowBottom();
                break;
            case 'start':
                isRtl ? setArrowEnd() : setArrowStart();
                break;
        }
        function setArrowTop() {
            if (x != undefined) {
                if (isCornerHorizontalPlacement) {
                    // Top corners
                    setArrowStyle({
                        top: '',
                        bottom: getSize(-arrowSize + 2),
                        left: getSize(x + (isCenterOffsetPositive ? 5 : -5)),
                        transform: getTurn(isCenterOffsetPositive ? 5 : 3)
                    });
                    setCornerArrowInner();
                }
                else {
                    setArrowStyle({
                        top: '',
                        bottom: getSize(-arrowSize),
                        left: isCenter ? getSize(x) : getSize(x + (isCenterOffsetPositive ? 1 : -1)),
                        transform: getTurn(0)
                    });
                    setNonCornerArrowInner();
                }
            }
        }
        function setArrowEnd() {
            if (y != undefined) {
                if (isCornerVerticalPlacement) {
                    // End corners
                    setArrowStyle({
                        top: getSize(y + (isCenterOffsetPositive ? 2 : -2)),
                        right: '',
                        left: getSize(-arrowSize - 1),
                        transform: getTurn(isCenterOffsetPositive ? 7 : 5)
                    });
                    setCornerArrowInner();
                }
                else {
                    // End
                    setArrowStyle({
                        top: isCenter ? getSize(y) : getSize(y + (isCenterOffsetPositive ? -2 : +2)),
                        right: '',
                        left: getSize(-arrowSize * 1.5),
                        transform: getTurn(2)
                    });
                    setNonCornerArrowInner();
                }
            }
        }
        function setArrowBottom() {
            if (x != undefined) {
                if (isCornerHorizontalPlacement) {
                    // Bottom corners
                    setArrowStyle({
                        top: getSize(-arrowSize + 3),
                        bottom: '',
                        left: getSize(x + (isCenterOffsetPositive ? 4 : -4)),
                        transform: getTurn(isCenterOffsetPositive ? 2 : 6)
                    });
                    setArrowInnerStyle({
                        top: getSize(-arrowInnerSize),
                        left: getSize(-arrowInnerSize + (isCenterOffsetPositive ? 1 : -1))
                    });
                }
                else {
                    setArrowStyle({
                        top: getSize(-arrowSize),
                        bottom: '',
                        left: isCenter ? getSize(x) : getSize(x + (isCenterOffsetPositive ? 1 : -1)),
                        transform: getTurn(4)
                    });
                    setNonCornerArrowInner();
                }
            }
        }
        function setArrowStart() {
            if (y != undefined) {
                if (isCornerVerticalPlacement) {
                    // Start corners
                    setArrowStyle({
                        top: getSize(y + (isCenterOffsetPositive ? 2 : -2)),
                        right: getSize(-arrowSize - 1),
                        left: '',
                        transform: getTurn(isCenterOffsetPositive ? 1 : 3)
                    });
                    setArrowInnerStyle({
                        top: getSize(-arrowInnerSize),
                        left: getSize(-arrowInnerSize + (isCenterOffsetPositive ? -2 : 2))
                    });
                }
                else {
                    // Start
                    setArrowStyle({
                        top: isCenter ? getSize(y) : getSize(y + (isCenterOffsetPositive ? -2 : +2)),
                        right: getSize(-arrowSize * 1.5),
                        left: '',
                        transform: getTurn(6)
                    });
                    setNonCornerArrowInner();
                }
            }
        }
        function setCornerArrowInner() {
            setArrowInnerStyle({
                top: getSize(-arrowInnerSize),
                left: getSize(-arrowInnerSize + (isCenterOffsetPositive ? 2 : -2))
            });
        }
        function setNonCornerArrowInner() {
            setArrowInnerStyle({
                top: getSize(-arrowInnerSize - 2),
                left: getSize(-arrowInnerSize)
            });
        }
    }
}

function isElement(value) {
    return value instanceof Element;
}
/**
 * A floating component allows the user to create a floating element that is displayed on the the "top layer" of all other elements.
 *  The Floating component is an advanced component and is used underneath Popup, Tooltip, SelectMultiple, Menu and other components.
 */
const Floating = forwardRef(({ children, onClickOutside, placement = 'bottom', anchorRef, offsetValue, class: className, tail = 'none', flipOptions = { mainAxis: true, crossAxis: false }, shiftOptions = { mainAxis: true, crossAxis: false }, sizeOptions = { isMaxHeightAdjusted: false, isMaxWidthAdjusted: false }, boundaryOptions = { padding: 0 }, onPosition }, ref) => {
    const arrowRef = useRef(null);
    const [previousAnchor, setPreviousAnchor] = useState(null);
    // we need to be sure anchorRef.current exists in first call
    // to be able to set the previousAnchor state
    useLayoutEffect(() => {
        setPreviousAnchor(anchorRef.current);
    }, []);
    // In case anchorRef.current changes and we need to update floating position
    // when it changes, we need to have copy in the state.
    // For example when anchorRef is Coords( virtual element)
    if (anchorRef.current !== previousAnchor) {
        setPreviousAnchor(anchorRef.current);
    }
    const { direction } = useUser();
    const isRtl = direction === 'rtl';
    const _onPosition = useCallback((data) => {
        renderTail(data, anchorRef, arrowRef, tail, isRtl);
        onPosition === null || onPosition === void 0 ? void 0 : onPosition(data);
    }, [placement, anchorRef, arrowRef, tail, onPosition]);
    const middleware = [
        offset(offsetValue),
        b({
            mainAxis: flipOptions.mainAxis,
            crossAxis: flipOptions.crossAxis,
            padding: boundaryOptions.padding
        }),
        D({
            mainAxis: shiftOptions.mainAxis,
            crossAxis: shiftOptions.crossAxis,
            limiter: L({
                mainAxis: shiftOptions.mainAxis,
                crossAxis: shiftOptions.crossAxis
            })
        }),
        ...(arrowRef.current
            ? [
                m({
                    element: arrowRef.current
                })
            ]
            : [])
    ];
    if (sizeOptions.isMaxHeightAdjusted || sizeOptions.isMaxWidthAdjusted) {
        middleware.push(k({
            apply({ availableWidth, availableHeight, elements }) {
                if (sizeOptions.isMaxHeightAdjusted) {
                    Object.assign(elements.floating.style, {
                        maxHeight: `${Math.min(availableHeight, sizeOptions.maxHeightCeiling || availableHeight)}px`
                    });
                }
                if (sizeOptions.isMaxWidthAdjusted) {
                    Object.assign(elements.floating.style, {
                        maxWidth: `${Math.min(availableWidth, sizeOptions.maxWidthCeiling || availableWidth)}px`,
                    });
                }
            },
            padding: boundaryOptions.padding
        }));
    }
    const { x, y, reference, floating, refs } = useFloating({
        placement: placement,
        middleware: middleware,
        whileElementsMounted: N,
        onPosition: _onPosition
    });
    useOutsideClick({ isDisabled: false, ref: refs.floating, handler: onClickOutside });
    useLayoutEffect(() => {
        if (isElement(previousAnchor)) {
            const element = previousAnchor;
            reference(element);
            return;
        }
        const coords = previousAnchor;
        const virtualEl = {
            getBoundingClientRect() {
                return {
                    width: 0,
                    height: 0,
                    x: coords.x,
                    y: coords.y,
                    top: coords.y,
                    left: coords.x,
                    right: coords.x,
                    bottom: coords.y
                };
            }
        };
        if (coords && coords.x != null) {
            reference(virtualEl);
        }
    }, [previousAnchor, reference]);
    const stableRef = useMemo(() => mergeRefs(ref, floating), [ref, floating]);
    const content = (jsxs("div", Object.assign({ class: className, ref: stableRef, style: {
            display: 'block',
            visibility: x == null && y == null ? 'hidden' : 'visible',
            position: 'absolute',
            top: y !== null && y !== void 0 ? y : '',
            left: x !== null && x !== void 0 ? x : '',
            width: 'auto',
            height: 'auto'
        } }, { children: [children, jsx(FloatingTail, { ref: arrowRef })] })));
    return content;
});

export { Floating };
/*  */
//# sourceMappingURL=UNSAFE_Floating.js.map
