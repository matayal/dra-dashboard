/* @oracle/oraclejet-preact: 14.1.0 */
import { jsx, jsxs } from 'preact/jsx-runtime';
import { useRef } from 'preact/hooks';
import { Collection } from './PRIVATE_Collection.js';
import { useViewportIntersect } from './hooks/UNSAFE_useViewportIntersect.js';

const isDataStateValid = (dataState) => {
    return dataState && dataState.data && dataState.offset >= 0 && dataState.totalSize >= 0;
};
const DEFAULT_MARGIN = 1;
const DEFAULT_FETCH_SIZE = 25;
const LOADMORE_STYLE_CLASS = 'oj-collection-loadmore';
const LOAD_MORE_SELECTOR = `.${LOADMORE_STYLE_CLASS}`;
/**
 * Component that only render items in the specified viewport.
 * @param props
 */
function LoadMoreCollection({ data, children, viewportConfig, onLoadRange, loadMoreIndicator, suggestions }) {
    const rootRef = useRef(null);
    const fetchSizeRef = useRef(-1);
    // detect if viewport has changed and it needs to re-render based on a new range
    useViewportIntersect(viewportConfig, DEFAULT_MARGIN, LOAD_MORE_SELECTOR, () => {
        if (data) {
            if (fetchSizeRef.current == null || fetchSizeRef.current <= 0) {
                fetchSizeRef.current = data.totalSize;
            }
            const fetchSize = fetchSizeRef.current && fetchSizeRef.current > 0
                ? fetchSizeRef.current
                : DEFAULT_FETCH_SIZE;
            onLoadRange({
                offset: 0,
                count: data.totalSize + fetchSize
            });
        }
    });
    // override itemRenderer to adjust the index
    const _getItemRenderer = (startIndex) => {
        // returns a new render function
        return (context) => {
            const itemContext = {
                index: startIndex + context.index,
                data: context.data
            };
            return children(itemContext);
        };
    };
    // if DataState is invalid (including not specified), just render blank
    if (!data || !isDataStateValid(data)) {
        return jsx("div", { ref: rootRef });
    }
    const dataState = data;
    const rangeData = dataState.data;
    const offset = dataState.offset;
    const endIndex = offset + rangeData.length;
    const itemCount = dataState.totalSize;
    const renderLoadMore = loadMoreIndicator && dataState.sizePrecision === 'atLeast' && endIndex <= itemCount;
    // might need to support elementType prop in the future to allow customization of what
    // type of element to render for the root
    return (jsxs("div", Object.assign({ ref: rootRef }, { children: [suggestions, jsx(Collection, Object.assign({ items: rangeData }, { children: _getItemRenderer(offset) })), renderLoadMore && jsx("div", Object.assign({ class: LOADMORE_STYLE_CLASS }, { children: loadMoreIndicator }))] })));
}

export { LoadMoreCollection as L };
/*  */
//# sourceMappingURL=LoadMoreCollection-735f7102.js.map
