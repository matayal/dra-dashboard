/* @oracle/oraclejet-preact: 14.1.0 */
import { jsx, jsxs } from 'preact/jsx-runtime';
import { Fragment, createRef } from 'preact';
import { useRef, useState, useCallback, useEffect } from 'preact/hooks';
import { Flex } from './UNSAFE_Flex.js';
import "./UNSAFE_Indexer.css";
import { mergeProps } from './utils/UNSAFE_mergeProps.js';
import { u as useSingleSelection } from './useSingleSelection-cba7bc13.js';
import { useCurrentKey } from './hooks/PRIVATE_useCurrentKey.js';
import { useCollectionFocusRing } from './hooks/PRIVATE_useCollectionFocusRing.js';
import { keyExtractor, getPrevNextKey } from './utils/PRIVATE_collectionUtils.js';
import { getClientHints } from './utils/PRIVATE_clientHints.js';
import { useId } from './hooks/UNSAFE_useId.js';
import { useTranslationBundle } from './hooks/UNSAFE_useTranslationBundle.js';
import { HiddenAccessible } from './UNSAFE_HiddenAccessible.js';
import { Collection } from './PRIVATE_Collection.js';
import { _ as __rest } from './tslib.es6-821b2d99.js';
import { classNames } from './utils/UNSAFE_classNames.js';
import { forwardRef } from 'preact/compat';
import './utils/UNSAFE_interpolations/dimensions.js';
import './utils/UNSAFE_arrayUtils.js';
import './utils/UNSAFE_size.js';
import './_curry1-ab762f3c.js';
import './utils/UNSAFE_mergeInterpolations.js';
import './_curry3-77af75f1.js';
import './_curry2-9cf34233.js';
import './_has-e54ed87c.js';
import './utils/UNSAFE_interpolations/boxalignment.js';
import './keys-6f2f2841.js';
import './utils/UNSAFE_interpolations/flexbox.js';
import './utils/UNSAFE_interpolations/flexitem.js';
import './utils/UNSAFE_keys.js';
import './UNSAFE_Environment.js';
import './UNSAFE_Layer.js';

/**
 * The others section variable that application could use
 * to compare value
 */
// const translations = useTranslationBundle<BundleType>('@oracle/oraclejet-preact');

const SECTION_OTHERS = Object.freeze({
  key: '__others__',
  label: '#'
});
const liStyles = {
  base: "z1km93",
  disabled: "nancku",
  focused: "dw49zi",
  selected: "y253y8"
};
const ITEM_STYLE_CLASS = liStyles.base;
const ITEM_SELECTOR = '.' + ITEM_STYLE_CLASS;
const dotStyles = {
  base: "_7sz2zw"
};
const SectionItem = forwardRef((props, ref) => {
  const translations = useTranslationBundle('@oracle/oraclejet-preact');
  const {
    context,
    selectedKey
  } = props;
  const isSelected = context.data.key === selectedKey;
  const commonProps = getCommonProps(props, ref);
  const itemClasses = classNames([commonProps.class, context.data.isDisabled && liStyles.disabled, isSelected && liStyles.selected]);
  const sectionLabel = context.data.label || context.data.key;
  const valueText = context.data.isDisabled ? translations.indexer_disabledLabel({
    SECTION: `${sectionLabel}`
  }) : `${sectionLabel}`;
  return jsx("li", Object.assign({}, commonProps, {
    class: itemClasses,
    "data-oj-valuetext": valueText,
    "data-oj-disabled": context.data.isDisabled
  }, {
    children: context.data.label || context.data.key
  }));
});

function getCommonProps({
  context,
  currentKey,
  valueNow,
  isFocusRingVisible
}, ref) {
  const isCurrent = context.data.key === currentKey;
  const classes = classNames([liStyles.base, isCurrent && isFocusRingVisible && liStyles.focused]);
  return Object.assign(Object.assign({}, isCurrent && {
    ref
  }), {
    key: context.data.key,
    class: classes,
    'data-oj-key': context.data.key,
    'data-oj-key-type': typeof context.data.key,
    'data-oj-valuenow': valueNow,
    isFocusRingVisible: !!isFocusRingVisible
  });
} // render the last section, that contains the last character and others character


const LastSectionItem = forwardRef((_a, ref) => {
  var {
    lastValueNow
  } = _a,
      sectionProps = __rest(_a, ["lastValueNow"]);

  const commonProps = Object.assign(Object.assign({}, sectionProps), {
    ref
  });
  return jsxs(Fragment, {
    children: [jsx(SectionItem, Object.assign({}, commonProps)), jsx(OthersItem, Object.assign({}, commonProps, {
      ref: ref,
      context: {
        index: -1,
        data: SECTION_OTHERS
      },
      valueNow: lastValueNow
    }))]
  });
});
const OthersItem = forwardRef((props, ref) => {
  const {
    context,
    selectedKey
  } = props;
  const commonProps = getCommonProps(props, ref);
  const isSelected = context.data.key === selectedKey;
  const othersClasses = classNames([commonProps.class, isSelected && liStyles.selected]);
  const othersValueText = SECTION_OTHERS.label;
  return jsx("li", Object.assign({}, commonProps, {
    class: othersClasses,
    "data-oj-valuetext": othersValueText
  }, {
    children: context.data.label
  }));
});
const SeparatorItem = forwardRef((props, ref) => {
  const translations = useTranslationBundle('@oracle/oraclejet-preact');
  const {
    context,
    sections
  } = props;
  const commonProps = getCommonProps(props, ref);
  const {
    from,
    to
  } = getSeparatorRange(props);

  if (!isInSeparatorMiddle(context.index, from, to)) {
    return null;
  }

  const fromText = sections[from].label || sections[from].key;
  const toText = sections[to].label || sections[to].key;
  const separatorClasses = classNames([dotStyles.base]);
  const separatorValueText = translations.indexer_separatorLabel({
    FROM_SECTION: `${fromText}`,
    TO_SECTION: `${toText}`
  });
  return jsx("li", Object.assign({}, commonProps, {
    "data-oj-valuetext": separatorValueText
  }, {
    children: jsx(Flex, Object.assign({
      align: "center",
      justify: "center"
    }, {
      children: jsx("div", {
        class: separatorClasses
      })
    }))
  }));
});
function hasSeparator(props) {
  const {
    from,
    to
  } = getSeparatorRange(props);
  return isInSeparatorMiddle(props.context.index, from, to);
}

function getSeparatorRange({
  context,
  sectionsPerTruncation,
  last
}) {
  const from = context.index - context.index % sectionsPerTruncation + 1;
  let to = from + sectionsPerTruncation - 2;
  to = to >= last ? last - 1 : to;
  return {
    from,
    to
  };
}

function isInSeparatorMiddle(index, from, to) {
  return index === Math.floor((from + to) / 2);
}

const styles = {
  base: "_1n71xyw"
};
const ulStyles = {
  base: "_1f2h03a"
};
const defaultSections = [{
  key: 'A'
}, {
  key: 'B'
}, {
  key: 'C'
}, {
  key: 'D'
}, {
  key: 'E'
}, {
  key: 'F'
}, {
  key: 'G'
}, {
  key: 'H'
}, {
  key: 'I'
}, {
  key: 'J'
}, {
  key: 'K'
}, {
  key: 'L'
}, {
  key: 'M'
}, {
  key: 'N'
}, {
  key: 'O'
}, {
  key: 'P'
}, {
  key: 'Q'
}, {
  key: 'R'
}, {
  key: 'S'
}, {
  key: 'T'
}, {
  key: 'U'
}, {
  key: 'V'
}, {
  key: 'W'
}, {
  key: 'X'
}, {
  key: 'Y'
}, {
  key: 'Z'
}];
/**
 * Pure Preact based component that consumes Collection component
 * and renders an indexer.
 */

function Indexer({
  sections = defaultSections,
  value,
  onCommit = () => {}
}) {
  var _a;

  const rootRef = useRef(null);
  const ulRef = useRef(null);
  const currElementRef = createRef();
  const [current, setCurrent] = useState((_a = sections[0]) === null || _a === void 0 ? void 0 : _a.key); // the number of sections in each truncation

  const [sectionsPerTruncation, setSectionsPerTruncation] = useState(-1); // the total number of rendered sections and separators

  const renderedSectionsCount = useRef(-1);
  const itemHeightRef = useRef(0); // the id for aria describedby

  const uniqueId = useId();
  const [showFocusRing, focusRingProps] = useCollectionFocusRing(elem => {
    var _a;

    return !!((_a = rootRef.current) === null || _a === void 0 ? void 0 : _a.contains(elem));
  }, ['ArrowUp', 'ArrowDown']);
  const {
    currentKeyProps
  } = useCurrentKey(element => keyExtractor(element, ITEM_SELECTOR), getPrevNextKey(rootRef.current, current, true, ITEM_SELECTOR), getPrevNextKey(rootRef.current, current, false, ITEM_SELECTOR), current, detail => setCurrent(detail.value));
  const {
    selectionProps
  } = useSingleSelection(element => handleKeyExtract(element, ulRef, current), // pass in undefined so onCommit handler will be called
  // no matter whether the Section was selected before or not
  undefined, detail => handleSelection(detail, onCommit, sections));
  /**
   * Item renderer that will return a section item or a section separator
   * based on the sectionsPerTruncation and item context index.
   * @param context item context
   */

  const itemRenderer = context => {
    const last = sections.length - 1;
    renderedSectionsCount.current += 1;
    const commonProps = {
      context,
      ref: currElementRef,
      currentKey: current,
      selectedKey: value,
      valueNow: renderedSectionsCount.current,
      isFocusRingVisible: !!showFocusRing
    }; // render the last and the others character, they are always present

    if (context.index === last) {
      return jsx(LastSectionItem, Object.assign({}, commonProps, {
        lastValueNow: renderedSectionsCount.current + 1
      }));
    } // render a section, in the non-truncation case or when it is the first in a truncation


    if (sectionsPerTruncation <= 1 || context.index % sectionsPerTruncation === 0) {
      return jsx(SectionItem, Object.assign({}, commonProps));
    } // render the separator in the middle of a truncation


    const separatorProps = Object.assign(Object.assign({}, commonProps), {
      sectionsPerTruncation,
      last,
      sections
    });

    if (hasSeparator(separatorProps)) {
      return jsx(SeparatorItem, Object.assign({}, separatorProps));
    } // remove the count for truncated sections


    renderedSectionsCount.current -= 1;
    return null;
  }; // truncate the Indexer during resize


  const handleResize = useCallback(entries => {
    var _a;

    for (const entry of entries) {
      updateSectionsPerTruncation(entry.contentRect.height, itemHeightRef.current, sections.length, (_a = sections[0]) === null || _a === void 0 ? void 0 : _a.key, sectionsPerTruncation, setSectionsPerTruncation, setCurrent);
    }
  }, [sections, sectionsPerTruncation]);
  useEffect(() => {
    var _a, _b, _c, _d;

    if (ulRef.current) {
      // Get aria values from IndexerItem to update aria values on Indexer ul element
      ulRef.current.setAttribute('aria-valuemax', renderedSectionsCount.current + 1 + '');
      ulRef.current.setAttribute('aria-valuetext', ((_b = (_a = currElementRef.current) === null || _a === void 0 ? void 0 : _a.dataset) === null || _b === void 0 ? void 0 : _b['ojValuetext']) || '');
      ulRef.current.setAttribute('aria-valuenow', ((_d = (_c = currElementRef.current) === null || _c === void 0 ? void 0 : _c.dataset) === null || _d === void 0 ? void 0 : _d['ojValuenow']) || '');
    }

    renderedSectionsCount.current = -1;
  });
  /**
   * Set up the initial values for sectionsPerTruncation and event listeners
   */

  useEffect(() => {
    var _a, _b;

    const root = rootRef.current;

    if (root) {
      itemHeightRef.current = ((_a = root.querySelector('li')) === null || _a === void 0 ? void 0 : _a.offsetHeight) || 0;
      updateSectionsPerTruncation(root.offsetHeight, itemHeightRef.current, sections.length, (_b = sections[0]) === null || _b === void 0 ? void 0 : _b.key, sectionsPerTruncation, setSectionsPerTruncation, setCurrent);
    }
  }, [sections, sectionsPerTruncation]);
  /**
   * Set up resize observer and refresh the resize observer when
   * sectionsPerTruncation is changed, otherwise it will only have the
   * old copy of sectionsPerTruncation.
   */

  useEffect(() => {
    const root = rootRef.current;

    if (root) {
      const resizeObserver = new ResizeObserver(entries => {
        handleResize(entries);
      });
      resizeObserver.observe(root);
      return () => {
        resizeObserver.unobserve(root);
      };
    }

    return undefined;
  }, [sectionsPerTruncation, handleResize]);
  const translations = useTranslationBundle('@oracle/oraclejet-preact');
  return jsxs("div", Object.assign({
    ref: rootRef,
    class: styles.base
  }, {
    children: [jsx(Flex, Object.assign({
      align: "center",
      width: "6x",
      height: "100%"
    }, {
      children: jsx("ul", Object.assign({}, mergeProps(currentKeyProps, focusRingProps, selectionProps), {
        ref: ulRef,
        tabIndex: 0,
        "aria-label": "Indexer",
        "aria-orientation": "vertical",
        "aria-valuemin": "0",
        "aria-describedby": uniqueId,
        role: "slider",
        class: ulStyles.base
      }, {
        children: jsx(Collection, Object.assign({
          items: sections
        }, {
          children: itemRenderer
        }))
      }))
    })), jsx(HiddenAccessible, {
      children: jsx("span", Object.assign({
        id: uniqueId
      }, {
        children: getIndexerDescription(translations)
      }))
    })]
  }));
} // A function to extract key for selection

const handleKeyExtract = (element, rootRef, current) => {
  if (element === rootRef.current) {
    return current === undefined ? null : current;
  }

  return keyExtractor(element, ITEM_SELECTOR);
};

const handleSelection = (detail, onCommit, sections) => {
  if (detail.value === SECTION_OTHERS.key) {
    onCommit({
      value: SECTION_OTHERS.key
    });
  } else {
    const selectedSection = sections.find(section => section.key === detail.value);
    onCommit({
      value: selectedSection.key
    });
  }
};
/**
 * A function that calculates the section count, based on
 * the container height and the number of sections
 * @param height height of Indexer container
 */


const updateSectionsPerTruncation = (height, itemHeight, sectionsLength, firstSectionKey, sectionsPerTruncation, setSectionsPerTruncation, setCurrent) => {
  if (height === 0 || itemHeight === 0) {
    return;
  }

  const maxSections = height / itemHeight;
  const last = sectionsLength - 1; // when the container size is too small to hold two sections

  if (maxSections < 2) {
    if (sectionsPerTruncation !== last) {
      setSectionsPerTruncation(last);
      setCurrent(firstSectionKey);
    } // no truncation
    // compare with < 0.01 for the deviation from calculation, when sectionsLength and maxSections
    // are about the same, maxNum === sectionsLength doesn't work

  } else if (maxSections > sectionsLength || sectionsLength - maxSections < 0.01) {
    if (sectionsPerTruncation > 1) {
      setSectionsPerTruncation(1);
      setCurrent(firstSectionKey);
    } // need truncation

  } else {
    const tempSectionCount = findSectionCount(maxSections, last);

    if (tempSectionCount !== sectionsPerTruncation && tempSectionCount < sectionsLength) {
      setSectionsPerTruncation(tempSectionCount);
      setCurrent(firstSectionKey);
    }
  }
};
/**
 * A helper function to find the best section count
 * in a truncation
 *
 * @param maxSections maximum number of sections allowed in a truncation
 * @param last the index of last section
 */


const findSectionCount = (maxSections, last) => {
  // need truncation
  maxSections -= 2; // minus the last character and the others character

  maxSections /= 2; // each truncation has a section and a separator

  const newSectionCount = Math.round(last / maxSections) + 1;
  const truncationLeftover = last % newSectionCount;
  const truncationCount = Math.floor(last / newSectionCount) + (truncationLeftover > 1 ? 1 : 0); // When the sectionCount becomes greater, it will result in
  // same truncations but with different sections appearing.
  // The following is to find the best sectionCount in this case
  // and prevent unnecessary truncations.

  let tempLeftover = last - (truncationCount - 1) * newSectionCount;
  let tempSectionCount = newSectionCount;

  while (tempSectionCount > tempLeftover) {
    tempSectionCount -= 1;
    tempLeftover = last - (truncationCount - 1) * tempSectionCount;
  }

  if (tempSectionCount != newSectionCount) {
    tempSectionCount += 1;
  }

  return tempSectionCount;
};
/**
 * Helper function to find the aria description for Indexer,
 * based on whether current device is a mobile device
 */


function getIndexerDescription(translations) {
  const deviceType = getClientHints().deviceType;

  if (deviceType === 'phone' || deviceType === 'tablet') {
    return translations.indexer_touchInstructionText();
  } else {
    return translations.indexer_keyboardInstructionText();
  }
}

/**
 * @license
 * Copyright (c) %FIRST_YEAR% %CURRENT_YEAR%, Oracle and/or its affiliates.
 * The Universal Permissive License (UPL), Version 1.0
 * as shown at https://oss.oracle.com/licenses/upl/
 * @ignore
 */

export { Indexer, SECTION_OTHERS };
/*  */
//# sourceMappingURL=UNSAFE_Indexer.js.map
