/* @oracle/oraclejet-preact: 14.1.0 */
import { _ as __rest } from './tslib.es6-821b2d99.js';
import { jsx, jsxs } from 'preact/jsx-runtime';
import { useFormContext } from './hooks/UNSAFE_useFormContext.js';
import { useTabbableMode } from './hooks/UNSAFE_useTabbableMode.js';
import "./UNSAFE_TextField.css";
import { classNames } from './utils/UNSAFE_classNames.js';
import { textInterpolations } from './utils/UNSAFE_interpolations/text.js';
import { mergeInterpolations } from './utils/UNSAFE_mergeInterpolations.js';
import { useFormFieldContext } from './hooks/UNSAFE_useFormFieldContext.js';
import { useTranslationBundle } from './hooks/UNSAFE_useTranslationBundle.js';
import { LabelValueLayout } from './UNSAFE_LabelValueLayout.js';
import { Fragment } from 'preact';
import { Flex } from './UNSAFE_Flex.js';
import { useTextFieldInputHandlers } from './hooks/UNSAFE_useTextFieldInputHandlers.js';
import { useDebounce } from './hooks/UNSAFE_useDebounce.js';
import { LiveRegion } from './UNSAFE_LiveRegion.js';
import 'preact/hooks';
import './keys-6f2f2841.js';
import './_curry1-ab762f3c.js';
import './_has-e54ed87c.js';
import './_curry3-77af75f1.js';
import './_curry2-9cf34233.js';
import './UNSAFE_Environment.js';
import './UNSAFE_Layer.js';
import 'preact/compat';
import './utils/UNSAFE_size.js';
import './utils/UNSAFE_interpolations/dimensions.js';
import './utils/UNSAFE_arrayUtils.js';
import './utils/UNSAFE_interpolations/boxalignment.js';
import './utils/UNSAFE_interpolations/flexbox.js';
import './utils/UNSAFE_interpolations/flexitem.js';
import './utils/PRIVATE_clientHints.js';

const rootStyles$1 = {
  base: "_1s3skvi",
  labelInside: "d1iwqt"
};
const getFormControlClasses = hasInsideLabel => {
  return classNames([rootStyles$1.base, hasInsideLabel && rootStyles$1.labelInside]);
};
const getLoadingAriaLabel = () => {
  const translations = useTranslationBundle('@oracle/oraclejet-preact');
  return translations.formControl_loading();
};

// and the textarea, so the the textarea's focus outline doesn't get truncated.
// The 0.25rem is an aesthetically pleasing amount of margin to make the readonly
// focus ring visible.

const borderToTextAreaContentMargin = '0.25rem';
const readOnlyTextFieldStyles = {
  base: "vblukg",
  textareaBase: "fdlpr5",
  inEnabledFormBase: "_15ub5u3",
  textareaInEnabledFormBase: "ih0sj9",
  inEnabledFormLabelInside: "_1hta94e",
  textareaInEnabledFormLabelInside: "_20ve4c",
  inEnabledFormNoLabelInside: "_1wo2vfg",
  // don't apply this for textarea
  inEnabledFormNoStartContent: "_10ocs2m"
};
function ReadonlyTextFieldInput(_a) {
  var {
    ariaDescribedBy,
    ariaLabel,
    ariaLabelledBy,
    autoFocus,
    as = 'div',
    elementRef,
    hasInsideLabel = false,
    inlineUserAssistance,
    innerReadonlyField,
    rows,
    type,
    value = '',
    variant
  } = _a,
      props = __rest(_a, ["ariaDescribedBy", "ariaLabel", "ariaLabelledBy", "autoFocus", "as", "elementRef", "hasInsideLabel", "inlineUserAssistance", "innerReadonlyField", "rows", "type", "value", "variant"]);

  const {
    isFormLayout,
    isReadonly: isReadonlyForm
  } = useFormContext();
  const {
    isLoading
  } = useFormFieldContext();
  const ariaLabelForReadonly = isLoading ? getLoadingAriaLabel() : ariaLabel; // get classes for text align

  const interpolations = [...Object.values(textInterpolations)];
  const styleInterpolations = mergeInterpolations(interpolations);
  const {
    class: styleInterpolationClasses
  } = styleInterpolations(props);
  const readonlyDivClasses = classNames([as !== 'textarea' && 'oj-c-hide-scrollbar', readOnlyTextFieldStyles.base, as === 'textarea' && readOnlyTextFieldStyles.textareaBase, isFormLayout && !isReadonlyForm && readOnlyTextFieldStyles.inEnabledFormBase, variant === 'textarea' && isFormLayout && !isReadonlyForm && readOnlyTextFieldStyles.textareaInEnabledFormBase, isFormLayout && !isReadonlyForm && (hasInsideLabel ? readOnlyTextFieldStyles.inEnabledFormLabelInside : readOnlyTextFieldStyles.inEnabledFormNoLabelInside), variant === 'textarea' && isFormLayout && !isReadonlyForm && hasInsideLabel && readOnlyTextFieldStyles.textareaInEnabledFormLabelInside, variant !== 'textarea' && // not for textarea
  isFormLayout && !isReadonlyForm && readOnlyTextFieldStyles.inEnabledFormNoStartContent, styleInterpolationClasses]); // JET-52914 - Implement Tabbable mode API contract in InputText
  // spread tabbableModeProps on component

  const {
    isTabbable,
    tabbableModeProps
  } = useTabbableMode();

  if (as === 'input') {
    return jsx("input", Object.assign({
      "aria-describedby": ariaDescribedBy,
      "aria-label": ariaLabelForReadonly,
      "aria-labelledby": ariaLabelledBy,
      autofocus: autoFocus,
      class: readonlyDivClasses,
      readonly: true,
      // @ts-ignore
      ref: elementRef,
      type: type,
      value: value
    }, !isTabbable && tabbableModeProps));
  }

  if (as === 'textarea') {
    return jsx("textarea", Object.assign({
      "aria-describedby": ariaDescribedBy,
      "aria-label": ariaLabelForReadonly,
      "aria-labelledby": ariaLabelledBy,
      autofocus: autoFocus,
      class: readonlyDivClasses,
      readonly: true,
      // @ts-ignore
      ref: elementRef,
      rows: rows
    }, !isTabbable && tabbableModeProps, {
      children: value
    }));
  }

  return jsx("div", Object.assign({
    "aria-describedby": ariaDescribedBy,
    "aria-label": ariaLabelForReadonly,
    "aria-labelledby": ariaLabelledBy,
    "aria-readonly": true,
    autofocus: autoFocus,
    class: readonlyDivClasses,
    // @ts-ignore
    ref: elementRef,
    role: "textbox"
  }, tabbableModeProps, {
    children: value
  }));
}

const textFieldStyles = {
  base: "_3navvy",
  embedded: "_1u199qo",
  nonReadonly: "gol8rq"
};
const readonlyStyles = {
  base: "_1kz2e2a",
  insideEnabledForm: "_1i0hm4r",
  textarea: "_1e7m3af",
  insideEnabledFormLabelInside: "_60ovt4",
  notInsideEnabledForm: "_13qk218",
  textareaNotInsideEnabledForm: "_1auvrj3"
}; //Consolidating all loading styles on form elements here

const loadingStyles = "xy1wrz";
const getTextFieldClasses = (readonly, variant) => {
  return classNames([textFieldStyles.base, variant === 'embedded' && textFieldStyles.embedded, !readonly && textFieldStyles.nonReadonly]);
};
const getReadonlyClasses = (isInsideNonReadonlyForm, hasInsideLabel, variant) => {
  const classes = classNames([readonlyStyles.base, variant === 'textarea' && readonlyStyles.textarea, isInsideNonReadonlyForm ? readonlyStyles.insideEnabledForm : readonlyStyles.notInsideEnabledForm, variant === 'textarea' && !isInsideNonReadonlyForm && readonlyStyles.textareaNotInsideEnabledForm, isInsideNonReadonlyForm && hasInsideLabel && readonlyStyles.insideEnabledFormLabelInside]);
  return classes;
};
const getInputId = id => {
  return (id !== null && id !== void 0 ? id : '') + '|input';
};
const isInputPlaceholderShown = (hasInsideLabel, hasValue, isFocused) => {
  return !(hasInsideLabel && !hasValue && !isFocused);
};

const StartTopLabelReadonlyTextField = (_a) => {
    var { outerClassNames, innerClassNames, label, labelEdge, labelStartWidth, inlineUserAssistance, children } = _a, props = __rest(_a, ["outerClassNames", "innerClassNames", "label", "labelEdge", "labelStartWidth", "inlineUserAssistance", "children"]);
    return (jsxs("div", Object.assign({}, props, { class: outerClassNames }, { children: [jsx(LabelValueLayout, Object.assign({ label: label, labelEdge: labelEdge, labelStartWidth: labelStartWidth }, { children: jsx("div", Object.assign({ class: innerClassNames }, { children: children })) })), inlineUserAssistance] })));
};
const InsideLabelReadonlyTextField = (_a) => {
    var { outerClassNames, innerClassNames, inlineUserAssistance, children } = _a, props = __rest(_a, ["outerClassNames", "innerClassNames", "inlineUserAssistance", "children"]);
    return (jsxs("div", Object.assign({}, props, { class: outerClassNames }, { children: [jsx("div", Object.assign({ class: innerClassNames }, { children: children })), inlineUserAssistance] })));
};
const ReadonlyTextField = (_a) => {
    var { label, labelEdge, children, variant } = _a, props = __rest(_a, ["label", "labelEdge", "children", "variant"]);
    const { isFormLayout, isReadonly: isReadonlyForm } = useFormContext();
    const { isLoading } = useFormFieldContext();
    const hasInsideLabel = label !== undefined && labelEdge === 'inside';
    // TODO: We need to re-evaluate how we use CSS multi-classing to our VDOM components
    const formControlClassNames = getFormControlClasses(hasInsideLabel);
    const textFieldClassNames = getTextFieldClasses(true);
    const readonlyClassNames = getReadonlyClasses(isFormLayout && !isReadonlyForm, hasInsideLabel, variant);
    const outerClassNames = classNames([formControlClassNames, textFieldClassNames]);
    const innerClassNames = classNames([readonlyClassNames, isLoading && loadingStyles]);
    if (label !== undefined && (labelEdge === 'start' || labelEdge === 'top')) {
        return (jsx(StartTopLabelReadonlyTextField, Object.assign({ outerClassNames: outerClassNames, innerClassNames: innerClassNames, label: label, labelEdge: labelEdge }, props, { children: children })));
    }
    return (jsxs(InsideLabelReadonlyTextField, Object.assign({ outerClassNames: outerClassNames, innerClassNames: innerClassNames }, props, { children: [label, children] })));
};

const ojButtonHeight = '2.75rem'; // TODO: replace this with var(--oj-button-sm-height) once it is available

const ojButtonSmHeight = '2.25rem'; // TODO: replace this with var(--oj-button-icon-size) once it is available

const ojButtonIconSize = 'var(--oj-c-PRIVATE-DO-NOT-USE-core-icon-size-lg)'; // TODO: replace this with var(--oj-button-sm-icon-size) once it is available

const ojButtonSmIconSize = '1.25rem';
const textFieldContainerStyles = {
  base: "_3fpx1v",
  defaultStyles: "_1vwpcak",
  embeddedStyles: "_1g7v3at",
  showBorder: "_1x5ro8z",
  textarea: "e8zd1",
  labelInside: "_1gbcwl7",
  focused: "_1xjj5q0",
  resize: {
    both: "zckr9h",
    horizontal: "j83rmv",
    vertical: "eek3i1"
  },
  disabled: "_1rthkn7",
  error: "_1kguvw0",
  warning: "_188dnv2"
};
const textFieldStartContentStyles = {
  base: "_1atjsf4",
  labelInside: "tlwmy2",
  disabled: "_1q8iyi0"
};
const textFieldMiddleStyles = {
  base: "_1hu6m6d",
  textarea: "_1l06ws5"
};
const textFieldEndContentStyles = {
  base: "_1pwzbuu",
  labelInside: "_5mbiug"
}; // Renders the oj-text-field-container dom which includes the
// start, middle (where the inside label and inputElem goes),
// and end pieces of the form component.
// This does not include user assistance because that is rendered outside the
// oj-text-field-container; that is rendered in the TextField component.

const TextFieldContent = ({
  contentVariant = 'input',
  insideLabel,
  mainContent,
  startContent,
  statusVariant = 'none',
  styleVariant = 'default',
  endContent,
  resize,
  rootRef
}) => {
  const {
    isDisabled,
    isFocused,
    isLoading
  } = useFormFieldContext();
  const rootStyles = classNames([textFieldContainerStyles.base, styleVariant === 'embedded' ? classNames([textFieldContainerStyles.embeddedStyles, statusVariant !== 'none' && textFieldContainerStyles.showBorder]) : classNames([textFieldContainerStyles.defaultStyles, textFieldContainerStyles.showBorder, insideLabel !== undefined && textFieldContainerStyles.labelInside, isFocused && textFieldContainerStyles.focused, contentVariant === 'textarea' && textFieldContainerStyles.textarea]), resize && textFieldContainerStyles.resize[resize], isDisabled ? textFieldContainerStyles.disabled : classNames([statusVariant === 'error' && textFieldContainerStyles.error, statusVariant === 'warning' && textFieldContainerStyles.warning, // TODO: don't use class names: https://jira.oraclecorp.com/jira/browse/JET-50572
  statusVariant !== 'none' && `oj-c-text-field-${statusVariant}`]), isLoading && loadingStyles]);
  const startContentStyles = classNames([textFieldStartContentStyles.base, insideLabel != undefined && textFieldStartContentStyles.labelInside, isDisabled && textFieldStartContentStyles.disabled]);
  const middleStyles = classNames([textFieldMiddleStyles.base, contentVariant === 'textarea' && textFieldMiddleStyles.textarea // getMiddleContentVariantStyles(variant)
  ]);
  const endContentStyles = classNames([textFieldEndContentStyles.base, insideLabel != undefined && textFieldEndContentStyles.labelInside]);
  return jsxs("div", Object.assign({
    role: "presentation",
    class: rootStyles,
    ref: rootRef
  }, {
    children: [startContent && jsx("span", Object.assign({
      class: startContentStyles
    }, {
      children: jsx(Flex, Object.assign({
        justify: "center",
        align: "center",
        hasZeroMargins: true
      }, {
        children: startContent
      }))
    })), jsxs("div", Object.assign({
      class: middleStyles
    }, {
      children: [insideLabel, mainContent]
    })), endContent && jsx("span", Object.assign({
      class: endContentStyles
    }, {
      children: jsx(Flex, Object.assign({
        justify: "center",
        align: "center",
        hasZeroMargins: true
      }, {
        children: endContent
      }))
    }))]
  }));
};

const StyledTextField = (_a) => {
    var { hasInsideLabel = false, variant = 'default' } = _a, props = __rest(_a, ["hasInsideLabel", "variant"]);
    const { isReadonly } = useFormFieldContext();
    // TODO: We need to re-evaluate how we use CSS multi-classing to our VDOM components
    const formControlClassNames = getFormControlClasses(hasInsideLabel);
    const textFieldClassNames = getTextFieldClasses(isReadonly, variant);
    const cssClassNames = classNames([formControlClassNames, textFieldClassNames]);
    return jsx("div", Object.assign({}, props, { class: cssClassNames }));
};

// TODO: Do we need named props for start/endContent, or could they just be children that get
// wrapped in a flex layout?  (from review on 3/8/22)
// TODO: Instead of passing the inputElem, label, and userAssistance as named props here, should we
// have a separate layout component that lays them out, which could just be passed as a child
// to the TextField?  (from review on 3/8/22)
const TextField = ({ contentVariant, id, endContent, mainContent, startContent, inlineUserAssistance, label, labelEdge, labelStartWidth, mainFieldRef, resize, statusVariant, styleVariant, onFocus, onBlur, onKeyDown, onMouseDown, onMouseEnter, onMouseLeave }) => {
    // TODO: What are the implications for interoperability between new preact-based form components
    // and the existing JET oj-form-layout?  The preact form components create their own start/top
    // labels, while oj-form-layout expects to create those itself and wire them to the existing form
    // components through attributes like labelled-by.  (from review on 3/8/22)
    // TODO: How should a parent form component render component-specific content within TextField,
    // for example an aria live region?  Instead of a children prop on TextField, could the parent
    // component pass comp-specific content through other props, like inputElem?   The parent could
    // have its own component that composes inputElem with additional DOM.  (from review on 3/8/22)
    const styledTextFieldChildren = label !== undefined && (labelEdge === 'start' || labelEdge === 'top') ? (jsx(LabelValueLayout, Object.assign({ label: label, labelEdge: labelEdge, labelStartWidth: labelStartWidth }, { children: jsxs(Fragment, { children: [jsx(TextFieldContent, { contentVariant: contentVariant, endContent: endContent, mainContent: mainContent, resize: resize, rootRef: mainFieldRef, startContent: startContent, statusVariant: statusVariant, styleVariant: styleVariant }), inlineUserAssistance] }) }))) : (jsxs(Fragment, { children: [jsx(TextFieldContent, { contentVariant: contentVariant, endContent: endContent, insideLabel: label, mainContent: mainContent, resize: resize, rootRef: mainFieldRef, startContent: startContent, statusVariant: statusVariant, styleVariant: styleVariant }), inlineUserAssistance] }));
    return (jsx(StyledTextField, Object.assign({ id: id, hasInsideLabel: label !== undefined && labelEdge === 'inside', onfocusin: onFocus, onfocusout: onBlur, onKeyDown: onKeyDown, onMouseDown: onMouseDown, onMouseEnter: onMouseEnter, onMouseLeave: onMouseLeave, variant: styleVariant }, { children: styledTextFieldChildren })));
};

const rootStyles = {
  base: "r31ub9",
  // removes margin that Safari adds to the input element
  input: "_1xcja60",
  textarea: "_18nhsex",
  password: "_7ug75m",
  labelDefaultPadding: "_1j3ipzy",
  labelInsideBase: "_8uf9oc",
  textareaLabelInsideBase: "kvvgcx",
  labelInsideNoValueAndHasFocus: "pzinoo",
  hasStartContent: "urhp59",
  hasEndContent: "_1d42cg5",
  defaultColor: "_821xj3",
  disabledColor: "_1a5o460",
  // The 0.25em is the space between the prefix and the input. This is equivalent to ' '.
  hasPrefix: "_4fcmfv",
  hasSuffix: "fpdz8q",
  default: "gius89",
  defaultPaddingStart: "_13165zu",
  defaultPaddingEnd: "oe9gzv",
  embedded: "xp01v6"
};
const interpolations = [...Object.values(textInterpolations)];
const styleInterpolations = mergeInterpolations(interpolations);
const TextFieldInput = _a => {
  var {
    as = 'input',
    ariaAutoComplete,
    ariaControls,
    ariaDescribedBy,
    ariaExpanded,
    ariaInvalid,
    ariaLabel,
    ariaLabelledBy,
    ariaValueMax,
    ariaValueMin,
    ariaValueNow,
    ariaValueText,
    autoComplete,
    autoFocus,
    currentCommitValue,
    hasEndContent = false,
    hasInsideLabel = false,
    hasPrefix = false,
    hasStartContent = false,
    hasSuffix = false,
    id,
    inputRef,
    placeholder,
    isRequired,
    role,
    rows,
    spellcheck,
    type,
    value = '',
    variant = 'default',
    onInput,
    onCommit,
    onKeyDown,
    onKeyUp
  } = _a,
      props = __rest(_a, ["as", "ariaAutoComplete", "ariaControls", "ariaDescribedBy", "ariaExpanded", "ariaInvalid", "ariaLabel", "ariaLabelledBy", "ariaValueMax", "ariaValueMin", "ariaValueNow", "ariaValueText", "autoComplete", "autoFocus", "currentCommitValue", "hasEndContent", "hasInsideLabel", "hasPrefix", "hasStartContent", "hasSuffix", "id", "inputRef", "placeholder", "isRequired", "role", "rows", "spellcheck", "type", "value", "variant", "onInput", "onCommit", "onKeyDown", "onKeyUp"]);

  const hasValue = value !== '';
  const {
    isDisabled,
    isFocused,
    isLoading,
    isReadonly
  } = useFormFieldContext();
  const myPlaceholder = isInputPlaceholderShown(hasInsideLabel, hasValue, isFocused) ? placeholder : undefined;
  const {
    class: styleInterpolationClasses
  } = styleInterpolations(props);
  const renderPrefix = !isDisabled && hasPrefix;
  const renderSuffix = !isDisabled && hasSuffix;
  const inputClasses = classNames(['oj-c-text-field-input', rootStyles.base, variant === 'default' ? classNames([rootStyles.default, as === 'textarea' && rootStyles.textarea, as === 'input' && rootStyles.input, type === 'password' && rootStyles.password, !hasStartContent && !renderPrefix && rootStyles.defaultPaddingStart, !hasEndContent && !renderSuffix && rootStyles.defaultPaddingEnd]) : rootStyles.embedded, hasInsideLabel && classNames([rootStyles.labelInsideBase, as === 'textarea' && rootStyles.textareaLabelInsideBase, !hasValue && isFocused && rootStyles.labelInsideNoValueAndHasFocus]), !hasInsideLabel && as !== 'textarea' && rootStyles.labelDefaultPadding, // We want the input to have padding on itself. This gives the user more space to click on to set focus to the input.
  // The padding between the input and the icon is different than the padding between the input and prefix/suffix (since they are both text)
  // startcontentpadding+input+endcontentpadding
  hasStartContent && !hasPrefix && rootStyles.hasStartContent, hasEndContent && !hasSuffix && rootStyles.hasEndContent, isDisabled ? rootStyles.disabledColor : rootStyles.defaultColor, // prefix+prefixpadding+input+suffixpadding+suffix
  // if there is also a startcontent or end content,
  // the prefix/suffix will have that padding on it (see PrefixSuffix)
  renderPrefix && rootStyles.hasPrefix, renderSuffix && rootStyles.hasSuffix, styleInterpolationClasses]);
  const Comp = as || 'input';
  const handlers = useTextFieldInputHandlers({
    currentCommitValue,
    value,
    onInput,
    onCommit,
    onKeyDown
  }); // the implicit default for tabindex on an input is 0, so do not explicitly set it.
  // JET-52914 - Implement Tabbable mode API contract in InputText
  // if not tabbable, spread tabbableModeProps on component

  const {
    isTabbable,
    tabbableModeProps
  } = useTabbableMode(); // TODO: for autoComplete='off', need to configure attrs appropriately to make sure it
  // works across browsers and versions  (from review on 3/11/22)

  return jsx(Comp, Object.assign({
    "aria-autocomplete": ariaAutoComplete,
    "aria-controls": ariaControls,
    "aria-describedby": ariaDescribedBy,
    "aria-expanded": ariaExpanded,
    "aria-invalid": ariaInvalid,
    "aria-label": isLoading ? getLoadingAriaLabel() : ariaLabel ? ariaLabel : undefined,
    "aria-labelledby": ariaLabelledBy,
    "aria-required": isRequired ? true : undefined,
    "aria-valuemax": ariaValueMax,
    "aria-valuemin": ariaValueMin,
    "aria-valuenow": ariaValueNow,
    "aria-valuetext": ariaValueText,
    autocomplete: autoComplete,
    autofocus: autoFocus,
    class: inputClasses,
    disabled: isDisabled,
    id: id,
    onKeyUp: onKeyUp,
    placeholder: myPlaceholder,
    readonly: isReadonly,
    // @ts-ignore
    ref: inputRef,
    role: role,
    rows: rows,
    spellcheck: spellcheck,
    type: type,
    value: value
  }, handlers, !isTabbable && tabbableModeProps));
};

const MAX_LENGTH_UPDATE_DELAY = 500;
function MaxLengthLiveRegion({ isMaxLengthExceeded, maxLength, valueLength = 0 }) {
    // Comment copied from InputBase.js in Big JET:
    // Only update the aria-live div when the user has paused for more than
    // 500 milliseconds. That way, we avoid queued up aria-live messages which
    // would be annoying and not helpful. The 500ms was agreed upon in the
    // accessibility review meeting.
    const debouncedRemainingChars = useDebounce(maxLength - valueLength, MAX_LENGTH_UPDATE_DELAY);
    const translations = useTranslationBundle('@oracle/oraclejet-preact');
    const maxLengthExceededTranslatedString = translations.formControl_maxLengthExceeded({
        MAX_LENGTH: `${maxLength}`
    });
    const remainingCharsTranslatedString = translations.formControl_maxLengthRemaining({
        CHARACTER_COUNT: `${debouncedRemainingChars}`
    });
    return (jsxs(Fragment, { children: [jsx(LiveRegion, { children: remainingCharsTranslatedString }), isMaxLengthExceeded && (jsx(LiveRegion, Object.assign({ type: "assertive" }, { children: maxLengthExceededTranslatedString })))] }));
}

/**
 * @license
 * Copyright (c) %FIRST_YEAR% %CURRENT_YEAR%, Oracle and/or its affiliates.
 * The Universal Permissive License (UPL), Version 1.0
 * as shown at https://oss.oracle.com/licenses/upl/
 * @ignore
 */

export { MaxLengthLiveRegion, ReadonlyTextField, ReadonlyTextFieldInput, TextField, TextFieldInput, getInputId };
/*  */
//# sourceMappingURL=UNSAFE_TextField.js.map
