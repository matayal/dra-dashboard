/* @oracle/oraclejet-preact: 14.1.0 */
'use strict';

var jsxRuntime = require('preact/jsx-runtime');
var preact$1 = require('@testing-library/preact');
var chai = require('chai');
var FilePicker = require('../../FilePicker-4c1e05a5.js');
var utils_UNSAFE_matchTranslationBundle = require('../../utils/UNSAFE_matchTranslationBundle.js');
var UNSAFE_Environment = require('../../UNSAFE_Environment.js');
var preact = require('preact');
var compat = require('preact/compat');
require('../../utils/PRIVATE_clientHints.js');
var utils_PRIVATE_dvtTestUtils = require('../../utils/PRIVATE_dvtTestUtils.js');
var clientHints = require('../../clientHints-e821b5ee.js');
require('../../tslib.es6-6f60dd09.js');
require('../../utils/UNSAFE_mergeProps.js');
require('../../utils/UNSAFE_classNames.js');
require('../../classNames-55bceee6.js');
require('../../hooks/UNSAFE_useTranslationBundle.js');
require('preact/hooks');
require('../../UNSAFE_Layer.js');
require("identity-obj-proxy");
require('../../UNSAFE_Text.js');
require('../../Text-cdd6f2fd.js');
require('../../utils/UNSAFE_mergeInterpolations.js');
require('../../_curry1-f1ebd742.js');
require('../../_curry3-bc6e6a86.js');
require('../../_curry2-588f7ddc.js');
require('../../_has-2eedb7e0.js');
require('../../UNSAFE_Spacer.js');
require('../../Spacer-6f567a4e.js');
require('../../utils/UNSAFE_interpolations/dimensions.js');
require('../../utils/UNSAFE_arrayUtils.js');
require('../../utils/UNSAFE_size.js');
require('../../utils/UNSAFE_interpolations/flexitem.js');
require('../../flexitem-0c1e9a72.js');
require('../../keys-326d80d5.js');
require('../../utils/UNSAFE_stringUtils.js');
require('../../stringUtils-dad38408.js');
require('../../utils/UNSAFE_filePickerUtils.js');
require('../../hooks/UNSAFE_usePress.js');
require('../../hooks/UNSAFE_useHover.js');
require('../../hooks/UNSAFE_useToggle.js');
require('../../hooks/UNSAFE_useTabbableMode.js');

function __variableDynamicImportRuntime0__(path) {
  switch (path) {
    case '../../resources/nls/ar/bundle.ts': return Promise.resolve().then(function () { return require('../../resources/nls/ar/bundle.js'); });
    case '../../resources/nls/ar-XB/bundle.ts': return Promise.resolve().then(function () { return require('../../resources/nls/ar-XB/bundle.js'); });
    case '../../resources/nls/bg/bundle.ts': return Promise.resolve().then(function () { return require('../../resources/nls/bg/bundle.js'); });
    case '../../resources/nls/bs/bundle.ts': return Promise.resolve().then(function () { return require('../../resources/nls/bs/bundle.js'); });
    case '../../resources/nls/bs-Cyrl/bundle.ts': return Promise.resolve().then(function () { return require('../../resources/nls/bs-Cyrl/bundle.js'); });
    case '../../resources/nls/cs/bundle.ts': return Promise.resolve().then(function () { return require('../../resources/nls/cs/bundle.js'); });
    case '../../resources/nls/da/bundle.ts': return Promise.resolve().then(function () { return require('../../resources/nls/da/bundle.js'); });
    case '../../resources/nls/de/bundle.ts': return Promise.resolve().then(function () { return require('../../resources/nls/de/bundle.js'); });
    case '../../resources/nls/el/bundle.ts': return Promise.resolve().then(function () { return require('../../resources/nls/el/bundle.js'); });
    case '../../resources/nls/en/bundle.ts': return Promise.resolve().then(function () { return require('../../resources/nls/en/bundle.js'); });
    case '../../resources/nls/en-XA/bundle.ts': return Promise.resolve().then(function () { return require('../../resources/nls/en-XA/bundle.js'); });
    case '../../resources/nls/en-XC/bundle.ts': return Promise.resolve().then(function () { return require('../../resources/nls/en-XC/bundle.js'); });
    case '../../resources/nls/es/bundle.ts': return Promise.resolve().then(function () { return require('../../resources/nls/es/bundle.js'); });
    case '../../resources/nls/et/bundle.ts': return Promise.resolve().then(function () { return require('../../resources/nls/et/bundle.js'); });
    case '../../resources/nls/fi/bundle.ts': return Promise.resolve().then(function () { return require('../../resources/nls/fi/bundle.js'); });
    case '../../resources/nls/fr/bundle.ts': return Promise.resolve().then(function () { return require('../../resources/nls/fr/bundle.js'); });
    case '../../resources/nls/fr-CA/bundle.ts': return Promise.resolve().then(function () { return require('../../resources/nls/fr-CA/bundle.js'); });
    case '../../resources/nls/he/bundle.ts': return Promise.resolve().then(function () { return require('../../resources/nls/he/bundle.js'); });
    case '../../resources/nls/hr/bundle.ts': return Promise.resolve().then(function () { return require('../../resources/nls/hr/bundle.js'); });
    case '../../resources/nls/hu/bundle.ts': return Promise.resolve().then(function () { return require('../../resources/nls/hu/bundle.js'); });
    case '../../resources/nls/is/bundle.ts': return Promise.resolve().then(function () { return require('../../resources/nls/is/bundle.js'); });
    case '../../resources/nls/it/bundle.ts': return Promise.resolve().then(function () { return require('../../resources/nls/it/bundle.js'); });
    case '../../resources/nls/ja/bundle.ts': return Promise.resolve().then(function () { return require('../../resources/nls/ja/bundle.js'); });
    case '../../resources/nls/ko/bundle.ts': return Promise.resolve().then(function () { return require('../../resources/nls/ko/bundle.js'); });
    case '../../resources/nls/lt/bundle.ts': return Promise.resolve().then(function () { return require('../../resources/nls/lt/bundle.js'); });
    case '../../resources/nls/lv/bundle.ts': return Promise.resolve().then(function () { return require('../../resources/nls/lv/bundle.js'); });
    case '../../resources/nls/ms/bundle.ts': return Promise.resolve().then(function () { return require('../../resources/nls/ms/bundle.js'); });
    case '../../resources/nls/nl/bundle.ts': return Promise.resolve().then(function () { return require('../../resources/nls/nl/bundle.js'); });
    case '../../resources/nls/no/bundle.ts': return Promise.resolve().then(function () { return require('../../resources/nls/no/bundle.js'); });
    case '../../resources/nls/pl/bundle.ts': return Promise.resolve().then(function () { return require('../../resources/nls/pl/bundle.js'); });
    case '../../resources/nls/pt/bundle.ts': return Promise.resolve().then(function () { return require('../../resources/nls/pt/bundle.js'); });
    case '../../resources/nls/pt-PT/bundle.ts': return Promise.resolve().then(function () { return require('../../resources/nls/pt-PT/bundle.js'); });
    case '../../resources/nls/ro/bundle.ts': return Promise.resolve().then(function () { return require('../../resources/nls/ro/bundle.js'); });
    case '../../resources/nls/ru/bundle.ts': return Promise.resolve().then(function () { return require('../../resources/nls/ru/bundle.js'); });
    case '../../resources/nls/sk/bundle.ts': return Promise.resolve().then(function () { return require('../../resources/nls/sk/bundle.js'); });
    case '../../resources/nls/sl/bundle.ts': return Promise.resolve().then(function () { return require('../../resources/nls/sl/bundle.js'); });
    case '../../resources/nls/sr/bundle.ts': return Promise.resolve().then(function () { return require('../../resources/nls/sr/bundle.js'); });
    case '../../resources/nls/sr-Latn/bundle.ts': return Promise.resolve().then(function () { return require('../../resources/nls/sr-Latn/bundle.js'); });
    case '../../resources/nls/sv/bundle.ts': return Promise.resolve().then(function () { return require('../../resources/nls/sv/bundle.js'); });
    case '../../resources/nls/th/bundle.ts': return Promise.resolve().then(function () { return require('../../resources/nls/th/bundle.js'); });
    case '../../resources/nls/tr/bundle.ts': return Promise.resolve().then(function () { return require('../../resources/nls/tr/bundle.js'); });
    case '../../resources/nls/uk/bundle.ts': return Promise.resolve().then(function () { return require('../../resources/nls/uk/bundle.js'); });
    case '../../resources/nls/vi/bundle.ts': return Promise.resolve().then(function () { return require('../../resources/nls/vi/bundle.js'); });
    case '../../resources/nls/zh-Hans/bundle.ts': return Promise.resolve().then(function () { return require('../../resources/nls/zh-Hans/bundle.js'); });
    case '../../resources/nls/zh-Hant/bundle.ts': return Promise.resolve().then(function () { return require('../../resources/nls/zh-Hant/bundle.js'); });
    default: return new Promise(function(resolve, reject) {
      (typeof queueMicrotask === 'function' ? queueMicrotask : setTimeout)(
        reject.bind(null, new Error("Unknown variable dynamic import: " + path))
      );
    })
   }
 }
describe('Test Filepicker component', () => {
    it('render', async () => {
        const content = await setupFilePicker({ accept: ['image/*'] });
        const firstElement = content.container.firstElementChild;
        const classList = firstElement.classList;
        chai.expect(classList.length).equals(2);
    });
    it('Focus Blur', async () => {
        const content = await setupFilePicker();
        const firstElement = content.container.firstElementChild;
        firstElement.focus();
        let focusElement = document.activeElement;
        chai.expect(firstElement.contains(focusElement), 'FilePicker is in focus').equals(true);
        firstElement.blur();
        focusElement = document.activeElement;
        chai.expect(firstElement.contains(focusElement), 'FilePicker no longer in focus').not.equals(true);
    });
    //TODO: JET-53693 Focus not working in Preact Avatar
    // it('Focus Blur Trigger Content', async () => {
    //   const triggerContent = (
    //     <div id="triggerContent" tabIndex={0}>
    //       This is the child content
    //     </div>
    //   );
    //   const content = await setupFilePicker({ children: triggerContent });
    //   const firstElement = content.container?.firstElementChild as HTMLElement;
    //   firstElement.focus();
    //   let focusElement = document.activeElement;
    //   expect(focusElement?.getAttribute('id'), 'FilePicker trigger is in focus').equals('triggerContent');
    //   expect(
    //     firstElement.contains(focusElement) && firstElement !== focusElement,
    //     'FilePicker is in focus'
    //   ).equals(true);
    //   firstElement.blur();
    //   focusElement = document.activeElement;
    //   expect(firstElement.contains(focusElement), 'FilePicker no longer in focus').not.equals(true);
    // });
    it('default value for isDisabled', async () => {
        var _a;
        const content = await setupFilePicker();
        const firstElement = content.container.firstElementChild;
        const elementClasses = (_a = firstElement.classList) === null || _a === void 0 ? void 0 : _a.value;
        chai.expect(elementClasses).to.be.a('string').that.not.contains('oj-c-filepicker-disabled');
    });
    it('default value for primaryText', async () => {
        const content = await setupFilePicker();
        const primaryText = await content.findByText('Drag and Drop');
        chai.expect(primaryText).not.null;
    });
    it('default value for secondaryText', async () => {
        const content = await setupFilePicker();
        const secondaryText = await content.findByText('Select or drop files here');
        chai.expect(secondaryText).not.null;
    });
    it('default value for accessibleLabel', async () => {
        const content = await setupFilePicker();
        const firstElement = content.container.firstElementChild;
        chai.expect(firstElement.getAttribute('aria-label')).equals('Add Files. Drag and Drop. Select or drop files here');
    });
    it('HandleDragEnter', async () => {
        const filePickerRef = preact.createRef();
        await setupFilePicker({}, filePickerRef);
        const eventObj = createEvent();
        const data = filePickerRef.current;
        data.onDragEnter(eventObj.event);
        await preact$1.waitFor(() => {
            eventObj.expectEventToBeCancelled();
        });
    });
    //following test also checks for default capture option
    const invalidTestDetails = [
        {
            description: 'Invalid single handleDragOver handleDragLeave',
            dragOver: ['application/pdf'],
            dragLeave: true,
            invalidMessage: "You can't upload files of type application/pdf"
        },
        {
            description: 'Invalid single handleDragOver handleFileDrop',
            dragOver: ['application/pdf'],
            fileDrop: [['test.pdf', 'application/pdf']],
            invalidMessage: "You can't upload files of type application/pdf"
        },
        {
            description: 'Invalid single unknown mimetype handleDragOver handleFileDrop',
            dragOver: [''],
            fileDrop: [['test.pkg', '']],
            invalidMessage: "You can't upload files of type unknown",
            invalidSafariIEMessage: "You can't upload files of type .pkg"
        },
        {
            description: 'Invalid single .pem mimetype handleDragOver handleFileDrop',
            dragOver: [''],
            fileDrop: [['test.pkg', '']],
            invalidMessage: "You can't upload files of type .pkg",
            invalidSafariIEMessage: "You can't upload files of type .pkg",
            mimeType: ['.pem']
        },
        {
            description: 'Invalid single unknown no extension mimetype handleDragOver handleFileDrop',
            dragOver: [''],
            fileDrop: [['README', '']],
            invalidMessage: "You can't upload files of type unknown"
        },
        {
            description: 'Invalid multiple unknown mimetype handleDragOver handleFileDrop',
            dragOver: ['', ''],
            fileDrop: [
                ['test.pkg', ''],
                ['README', '']
            ],
            invalidMessage: "You can't upload files of type unknown",
            invalidSafariIEMessage: "You can't upload files of type: .pkg, unknown"
        },
        {
            description: 'Invalid multiple handleDragOver selectionMode single',
            dragOver: ['image/png', 'image/png'],
            invalidMessage: 'Upload one file at a time',
            single: true
        },
        {
            description: 'Invalid multiple handleDragOver handleFileDrop',
            dragOver: ['application/pdf', 'application/pdf'],
            fileDrop: [
                ['test.pdf', 'application/pdf'],
                ['test2.pdf', 'application/pdf']
            ],
            invalidMessage: "You can't upload files of type application/pdf"
        },
        {
            description: 'Invalid multiple unique types handleDragOver handleFileDrop',
            dragOver: ['application/pdf', 'video/mp4'],
            fileDrop: [
                ['test.pdf', 'application/pdf'],
                ['test.mp4', 'video/mp4']
            ],
            invalidMessage: "You can't upload files of type: application/pdf, video/mp4"
        }
    ];
    it('Invalid Scenarios', () => {
        invalidTestDetails.forEach(async (test) => {
            let invalidPromise = Promise.resolve();
            const onRejection = (event) => {
                const message = event.messages[0];
                // TODO JET-53367 for safari/edge testing for preact components
                const correctMessage = clientHints.getClientHints().browser === 'safari' && test.invalidSafariIEMessage
                    ? test.invalidSafariIEMessage
                    : test.invalidMessage;
                chai.expect(message.severity, 'Message severity is error').to.equal('error');
                chai.expect(message.summary, 'Message summary is correct').to.equal(correctMessage);
                invalidPromise = event.until;
                expectedCalls.invalidCalled = true;
            };
            const mimetypeDot = test.mimeType ? true : false;
            const expectedCalls = { invalidCalled: false };
            const filePickerRef = preact.createRef();
            const content = await setupFilePicker({
                accept: test.mimeType ? test.mimeType : ['image/*'],
                selectionMode: test.single ? 'single' : 'multiple',
                onReject: onRejection
            }, filePickerRef);
            const filePickerContent = content.container.firstElementChild;
            const eventObj = createInvalidDragOverEvent(test.dragOver, expectedCalls, filePickerContent, mimetypeDot);
            const data = filePickerRef.current;
            data.onDragOver(eventObj.event);
            await preact$1.waitFor(() => {
                eventObj.expectEventToBeCancelled();
                eventObj.expectedCalls();
            });
            if (test.fileDrop) {
                const dropEventObj = createInvalidDropEvent(test.fileDrop, expectedCalls, mimetypeDot);
                data.onDrop(dropEventObj.event);
                await invalidPromise;
                dropEventObj.expectEventToBeCancelled();
                dropEventObj.expectedCalls();
            }
            if (test.dragLeave) {
                const dragLeaveEventObj = createDragLeaveEvent(content.container, filePickerContent);
                data.onDragLeave(dragLeaveEventObj.event, mimetypeDot);
                await invalidPromise;
                dragLeaveEventObj.expectEventToBeCancelled();
                dragLeaveEventObj.expectedCalls();
            }
        });
    });
    const validTestDetails = [
        {
            description: 'Valid single handleDragOver handleFileDrop',
            dragOver: ['image/png'],
            fileDrop: [['test.png', 'image/png']]
        },
        {
            description: 'Valid .pem handleDragOver handleFileDrop',
            dragOver: [''],
            fileDrop: [['test.pem', '']],
            mimeType: ['.pem']
        },
        {
            description: 'Valid multiple handleDragOver handleFileDrop',
            dragOver: ['image/png', 'image/png'],
            fileDrop: [
                ['test.png', 'image/png'],
                ['test2.png', 'image/png']
            ]
        }
    ];
    it('Valid Scenarios', () => {
        validTestDetails.forEach(async (test) => {
            const onCommit = (event) => {
                const files = event.files;
                let file;
                for (let i = 0; i < files.length; i++) {
                    file = files[i];
                    chai.expect(file.name, 'File name is correct').to.equal(test.fileDrop[i][0]);
                    chai.expect(file.type, 'File type is correct').to.equal(test.fileDrop[i][1]);
                }
                expectedCalls.selectCalled = true;
            };
            const onReject = () => {
                chai.expect(false, 'Invalid Select Listener should not be called').to.be.true;
            };
            const filePickerRef = preact.createRef();
            const content = await setupFilePicker({
                accept: test.mimeType ? test.mimeType : ['image/*'],
                onReject: onReject,
                onCommit: onCommit
            }, filePickerRef);
            const expectedCalls = { selectCalled: false };
            const filePickerContent = content.container.firstElementChild;
            const data = filePickerRef.current;
            const eventObj = createValidDragOverEvent(test.dragOver, filePickerContent);
            data.onDragOver(eventObj.event);
            await preact$1.waitFor(() => {
                eventObj.expectEventToBeCancelled();
                eventObj.expectedCalls();
            });
            const dropEventObj = createValidDropEvent(test.fileDrop, expectedCalls);
            data.onDrop(dropEventObj.event);
            await preact$1.waitFor(() => {
                dropEventObj.expectEventToBeCancelled();
                dropEventObj.expectedCalls();
            });
        });
    });
    it('handleFileSelected (click listener)', async () => {
        let resolver;
        const expectedCalls = { select: false };
        const fileType = 'image/png';
        const fileName = 'test.png';
        const invalidPromise = new Promise((resolve) => {
            resolver = resolve;
        });
        const filePickerRef = preact.createRef();
        const commitListener = (event) => {
            const file = event.files[0];
            chai.expect(file.name, 'File name is correct').to.equal(fileName);
            chai.expect(file.type, 'File type is correct').to.equal(fileType);
            expectedCalls.select = true;
            resolver();
        };
        await setupFilePicker({ accept: ['image/*'], onCommit: commitListener }, filePickerRef);
        const data = filePickerRef.current;
        const expectedCallsFunc = createExpectedCalls(expectedCalls);
        data.onClickSelected([{ name: fileName, type: fileType }]);
        await invalidPromise;
        expectedCallsFunc();
    });
    if (clientHints.getClientHints().browser === 'edge') {
        it('handleFileSelected invalid file Edge(click listener)', async () => {
            const onRejection = (event) => {
                const message = event.detail.messages[0];
                chai.expect(message.severity, 'Message severity is error').to.equal('error');
                chai.expect(message.summary, 'Message summary is correct').to.equal("You can't upload files of type " + fileType + '.');
                expectedCalls.invalid = true;
                resolver();
            };
            const expectedCalls = { invalid: false };
            const filePickerRef = preact.createRef();
            const FilePickerContainer = await setupFilePicker({
                onReject: onRejection
            }, filePickerRef);
            preact$1.render(FilePickerContainer);
            const data = filePickerRef.current;
            const fileName = 'test.pdf';
            const fileType = 'document/pdf';
            let resolver;
            const invalidPromise = new Promise((resolve, reject) => {
                resolver = resolve;
                reject = reject;
            });
            const expectedCallsFunc = createExpectedCalls(expectedCalls);
            data.onClickSelected([{ name: fileName, type: fileType }]);
            await invalidPromise;
            expectedCallsFunc();
        });
    }
});
describe('File Picker - TabbableModeContext', () => {
    it(' RootEnvironmentProvider is not present', async () => {
        const content = await setupFilePicker();
        const firstElement = content.container.firstElementChild;
        const tabindex = firstElement === null || firstElement === void 0 ? void 0 : firstElement.getAttribute('tabindex');
        chai.expect(tabindex).to.equal('0');
    });
    it('TabbableModeContext isTabbable=true', async () => {
        const filePicker = jsxRuntime.jsx(FilePicker.FilePicker, {});
        const content = await utils_PRIVATE_dvtTestUtils["default"](filePicker, true);
        const firstElement = content.container.firstElementChild;
        const tabindex = firstElement === null || firstElement === void 0 ? void 0 : firstElement.getAttribute('tabindex');
        chai.expect(tabindex).to.equal('0');
    });
    it('TabbableModeContext isTabbable=false', async () => {
        const filePicker = jsxRuntime.jsx(FilePicker.FilePicker, {});
        const content = await utils_PRIVATE_dvtTestUtils["default"](filePicker, false);
        const firstElement = content.container.firstElementChild;
        const tabindex = firstElement === null || firstElement === void 0 ? void 0 : firstElement.getAttribute('tabindex');
        chai.expect(tabindex).to.equal('-1');
    });
    it('TabbableModeContext not provided', async () => {
        const filePicker = jsxRuntime.jsx(FilePicker.FilePicker, {});
        const content = await utils_PRIVATE_dvtTestUtils["default"](filePicker);
        const firstElement = content.container.firstElementChild;
        const tabindex = firstElement === null || firstElement === void 0 ? void 0 : firstElement.getAttribute('tabindex');
        chai.expect(tabindex).to.equal('0');
    });
});
const setupFilePicker = async (props = {}, ref) => {
    const locale = utils_UNSAFE_matchTranslationBundle.matchTranslationBundle(['en'], new Set(['en-US', 'en']));
    const { default: translations } = await __variableDynamicImportRuntime0__(`../../resources/nls/${locale}/bundle.ts`);
    const env = {
        translations: { '@oracle/oraclejet-preact': translations }
    };
    let filePicker;
    if (ref) {
        const RefWrapper = compat.forwardRef(TestFilePicker);
        filePicker = jsxRuntime.jsx(RefWrapper, Object.assign({ ref: ref }, props));
    }
    else {
        filePicker = jsxRuntime.jsx(FilePicker.FilePicker, Object.assign({}, props));
    }
    return preact$1.render(jsxRuntime.jsx(UNSAFE_Environment.RootEnvironmentProvider, Object.assign({ environment: env }, { children: filePicker })));
};
const TestFilePicker = (props, testHandlersRef) => {
    const BaseFilePicker = FilePicker.FilePicker;
    const testProps = Object.assign({ __testHandlerSymbol: testHandlersRef }, props);
    return jsxRuntime.jsx(BaseFilePicker, Object.assign({}, testProps));
};
const createEvent = () => {
    let defaultPrevented = false;
    let propagationStopped = false;
    return {
        event: {
            preventDefault: () => {
                defaultPrevented = true;
            },
            stopPropagation: () => {
                propagationStopped = true;
            }
        },
        expectEventToBeCancelled: () => {
            chai.expect(defaultPrevented, 'Default prevented').to.be.true;
            chai.expect(propagationStopped, 'Propagation stopped').to.be.true;
        }
    };
};
const createDragOverEvent = (types) => {
    const eventObj = createEvent();
    const files = [];
    for (const type of types) {
        files.push({ kind: 'file', type: type });
    }
    // TODO JET-53367 for safari/edge testing for preact components
    const isSafari = clientHints.getClientHints().browser === 'safari';
    const dataTransfer = isSafari ? null : { items: files };
    eventObj.event.dataTransfer = dataTransfer;
    return eventObj;
};
const createDropEvent = (types) => {
    const eventObj = createEvent();
    const files = [];
    let type;
    for (let i = 0; i < types.length; i++) {
        type = types[i];
        files.push({ name: type[0], type: type[1] });
    }
    eventObj.event.dataTransfer = { files: files };
    return eventObj;
};
const createValidDropEvent = (types, expectedCalls) => {
    const eventObj = createDropEvent(types);
    eventObj.expectedCalls = () => {
        chai.expect(expectedCalls.selectCalled, 'Select Listener Event fired').to.be.true;
    };
    return eventObj;
};
const createValidDragOverEvent = (types, filepicker) => {
    const eventObj = createDragOverEvent(types);
    eventObj.expectedCalls = () => {
        chai.expect(filepicker.querySelector('.oj-c-valid-drop') !== null, 'Overlay shown').to.be.true;
    };
    return eventObj;
};
const createInvalidDragOverEvent = (types, expectedCalls, filepicker, mimeTypeDot) => {
    const eventObj = createDragOverEvent(types);
    eventObj.expectedCalls = () => {
        // TODO JET-53367 for safari/edge testing for preact components
        // In IE and Safari, invalid select event isn't fired until drop
        const isSafari = clientHints.getClientHints().browser === 'safari';
        if (isSafari || mimeTypeDot) {
            chai.expect(filepicker.querySelector('.oj-c-valid-drop') !== null, 'Overlay shown').to.be.true;
            chai.expect(expectedCalls.invalidCalled, 'Invalid Listener Event not fired in IE or Safari').to.be
                .false;
        }
        else {
            chai.expect(expectedCalls.invalidCalled, 'Invalid Listener Event fired').to.be.true;
        }
    };
    return eventObj;
};
const createInvalidDropEvent = (types, expectedCalls, mimeTypeDot) => {
    const eventObj = createDropEvent(types);
    eventObj.expectedCalls = () => {
        // TODO JET-53367 for safari/edge testing for preact components
        const isSafari = clientHints.getClientHints().browser === 'safari';
        if (isSafari || mimeTypeDot) {
            chai.expect(expectedCalls.invalidCalled, 'Invalid Listener Event fired').to.be.true;
        }
    };
    return eventObj;
};
const createDragLeaveEvent = (container, filepicker) => {
    const eventObj = createEvent();
    eventObj.event.relatedTarget = container;
    // TODO JET-53367 for safari/edge testing for preact components
    const isSafari = clientHints.getClientHints().browser === 'safari';
    eventObj.expectedCalls = () => {
        // In IE and Safari, invalid select event isn't fired until drop
        if (isSafari) {
            chai.expect(filepicker.querySelector('.oj-c-invalid-drop') === null, 'Invalid State removed').to.be
                .true;
        }
        else {
            chai.expect(filepicker.querySelector('.oj-c-valid-drop') === null, 'Overlay removed').to.be.true;
        }
    };
    return eventObj;
};
const createExpectedCalls = (calls) => {
    return () => {
        for (const call of Object.keys(calls)) {
            chai.expect(calls[call], call + ' Listener Event fired').to.be.true;
        }
    };
};
/*  */
//# sourceMappingURL=FilePicker.spec.js.map
