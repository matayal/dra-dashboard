/* @oracle/oraclejet-preact: 14.1.0 */
'use strict';

var jsxRuntime = require('preact/jsx-runtime');
var preact = require('preact');
var hooks = require('preact/hooks');
var PRIVATE_TransitionGroup = require('./PRIVATE_TransitionGroup.js');
var tslib_es6 = require('./tslib.es6-6f60dd09.js');
require('./hooks/UNSAFE_useAnimation.js');
var hooks_UNSAFE_useMessagesContext = require('./hooks/UNSAFE_useMessagesContext.js');
var useAnimation = require('./useAnimation-576ef8bc.js');

const DEFAULT_ANIMATION_STATES = {};
/**
 * A intermediary component that handles animation for the messages component.
 *
 * The expected flow is as follows:
 * 1. message removed from the data
 * 2. onExiting called and a callback is passed which needs to be called to complete the transition
 * 3. state set to "exiting" in this component
 * 4. triggers useAnimation to perform the exit animation
 * 5. onAnimationEnd is called after the animation, which invokes the callback provided earlier
 * 6. onExited is called (done when the callback mentioned above is called)
 * 7. message is removed from the UI
 *
 * @param param0 Props of the message component
 */
function MessageTransition(_a) {
    var { animationStates = DEFAULT_ANIMATION_STATES, initialAnimationStyles, onEntering, onExiting } = _a, transitionProps = tslib_es6.__rest(_a, ["animationStates", "initialAnimationStyles", "onEntering", "onExiting"]);
    const [state, setState] = hooks.useState('entering');
    const animationCallbackRef = hooks.useRef();
    const busyStateResolveRef = hooks.useRef();
    const { controller, nodeRef } = useAnimation.useAnimation(state, {
        animationStates,
        isAnimatedOnMount: true,
        onAnimationEnd: hooks.useCallback(() => {
            var _a, _b;
            // resolve animation callbacks & busyStates
            (_a = animationCallbackRef.current) === null || _a === void 0 ? void 0 : _a.call(animationCallbackRef);
            animationCallbackRef.current = undefined;
            (_b = busyStateResolveRef.current) === null || _b === void 0 ? void 0 : _b.call(busyStateResolveRef);
            busyStateResolveRef.current = undefined;
        }, [])
    });
    const { addBusyState } = hooks_UNSAFE_useMessagesContext.useMessagesContext();
    const onEnteringCallback = hooks.useCallback((node, callback, metadata) => {
        var _a;
        // cancel any existing animation
        if (animationCallbackRef.current) {
            animationCallbackRef.current = undefined;
            controller.cancel();
        }
        // resolve any existing busyState
        (_a = busyStateResolveRef.current) === null || _a === void 0 ? void 0 : _a.call(busyStateResolveRef);
        busyStateResolveRef.current = undefined;
        onEntering === null || onEntering === void 0 ? void 0 : onEntering(node, undefined, metadata);
        // start the animation and set the callback & busyState
        setState('entering');
        // if there is no animation configured, resolve immediately
        if (animationStates['entering'] === undefined &&
            animationStates['exiting => entering'] === undefined) {
            callback === null || callback === void 0 ? void 0 : callback();
            return;
        }
        animationCallbackRef.current = callback;
        busyStateResolveRef.current = addBusyState === null || addBusyState === void 0 ? void 0 : addBusyState('messages animating');
    }, [animationStates, controller, addBusyState, onEntering]);
    const onExitingCallback = hooks.useCallback((node, callback, metadata) => {
        var _a;
        // cancel any existing animation
        if (animationCallbackRef.current) {
            animationCallbackRef.current = undefined;
            controller.cancel();
        }
        // resolve any existing busyState
        (_a = busyStateResolveRef.current) === null || _a === void 0 ? void 0 : _a.call(busyStateResolveRef);
        busyStateResolveRef.current = undefined;
        onExiting === null || onExiting === void 0 ? void 0 : onExiting(node, undefined, metadata);
        // start the animation and set the callback & busyState
        setState('exiting');
        // if there is no animation configured, resolve immediately
        if (animationStates['exiting'] === undefined &&
            animationStates['entering => exiting'] === undefined) {
            callback === null || callback === void 0 ? void 0 : callback();
            return;
        }
        animationCallbackRef.current = callback;
        busyStateResolveRef.current = addBusyState === null || addBusyState === void 0 ? void 0 : addBusyState('messages animating');
    }, [animationStates, controller, addBusyState, onExiting]);
    // if animation is interrupted, the busyState may be left hanging. So clear that on unmount
    // Note: When using a class-based component inside a functional component, the timings of
    // componentDidMount and useEffect might differ. So, in order to guarantee the registration
    // of the cleanup function, use useLayoutEffect instead of useEffect. This way we can make sure
    // the cleanup registers at all times.
    hooks.useLayoutEffect(() => () => { var _a; return (_a = busyStateResolveRef.current) === null || _a === void 0 ? void 0 : _a.call(busyStateResolveRef); }, []);
    return (jsxRuntime.jsx("div", Object.assign({ ref: nodeRef, style: initialAnimationStyles }, { children: jsxRuntime.jsx(PRIVATE_TransitionGroup.Transition, Object.assign({}, transitionProps, { onEntering: onEnteringCallback, onExiting: onExitingCallback })) })));
}

/**
 * The component that renders individual messages for the provided data.
 */
function MessagesManager({ data, animationStates, children, initialAnimationStyles, onMessageWillRemove }) {
    /**
     * Handles when a message has finished to exit.
     *
     * @param node The corresponding message element
     * @param callback A callback function to be called after the animation is complete
     */
    const handleExited = hooks.useCallback(async (node, metadata) => {
        metadata && (onMessageWillRemove === null || onMessageWillRemove === void 0 ? void 0 : onMessageWillRemove(metadata.key, metadata.index, node));
    }, [onMessageWillRemove]);
    return (jsxRuntime.jsx(PRIVATE_TransitionGroup.TransitionGroup, Object.assign({ elementType: preact.Fragment }, { children: data.map((item, index) => (jsxRuntime.jsx(MessageTransition, Object.assign({ animationStates: animationStates, initialAnimationStyles: initialAnimationStyles, metadata: { index, key: item.key }, onExited: handleExited }, { children: children === null || children === void 0 ? void 0 : children({ index, item }) }), item.key))) })));
}

exports.MessagesManager = MessagesManager;
/*  */
//# sourceMappingURL=MessagesManager-88e137d7.js.map
