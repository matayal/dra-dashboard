/* @oracle/oraclejet-preact: 14.1.0 */
'use strict';

Object.defineProperty(exports, '__esModule', { value: true });

var jsxRuntime = require('preact/jsx-runtime');
var hooks = require('preact/hooks');
require("identity-obj-proxy");
require('./UNSAFE_HighlightText.js');
require('./PRIVATE_List.js');
require('./UNSAFE_Flex.js');
require('./UNSAFE_Skeleton.js');
var utils_UNSAFE_logger = require('./utils/UNSAFE_logger.js');
var Flex = require('./Flex-b113edd5.js');
var HighlightText = require('./HighlightText-5bdc12cb.js');
var List = require('./List-63716a22.js');
var Skeleton = require('./Skeleton-02ffb696.js');
require('./UNSAFE_Floating.js');
var UNSAFE_Layer = require('./UNSAFE_Layer.js');
var utils_UNSAFE_arrayUtils = require('./utils/UNSAFE_arrayUtils.js');
var Floating = require('./Floating-48167355.js');
var hooks_UNSAFE_usePress = require('./hooks/UNSAFE_usePress.js');
require('./index-3651c0e7.js');
require('./utils/UNSAFE_classNames.js');
var classNames = require('./classNames-55bceee6.js');
var UNSAFE_Icons = require('./index-d5067e50.js');
var hooks_UNSAFE_useFormFieldContext = require('./hooks/UNSAFE_useFormFieldContext.js');
var UNSAFE_UserAssistance = require('./UNSAFE_UserAssistance.js');
var hooks_UNSAFE_useTranslationBundle = require('./hooks/UNSAFE_useTranslationBundle.js');
require('./utils/PRIVATE_clientHints.js');
var clientHints = require('./clientHints-e821b5ee.js');
require('./utils/UNSAFE_mergeProps.js');
require('./utils/UNSAFE_keys.js');
require('./LoadMoreCollection-eaa4ed6f.js');
require('./PRIVATE_Collection.js');
require('./Collection-2647e7ee.js');
require('preact');
require('./hooks/UNSAFE_useViewportIntersect.js');
require('./PRIVATE_VirtualizedCollection.js');
require('./VirtualizedCollection-19e514e1.js');
require('./hooks/UNSAFE_useTabbableMode.js');
require('./UNSAFE_FocusTrap.js');
require('./FocusTrap-8af50913.js');
require('preact/compat');
require('./utils/PRIVATE_tabbableUtils.js');
require('./_curry1-f1ebd742.js');
require('./_curry2-588f7ddc.js');
require('./_curry3-bc6e6a86.js');
require('./hooks/UNSAFE_useId.js');
require('./hooks/PRIVATE_useSelection.js');
require('./hooks/PRIVATE_useCurrentKey.js');
require('./hooks/PRIVATE_useCollectionFocusRing.js');
require('./hooks/PRIVATE_useTabbableModeSet.js');
require('./hooks/PRIVATE_useItemAction.js');
require('./utils/PRIVATE_collectionUtils.js');
require('./tslib.es6-6f60dd09.js');
require('./utils/UNSAFE_interpolations/dimensions.js');
require('./utils/UNSAFE_size.js');
require('./utils/UNSAFE_mergeInterpolations.js');
require('./_has-2eedb7e0.js');
require('./utils/UNSAFE_interpolations/borders.js');
require('./utils/UNSAFE_interpolations/boxalignment.js');
require('./keys-326d80d5.js');
require('./utils/UNSAFE_interpolations/flexbox.js');
require('./flexbox-6deddb70.js');
require('./utils/UNSAFE_interpolations/flexitem.js');
require('./flexitem-0c1e9a72.js');
require('./UNSAFE_Selector.js');
require('./UNSAFE_Icon.js');
require('./Icon-c44e10c9.js');
require('./hooks/UNSAFE_useTooltip.js');
require('./hooks/UNSAFE_useHover.js');
require('./hooks/UNSAFE_useToggle.js');
require('./hooks/UNSAFE_useFocus.js');
require('./hooks/UNSAFE_useTouch.js');
require('./hooks/UNSAFE_useAnimation.js');
require('./useAnimation-576ef8bc.js');
require('./index-55dfe40c.js');
require('./hooks/UNSAFE_useUser.js');
require('./UNSAFE_Environment.js');
require('./utils/PRIVATE_floatingUtils.js');
require('./utils/PRIVATE_refUtils.js');
require('./hooks/UNSAFE_useOutsideClick.js');
require('./hooks/UNSAFE_useTheme.js');
require('./InlineHelpSource-c498a09a.js');
require('./UNSAFE_ComponentMessage.js');
require('./ComponentMessage-eea92e6b.js');
require('./PRIVATE_Message.js');
require('./utils/PRIVATE_timer.js');
require('./MessageCloseButton-66757186.js');
require('./UNSAFE_Button.js');
require('./Button-07d97191.js');
require('./UNSAFE_BaseButton.js');
require('./BaseButton-9bfe304e.js');
require('./hooks/UNSAFE_useActive.js');
require('./MessageDetail-9ab2fec2.js');
require('./MessageFormattingUtils-fac29bd4.js');
require('./utils/UNSAFE_getLocale.js');
require('./utils/UNSAFE_stringUtils.js');
require('./stringUtils-dad38408.js');
require('./Message.types-d5b1820f.js');
require('./MessageStartIcon-5cdb8fbe.js');
require('./MessageSummary-ea4ba9b8.js');
require('./MessageTimestamp-cb7998db.js');
require('./MessageUtils-c82ad817.js');
require('./utils/UNSAFE_soundUtils.js');
require('./MessagesManager-88e137d7.js');
require('./PRIVATE_TransitionGroup.js');
require('./hooks/UNSAFE_useMessagesContext.js');
require('./UNSAFE_HiddenAccessible.js');
require('./HiddenAccessible-42dab376.js');
require('./ComponentMessageContainer-7880a1b9.js');
require('./hooks/UNSAFE_useFormContext.js');

/**
 * @license
 * Copyright (c) %FIRST_YEAR% %CURRENT_YEAR%, Oracle and/or its affiliates.
 * The Universal Permissive License (UPL), Version 1.0
 * as shown at https://oss.oracle.com/licenses/upl/
 * @ignore
 */
function renderItemText(item, itemText) {
    var _a;
    // if item-text is a string and the data has the specified field, return it;
    // otherwise log an error
    if (typeof itemText === 'string') {
        if ((_a = item.data) === null || _a === void 0 ? void 0 : _a.hasOwnProperty(itemText)) {
            const retData = item.data[itemText];
            return String(retData);
        }
        utils_UNSAFE_logger.Logger.error('SelectMultiple: itemText specifies field that does not exist: ' + itemText);
        // return undefined if the field doesn't exist
        return undefined;
    }
    // if item-text is a function, call it to create a display label
    return itemText(item);
}

const itemStyles = "_1m0sjxy";

const noOp = () => {};

function DefaultList({
  accessibleSummary,
  currentItemVariant,
  currentKey,
  data,
  itemText,
  onCurrentKeyChange,
  onItemAction,
  onLoadRange = noOp,
  onSelectionChange,
  searchText,
  selectedKeys,
  selectionMode
}) {
  const listItemRenderer = hooks.useCallback(listItemContext => {
    const itemContext = {
      data: listItemContext.data,
      key: listItemContext.metadata.key,
      metadata: listItemContext.metadata
    };
    const renderedItemText = renderItemText(itemContext, itemText);
    return jsxRuntime.jsxs(Flex.Flex, {
      children: [listItemContext.selector && listItemContext.selector(), jsxRuntime.jsx("div", Object.assign({
        class: itemStyles
      }, {
        children: jsxRuntime.jsx(HighlightText.HighlightText, Object.assign({
          matchText: searchText
        }, {
          children: renderedItemText
        }))
      }))]
    });
  }, [itemText, searchText]);
  const keys = hooks.useMemo(() => {
    return {
      all: false,
      keys: selectedKeys !== null && selectedKeys !== void 0 ? selectedKeys : new Set()
    };
  }, [selectedKeys]);
  return jsxRuntime.jsx(List.List, Object.assign({
    accessibleSummary: accessibleSummary,
    allowTabbableMode: false,
    currentItemVariant: currentItemVariant,
    currentKey: currentKey,
    data: data !== null && data !== void 0 ? data : null,
    loadingIndicator: loadingIndicator,
    onCurrentKeyChange: onCurrentKeyChange,
    onItemAction: onItemAction,
    onLoadRange: onLoadRange,
    onSelectionChange: onSelectionChange,
    role: "listbox",
    selectedKeys: keys,
    selectionMode: selectionMode
  }, {
    children: context => listItemRenderer(context)
  }));
}
/**
 * Custom 3 Skeleton loader for select multiple
 * TODO: to remove this once https://jira.oraclecorp.com/jira/browse/JET-51527 is solved
 */

const loadingIndicator = jsxRuntime.jsx(List.SkeletonContainer, Object.assign({
  minimumCount: 3
}, {
  children: () => {
    return jsxRuntime.jsx(Flex.Flex, Object.assign({
      height: "12x",
      align: "center"
    }, {
      children: jsxRuntime.jsx(Skeleton.Skeleton, {
        height: "4x"
      })
    }));
  }
}));

const KEYS = {
    TAB: 'Tab',
    ENTER: 'Enter',
    ESC: 'Escape',
    SPACE: 'Space',
    LEFT: 'ArrowLeft',
    UP: 'ArrowUp',
    RIGHT: 'ArrowRight',
    DOWN: 'ArrowDown',
    SHIFT_LEFT: 'ShiftLeft',
    SHIFT_RIGHT: 'ShiftRight',
    CTRL_LEFT: 'ControlLeft',
    CTRL_RIGHT: 'ControlRight',
    ALT_LEFT: 'AltLeft',
    ALT_RIGHT: 'AltRight',
    PAGE_UP: 'PageUp',
    PAGE_DOWN: 'PageDown',
    HOME: 'Home',
    END: 'End',
    BACKSPACE: 'Backspace',
    DELETE: 'Delete'
};
const isControlKey = (event) => {
    switch (event.code) {
        case KEYS.SHIFT_LEFT:
        case KEYS.SHIFT_RIGHT:
        case KEYS.CTRL_LEFT:
        case KEYS.CTRL_RIGHT:
        case KEYS.ALT_LEFT:
        case KEYS.ALT_RIGHT:
            return true;
        default:
            return event.metaKey || event.ctrlKey;
    }
};
const isFunctionKey = (event) => {
    return /\bF([1-9]|1[0-2])\b/i.test(event.code);
};
const isControlOrFunctionKey = (event) => {
    return isControlKey(event) || isFunctionKey(event);
};
const isSimpleClick = (event) => {
    return event.button === 0 && !event.ctrlKey;
};
const preventDefaultForCurrentTarget = (event) => {
    if (event.currentTarget === event.target) {
        event.preventDefault();
    }
};

/**
 * @license
 * Copyright (c) %FIRST_YEAR% %CURRENT_YEAR%, Oracle and/or its affiliates.
 * The Universal Permissive License (UPL), Version 1.0
 * as shown at https://oss.oracle.com/licenses/upl/
 * @ignore
 */
const isPointOutside = (event, ref) => {
    const target = event.target;
    if (target) {
        const doc = getDocument(target);
        if (!doc.contains(target))
            return false;
    }
    return ref.every((elRef) => { var _a; return !((_a = elRef.current) === null || _a === void 0 ? void 0 : _a.contains(target)); });
};
const getDocument = (node) => { var _a; return (_a = node === null || node === void 0 ? void 0 : node.ownerDocument) !== null && _a !== void 0 ? _a : document; };
const useOutsideMousedown = ({ isDisabled: disabled = false, ref, handler }) => {
    hooks.useEffect(() => {
        const refs = utils_UNSAFE_arrayUtils.coerceArray(ref);
        if (!handler ||
            disabled ||
            (refs.length > 0 && refs.findIndex((elRef) => elRef.current === null) > -1))
            return;
        const onMouseDown = (event) => {
            if (isPointOutside(event, refs)) {
                handler === null || handler === void 0 ? void 0 : handler(event);
            }
        };
        const firstElRef = refs[0];
        const doc = getDocument(firstElRef.current);
        if (doc) {
            doc.addEventListener('mousedown', onMouseDown, true);
            return () => {
                doc.removeEventListener('mousedown', onMouseDown, true);
            };
        }
        return undefined;
    }, [disabled, handler, ref]);
};

const rootStyles$4 = {
  base: "_10e9xaq"
};
const DEFAULT_PLACEMENT = 'bottom-start';
function Dropdown({
  anchorRef,
  children,
  dropdownRef,
  id,
  isOpen,
  onAutoDismiss,
  onPosition
}) {
  var _a;

  const [placement, setPlacement] = hooks.useState(DEFAULT_PLACEMENT);
  hooks.useEffect(() => {
    // reset the placement to the default when the dropdown closes, not opens, so that it doesn't
    // initially open in the previous position and then move to the default position on the
    // rerender after the state is updated
    if (!isOpen) {
      setPlacement(DEFAULT_PLACEMENT);
    }
  }, [isOpen, setPlacement]);
  const handlePosition = hooks.useCallback(positionData => {
    // update the placement so that the dropdown stays where it is until there is a collision,
    // i.e. it no longer fits, instead of letting it try to move back to the default position
    // on every render
    setPlacement(positionData.placement); // call the callback that was passed in through props

    onPosition === null || onPosition === void 0 ? void 0 : onPosition(positionData);
  }, [onPosition, setPlacement]);
  const handleAutoDismiss = hooks.useCallback(event => {
    onAutoDismiss === null || onAutoDismiss === void 0 ? void 0 : onAutoDismiss(event);
  }, [onAutoDismiss]);
  const handleKeyDown = hooks.useCallback(event => {
    if (event.defaultPrevented || isControlOrFunctionKey(event)) {
      return;
    }

    switch (event.code) {
      case KEYS.ESC:
      case KEYS.TAB:
        handleAutoDismiss(event);
        break;
    }
  }, [handleAutoDismiss]); // use the mousedown event to be consistent with legacy JET and so that we're hiding the dropdown
  // on the same event where focus will transfer

  useOutsideMousedown({
    isDisabled: !isOpen,
    ref: [anchorRef, dropdownRef],
    handler: handleAutoDismiss
  }); // TODO: get dropdown y (mainAxis) offset from --oj-c-PRIVATE-DO-NOT-USE-private-core-global-dropdown-offset

  const offsetValue = {
    mainAxis: 4,
    crossAxis: 0
  };
  const inlineStyle = {
    minWidth: `${(_a = anchorRef.current) === null || _a === void 0 ? void 0 : _a.offsetWidth}px`
  };
  return !isOpen ? null : jsxRuntime.jsx(UNSAFE_Layer.Layer, Object.assign({
    logicalParentRef: anchorRef
  }, {
    children: jsxRuntime.jsx(Floating.Floating, Object.assign({
      anchorRef: anchorRef,
      sizeOptions: {
        isMaxHeightAdjusted: true,
        maxHeightCeiling: 400
      },
      ref: dropdownRef,
      placement: placement,
      offsetValue: offsetValue,
      onPosition: handlePosition
    }, {
      children: jsxRuntime.jsx("div", Object.assign({
        class: rootStyles$4.base,
        id: id,
        style: inlineStyle,
        onKeyDown: handleKeyDown,
        onMouseDown: preventDefaultForCurrentTarget
      }, {
        children: children
      }))
    }))
  }));
}

const ojButtonHeight = '2.75rem'; // TODO: replace this with var(--oj-button-sm-height) once it is available

const ojButtonSmHeight = '2.25rem'; // TODO: replace this with var(--oj-button-border-radius) once it is available

const ojButtonBorderRadius = 'var(--oj-c-PRIVATE-DO-NOT-USE-core-border-radius-md)'; // TODO: replace this with var(--oj-button-borderless-chrome-text-color) once it is available

const ojButtonBorderlessChromeTextColor = 'var(--oj-c-PRIVATE-DO-NOT-USE-core-text-color-primary)'; // TODO: replace this with var (--oj-button-borderless-chrome-text-color-disabled) once it is available

const ojButtonBorderlessChromeTextColorDisabled = 'var(--oj-c-PRIVATE-DO-NOT-USE-core-text-color-disabled)'; // TODO: replace this with var(--oj-button-borderless-chrome-text-color-hover) once it is available

const ojButtonBorderlessChromeTextColorHover = 'var(--oj-c-PRIVATE-DO-NOT-USE-core-text-color-primary)'; // TODO: replace this with var(--oj-button-borderless-chrome-bg-color-hover) once it is available

const ojButtonBorderlessChromeBgColorHover = 'var(--oj-c-PRIVATE-DO-NOT-USE-core-bg-color-hover)'; // TODO: replace this with var(--oj-button-borderless-chrome-border-color-hover) once it is available

const ojButtonBorderlessChromeBorderColorHover = 'transparent'; // TODO: replace this with var(--oj-c-PRIVATE-DO-NOT-USE-button-icon-size) once it is available

const ojButtonIconSize = 'var(--oj-c-PRIVATE-DO-NOT-USE-core-icon-size-lg)';
const rootStyles$3 = {
  base: "_19ki64l",
  sizeMd: "j1zkrn",
  sizeSm: "_1uuoh30",
  enabled: "dp7ymw",
  disabled: "zocnac"
};

const noop = () => {};

function DropdownArrow({
  isDisabled = false,
  onClick,
  size = 'md'
}) {
  const preventDefault = hooks.useCallback(event => {
    event.preventDefault();
  }, []);
  const {
    pressProps
  } = hooks_UNSAFE_usePress.usePress(onClick !== null && onClick !== void 0 ? onClick : noop, {
    isDisabled
  });
  const styleClasses = classNames.classNames([rootStyles$3.base, size === 'sm' ? rootStyles$3.sizeSm : rootStyles$3.sizeMd, isDisabled ? rootStyles$3.disabled : rootStyles$3.enabled]);
  return jsxRuntime.jsx("span", Object.assign({
    "aria-hidden": "true",
    class: styleClasses,
    tabIndex: -1,
    onMouseDown: preventDefault
  }, pressProps, {
    children: jsxRuntime.jsx(UNSAFE_Icons.SvgIcoCaretDown, {})
  }));
}

const rootStyles$2 = {
  base: "hplqi8",
  // TODO: These should really be applied directly to the child ListView so that the content
  // displays under the padding when scrolled, but we can't apply styles to the child collection.
  // TODO: Also need to figure out how to determine whether the collection is a ListView (in
  // the collectionRenderer case) in order to apply this styling.
  topGap: "x2o1z5",
  bottomGap: "de3yeg",
  loading: "khio7z"
};
function DropdownList({
  children,
  hasBottomGap = true,
  isLoading = false
}) {
  const styleClasses = classNames.classNames([rootStyles$2.base, rootStyles$2.topGap, hasBottomGap && rootStyles$2.bottomGap, isLoading && rootStyles$2.loading]);
  return jsxRuntime.jsx("div", Object.assign({
    class: styleClasses,
    onMouseDown: preventDefaultForCurrentTarget
  }, {
    children: children
  }));
}

const rootStyles$1 = "_18g93ys";
function DropdownUserAssistance(props) {
  // Prevent the focus from transferring when the user clicks on an empty/non-clickable area
  // of the user assistance
  const handleMouseDown = hooks.useCallback(event => {
    var _a; // Don't call preventDefault when the user clicks on the help source link, so that the
    // focus is allowed to transfer in that case.


    if (((_a = event.target) === null || _a === void 0 ? void 0 : _a.tagName) !== 'A') {
      event.preventDefault();
    }
  }, []);
  return jsxRuntime.jsx(hooks_UNSAFE_useFormFieldContext.FormFieldContext.Provider, Object.assign({
    value: {
      isFocused: true
    }
  }, {
    children: jsxRuntime.jsx("div", Object.assign({
      class: rootStyles$1,
      onMouseDown: handleMouseDown
    }, {
      children: jsxRuntime.jsx(UNSAFE_UserAssistance.InlineUserAssistance, Object.assign({}, props))
    }))
  }));
}

const rootStyles = "sy8p0x";
function EmptyResults() {
  const translations = hooks_UNSAFE_useTranslationBundle.useTranslationBundle('@oracle/oraclejet-preact'); // TODO: figure out whether we need a separate resource string for this message;
  // (JET-53984 - Preact Select* components: empty results message)
  // call preventDefault for mousedown on this div so that focus does not transfer from
  // the input

  return jsxRuntime.jsx("div", Object.assign({
    class: rootStyles,
    onMouseDown: preventDefaultForCurrentTarget
  }, {
    children: translations.select_noMatchesFound()
  }));
}

/**
 * @license
 * Copyright (c) %FIRST_YEAR% %CURRENT_YEAR%, Oracle and/or its affiliates.
 * The Universal Permissive License (UPL), Version 1.0
 * as shown at https://oss.oracle.com/licenses/upl/
 * @ignore
 */
/**
 * Helper function to determine whether the current device is a mobile device
 * @returns true if running on a mobile device, false otherwise
 */
function isMobile() {
    const deviceType = clientHints.getClientHints().deviceType;
    return deviceType === 'phone' || deviceType === 'tablet';
}
function isBeforeDataFetch(data) {
    return data.sizePrecision === 'atLeast' && data.totalSize === 0;
}

/**
 * @license
 * Copyright (c) %FIRST_YEAR% %CURRENT_YEAR%, Oracle and/or its affiliates.
 * The Universal Permissive License (UPL), Version 1.0
 * as shown at https://oss.oracle.com/licenses/upl/
 * @ignore
 */
/**
 * Hook that manages state and behavior for a Select* component.  This hook creates state
 * variables and event listeners, returning properties to apply to components internally
 * rendered by a Select* component, as well as state information.
 *
 * @param data Specifies data for the dropdown list.
 * @param inputRef Ref to the input element.
 * @param isFocused Specifies whether the component has focus.
 * @param onFilter Callback function to trigger loading data for the dropdown list,
 * which may or may not be filtered by user entered text.
 *
 * @returns Component state and event listeners.
 */
function useSelectCommon({ data, inputRef, isFocused, onFilter }) {
    const mainFieldRef = hooks.useRef(null);
    const dropdownRef = hooks.useRef(null);
    const [isDropdownOpen, setDropdownOpen] = hooks.useState(false);
    const [isDropdownAbove, setDropdownAbove] = hooks.useState(false);
    const [currentRow, setCurrentRow] = hooks.useState({
        rowKey: undefined
    });
    const [selectedKeys, setSelectedKeys] = hooks.useState();
    const [isUserFiltering, setUserFiltering] = hooks.useState(false);
    const [userInput, setUserInput] = hooks.useState();
    const [searchText, setSearchText] = hooks.useState();
    const onMouseDown = hooks.useCallback((event) => {
        // const target = event.target as HTMLElement;
        if (event.defaultPrevented || !isSimpleClick(event)) {
            return;
        }
        if (!isDropdownOpen) {
            setDropdownOpen(true);
        }
        // this is needed to focus the input when clicking on the inside label when there is no
        // value;  otherwise the component looks focused but doesn't actually have physical focus
        setTimeout(function () {
            var _a;
            (_a = inputRef.current) === null || _a === void 0 ? void 0 : _a.focus();
        }, 0);
    }, [isDropdownOpen]);
    const handleDropdownArrowClick = hooks.useCallback(() => {
        var _a;
        setDropdownOpen(!isDropdownOpen);
        // focus the input so that if the user Tabs afterwards, it loses focus and the dropdown closes
        (_a = inputRef.current) === null || _a === void 0 ? void 0 : _a.focus();
    }, [isDropdownOpen]);
    const handleDropdownAutoDismiss = hooks.useCallback((event) => {
        var _a, _b, _c;
        if (isDropdownOpen) {
            setDropdownOpen(false);
            switch (event === null || event === void 0 ? void 0 : event.type) {
                case 'keydown':
                    const keyboardEvent = event;
                    switch (keyboardEvent.code) {
                        case KEYS.ESC:
                            // focus the input when the user cancels out of the dropdown
                            (_a = inputRef.current) === null || _a === void 0 ? void 0 : _a.focus();
                            break;
                        default:
                            break;
                    }
                    break;
                case 'mousedown':
                    // if focus is in the dropdown, focus the input before the dropdown is hidden so that
                    // focus will transfer correctly when the target is not focusable;
                    // otherwise the text cursor appears in the input again
                    if ((_b = dropdownRef.current) === null || _b === void 0 ? void 0 : _b.contains(document.activeElement)) {
                        (_c = inputRef.current) === null || _c === void 0 ? void 0 : _c.focus();
                    }
                    break;
                default:
                    break;
            }
        }
    }, [isDropdownOpen]);
    const handleDropdownPosition = hooks.useCallback((data) => {
        setDropdownAbove(data.placement.startsWith('top'));
    }, []);
    const handleUpDownArrowKeys = hooks.useCallback((event) => {
        var _a, _b, _c, _d;
        if (!isDropdownOpen) {
            setDropdownOpen(true);
        }
        else {
            // transfer physical focus into the dropdown
            const firstFocusableElem = (_a = dropdownRef.current) === null || _a === void 0 ? void 0 : _a.querySelector('[tabindex="0"]');
            firstFocusableElem === null || firstFocusableElem === void 0 ? void 0 : firstFocusableElem.focus();
            // if there is no current item set, make the first item current
            if (data !== undefined && currentRow.rowKey === undefined) {
                setCurrentRow({ rowKey: (_d = (_c = (_b = data === null || data === void 0 ? void 0 : data.data) === null || _b === void 0 ? void 0 : _b[0]) === null || _c === void 0 ? void 0 : _c.metadata) === null || _d === void 0 ? void 0 : _d.key });
            }
        }
        // prevent the page from scrolling
        event.preventDefault();
    }, [currentRow, data, isDropdownOpen]);
    const handleMainFieldKeyDown = hooks.useCallback((event) => {
        // const target = event.target as HTMLElement;
        // ignore control key and function key
        if (isControlOrFunctionKey(event)) {
            return;
        }
        switch (event.code) {
            case KEYS.PAGE_UP:
            case KEYS.PAGE_DOWN:
                // prevent the page from scrolling
                event.preventDefault();
                return;
            case KEYS.UP:
            case KEYS.DOWN:
                // prevent the page from scrolling
                event.preventDefault();
                break;
            case KEYS.ESC:
                if (isDropdownOpen) {
                    setDropdownOpen(false);
                    event.preventDefault();
                    // JET-53183 - core pack compat: stop propagation of handled events
                    // we don't want a parent collection component to stop editing the row when we close
                    // the dropdown
                    event.stopPropagation();
                }
                break;
            default:
                break;
        }
    }, [isDropdownOpen]);
    const handleMainFieldKeyUp = hooks.useCallback((event) => {
        // ignore control key and function key
        if (isControlOrFunctionKey(event)) {
            return;
        }
        switch (event.code) {
            case KEYS.UP:
            case KEYS.DOWN:
                handleUpDownArrowKeys(event);
                break;
            default:
                break;
        }
    }, [handleUpDownArrowKeys]);
    const handleInput = hooks.useCallback((detail) => {
        var _a;
        if (!isDropdownOpen) {
            setDropdownOpen(true);
        }
        setUserFiltering(true);
        setUserInput(detail.value);
        const str = (_a = detail.value) === null || _a === void 0 ? void 0 : _a.trim();
        setSearchText(str);
        onFilter === null || onFilter === void 0 ? void 0 : onFilter({ searchText: str });
    }, [isDropdownOpen, onFilter]);
    const onCurrentKeyChange = hooks.useCallback((detail) => {
        setCurrentRow({ rowKey: detail.value });
    }, []);
    const stopFiltering = hooks.useCallback(() => {
        setUserFiltering(false);
        setUserInput('');
        setSearchText('');
    }, []);
    // the user is not actively filtering if the dropdown is closed and the component doesn't
    // have focus
    hooks.useEffect(() => {
        if (!isDropdownOpen && !isFocused && isUserFiltering) {
            stopFiltering();
        }
    }, [isDropdownOpen, isFocused, isUserFiltering]);
    // need to call onFilter with undefined searchText when the dropdown opens and the
    // user is NOT filtering
    hooks.useEffect(() => {
        if (isDropdownOpen && !isUserFiltering) {
            onFilter === null || onFilter === void 0 ? void 0 : onFilter({ searchText: undefined });
        }
    }, [isDropdownOpen, isUserFiltering, onFilter]);
    // when the dropdown closes, reset the isDropdownAbove flag
    hooks.useEffect(() => {
        if (!isDropdownOpen) {
            setDropdownAbove(false);
        }
    }, [isDropdownOpen]);
    return {
        currentRow,
        dropdownRef,
        handleDropdownArrowClick,
        handleDropdownAutoDismiss,
        handleDropdownPosition,
        handleInput,
        handleMainFieldKeyDown,
        handleMainFieldKeyUp,
        handleUpDownArrowKeys,
        isDropdownAbove,
        isDropdownOpen,
        // the field should remain to look focused while the dropdown is open,
        // in case physical focus is in the dropdown
        isFocused: isFocused || isDropdownOpen,
        isUserFiltering,
        mainFieldRef,
        onCurrentKeyChange,
        onMouseDown,
        searchText,
        selectedKeys,
        setCurrentRow,
        setDropdownOpen,
        setSelectedKeys,
        stopFiltering,
        userInput
    };
}

/**
 * @license
 * Copyright (c) %FIRST_YEAR% %CURRENT_YEAR%, Oracle and/or its affiliates.
 * The Universal Permissive License (UPL), Version 1.0
 * as shown at https://oss.oracle.com/licenses/upl/
 * @ignore
 */

exports.DefaultList = DefaultList;
exports.Dropdown = Dropdown;
exports.DropdownArrow = DropdownArrow;
exports.DropdownList = DropdownList;
exports.DropdownUserAssistance = DropdownUserAssistance;
exports.EmptyResults = EmptyResults;
exports.KEYS = KEYS;
exports.isBeforeDataFetch = isBeforeDataFetch;
exports.isControlKey = isControlKey;
exports.isControlOrFunctionKey = isControlOrFunctionKey;
exports.isFunctionKey = isFunctionKey;
exports.isMobile = isMobile;
exports.isSimpleClick = isSimpleClick;
exports.preventDefaultForCurrentTarget = preventDefaultForCurrentTarget;
exports.renderItemText = renderItemText;
exports.useSelectCommon = useSelectCommon;
/*  */
//# sourceMappingURL=PRIVATE_SelectCommon.js.map
