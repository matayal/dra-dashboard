/* @oracle/oraclejet-preact: 14.1.0 */
'use strict';

var jsxRuntime = require('preact/jsx-runtime');
var preact = require('@testing-library/preact');
var chai = require('chai');
var UNSAFE_InputText = require('../../UNSAFE_InputText.js');
require('../../UNSAFE_NumberInputText.js');
var NumberInputText = require('../../NumberInputText-a83c00be.js');
require('preact');
require('preact/compat');
require('preact/hooks');
require('../../hooks/UNSAFE_useClearIcon.js');
require('../../hooks/UNSAFE_useToggle.js');
require('../../hooks/UNSAFE_useFocusableTextField.js');
require('../../tslib.es6-6f60dd09.js');
require('../../hooks/UNSAFE_useFocusWithin.js');
require('../../useFocusWithin-145e8682.js');
require('../../hooks/UNSAFE_useFormContext.js');
require('../../hooks/UNSAFE_useFormFieldContext.js');
require('../../hooks/UNSAFE_useHover.js');
require('../../hooks/UNSAFE_useLengthFilter.js');
require('../../utils/UNSAFE_lengthFilter.js');
require('../../hooks/UNSAFE_useTextField.js');
require('../../hooks/UNSAFE_useId.js');
require('../../UNSAFE_Label.js');
require('../../utils/UNSAFE_classNames.js');
require('../../classNames-55bceee6.js');

require('../../hooks/UNSAFE_usePrefixSuffix.js');
require('../../UNSAFE_PrefixSuffix.js');
require('../../hooks/UNSAFE_useUser.js');
require('../../UNSAFE_Environment.js');
require('../../UNSAFE_Layer.js');
require('../../UNSAFE_TextField.js');
require('../../ReadonlyTextFieldInput-ec13a273.js');
require('../../hooks/UNSAFE_useTabbableMode.js');
require('../../utils/UNSAFE_interpolations/text.js');
require('../../keys-326d80d5.js');
require('../../_curry1-f1ebd742.js');
require('../../_has-2eedb7e0.js');
require('../../utils/UNSAFE_mergeInterpolations.js');
require('../../_curry3-bc6e6a86.js');
require('../../_curry2-588f7ddc.js');
require('../../FormControlUtils-c960c51d.js');
require('../../hooks/UNSAFE_useTranslationBundle.js');
require('../../UNSAFE_LabelValueLayout.js');
require('../../UNSAFE_Flex.js');
require('../../Flex-b113edd5.js');
require('../../utils/UNSAFE_interpolations/dimensions.js');
require('../../utils/UNSAFE_arrayUtils.js');
require('../../utils/UNSAFE_size.js');
require('../../utils/UNSAFE_interpolations/boxalignment.js');
require('../../utils/UNSAFE_interpolations/flexbox.js');
require('../../flexbox-6deddb70.js');
require('../../utils/UNSAFE_interpolations/flexitem.js');
require('../../flexitem-0c1e9a72.js');
require('../../TextFieldInput-c5f861ba.js');
require('../../hooks/UNSAFE_useTextFieldInputHandlers.js');
require('../../utils/PRIVATE_clientHints.js');
require('../../clientHints-e821b5ee.js');
require('../../hooks/UNSAFE_useDebounce.js');
require('../../UNSAFE_LiveRegion.js');
require('../../UNSAFE_UserAssistance.js');
require('../../InlineHelpSource-c498a09a.js');
require('../../UNSAFE_ComponentMessage.js');
require('../../ComponentMessage-eea92e6b.js');
require('../../PRIVATE_Message.js');
require('../../utils/PRIVATE_timer.js');
require('../../MessageCloseButton-66757186.js');
require('../../UNSAFE_Button.js');
require('../../Button-07d97191.js');
require('../../UNSAFE_BaseButton.js');
require('../../BaseButton-9bfe304e.js');
require('../../hooks/UNSAFE_usePress.js');
require('../../hooks/UNSAFE_useActive.js');
require('../../utils/UNSAFE_mergeProps.js');
require('../../index-3651c0e7.js');
require('../../index-d5067e50.js');
require('../../UNSAFE_Icon.js');
require('../../Icon-c44e10c9.js');
require('../../hooks/UNSAFE_useTooltip.js');
require('../../UNSAFE_Floating.js');
require('../../Floating-48167355.js');
require('../../index-55dfe40c.js');
require('../../utils/PRIVATE_floatingUtils.js');
require('../../utils/PRIVATE_refUtils.js');
require('../../hooks/UNSAFE_useOutsideClick.js');
require('../../hooks/UNSAFE_useFocus.js');
require('../../hooks/UNSAFE_useTouch.js');
require('../../hooks/UNSAFE_useAnimation.js');
require('../../useAnimation-576ef8bc.js');
require('../../hooks/UNSAFE_useTheme.js');
require('../../MessageDetail-9ab2fec2.js');
require('../../MessageFormattingUtils-fac29bd4.js');
require('../../utils/UNSAFE_getLocale.js');
require('../../utils/UNSAFE_stringUtils.js');
require('../../stringUtils-dad38408.js');
require('../../Message.types-d5b1820f.js');
require('../../MessageStartIcon-5cdb8fbe.js');
require('../../MessageSummary-ea4ba9b8.js');
require('../../MessageTimestamp-cb7998db.js');
require('../../MessageUtils-c82ad817.js');
require('../../utils/UNSAFE_logger.js');
require('../../utils/UNSAFE_soundUtils.js');
require('../../MessagesManager-88e137d7.js');
require('../../PRIVATE_TransitionGroup.js');
require('../../hooks/UNSAFE_useMessagesContext.js');
require('../../UNSAFE_HiddenAccessible.js');
require('../../HiddenAccessible-42dab376.js');
require('../../ComponentMessageContainer-7880a1b9.js');
require('../../utils/UNSAFE_componentUtils.js');
require('../../ClearIcon-be3cdd68.js');
require('../../hooks/UNSAFE_useCurrentValueReducer.js');
require('../../UNSAFE_Grid.js');
require('../../utils/UNSAFE_interpolations/grid.js');

const noOp = () => { };
function DemoInputText({ isDisabled, isReadonly, label, labelEdge, prefix, suffix, value }) {
    return (jsxRuntime.jsx(jsxRuntime.Fragment, { children: jsxRuntime.jsx(UNSAFE_InputText.InputText, { isDisabled: isDisabled, isReadonly: isReadonly, label: label, labelEdge: labelEdge, onInput: noOp, prefix: prefix, suffix: suffix, value: value }) }));
}
function DemoNumberInputText({ isDisabled, isReadonly, label, labelEdge, prefix, suffix, value }) {
    return (jsxRuntime.jsx(jsxRuntime.Fragment, { children: jsxRuntime.jsx(NumberInputText.NumberInputText, { isDisabled: isDisabled, isReadonly: isReadonly, label: label, labelEdge: labelEdge, onInput: noOp, prefix: prefix, suffix: suffix, value: value }) }));
}
const componentList = [
    { name: 'InputText', component: DemoInputText },
    { name: 'NumberInputText', component: DemoNumberInputText }
];
describe('Form Controls - Prefix/Suffix', () => {
    function testPrefixIsThere(inputElement, queryTextLength) {
        const element = inputElement === null || inputElement === void 0 ? void 0 : inputElement.previousElementSibling;
        chai.expect(element === null || element === void 0 ? void 0 : element.tagName.toUpperCase).not.equal('LABEL');
        chai.expect(queryTextLength).to.equal(1);
    }
    function testPrefixIsNotThere(inputElement, queryTextLength) {
        const element = inputElement === null || inputElement === void 0 ? void 0 : inputElement.previousElementSibling;
        chai.expect(element === null || element === void 0 ? void 0 : element.tagName.toUpperCase()).equal('LABEL');
        chai.expect(queryTextLength).to.equal(0);
    }
    function testSuffixIsThere(inputElement, queryTextLength) {
        const element = inputElement === null || inputElement === void 0 ? void 0 : inputElement.nextElementSibling;
        chai.expect(element).to.be.not.null;
        chai.expect(queryTextLength).to.equal(1);
    }
    function testSuffixIsNotThere(inputElement, queryTextLength) {
        const element = inputElement === null || inputElement === void 0 ? void 0 : inputElement.nextElementSibling;
        chai.expect(element).to.be.null;
        chai.expect(queryTextLength).to.equal(0);
    }
    componentList.forEach((compObj) => it(`${compObj.name}: prefix is there with value`, () => {
        const text = '+234';
        const { container, queryAllByText } = preact.render(jsxRuntime.jsx(compObj.component, { prefix: text, value: "123412", label: "with prefix" }));
        const inputElement = container.querySelector('input');
        chai.expect(inputElement).not.to.be.null;
        // prefix/suffix *is there* when there is a value and there is no focus.
        testPrefixIsThere(inputElement, queryAllByText(text).length);
    }));
    componentList.forEach((compObj) => it(`${compObj.name}: prefix is not there no value and no focus`, () => {
        const text = '+234';
        const { container, queryAllByText } = preact.render(jsxRuntime.jsx(compObj.component, { prefix: text, label: "no prefix" }));
        const inputElement = container.querySelector('input');
        chai.expect(inputElement).not.to.be.null;
        // prefix/suffix *is not there* when there is not a value and there is no focus.
        testPrefixIsNotThere(inputElement, queryAllByText(text).length);
    }));
    componentList.forEach((compObj) => it(`${compObj.name}: prefix is there no value and focus`, () => {
        const text = '+234';
        const { container, queryAllByText } = preact.render(jsxRuntime.jsx(compObj.component, { prefix: text, label: "with prefix" }));
        const inputElement = container.querySelector('input');
        chai.expect(inputElement).not.to.be.null;
        // copied from previous test that says: fireEvent.focus and userEvent.click does not seem to work here
        preact.act(() => {
            inputElement === null || inputElement === void 0 ? void 0 : inputElement.focus();
        });
        // prefix/suffix *is there* when there is focus
        testPrefixIsThere(inputElement, queryAllByText(text).length);
    }));
    componentList.forEach((compObj) => it(`${compObj.name}: prefix empty string is not there with value`, () => {
        const text = '';
        const { container } = preact.render(jsxRuntime.jsx(compObj.component, { prefix: text, value: "123412", label: "no prefix" }));
        const inputElement = container.querySelector('input');
        chai.expect(inputElement).not.to.be.null;
        // prefix/suffix *is not there* if it is ''.
        // test when there is a value and there is no focus since that is when it would normally be there.
        const element = inputElement === null || inputElement === void 0 ? void 0 : inputElement.previousElementSibling;
        chai.expect(element === null || element === void 0 ? void 0 : element.tagName.toUpperCase()).equal('LABEL');
    }));
    componentList.forEach((compObj) => it(`${compObj.name}: suffix is there with value`, () => {
        const text = 'lbs';
        const { container, queryAllByText } = preact.render(jsxRuntime.jsx(compObj.component, { suffix: text, value: "123412", label: "with suffix" }));
        const inputElement = container.querySelector('input');
        chai.expect(inputElement).not.to.be.null;
        // prefix/suffix *is there* when there is a value and there is no focus.
        testSuffixIsThere(inputElement, queryAllByText(text).length);
    }));
    componentList.forEach((compObj) => it(`${compObj.name}: suffix is not there no value and no focus`, () => {
        const text = 'lbs';
        const { container, queryAllByText } = preact.render(jsxRuntime.jsx(compObj.component, { suffix: text, label: "with suffix" }));
        const inputElement = container.querySelector('input');
        chai.expect(inputElement).not.to.be.null;
        // prefix/suffix *is not there* when there is not a value and there is no focus.
        testSuffixIsNotThere(inputElement, queryAllByText(text).length);
    }));
    componentList.forEach((compObj) => it(`${compObj.name}: suffix is there no value and focus`, () => {
        const text = 'lbs';
        const { container, queryAllByText } = preact.render(jsxRuntime.jsx(compObj.component, { suffix: text, label: "with suffix" }));
        const inputElement = container.querySelector('input');
        chai.expect(inputElement).not.to.be.null;
        // copied from previous test that says: fireEvent.focus and userEvent.click does not seem to work here
        preact.act(() => {
            inputElement === null || inputElement === void 0 ? void 0 : inputElement.focus();
        });
        // prefix/suffix *is there* when there is focus
        testSuffixIsThere(inputElement, queryAllByText(text).length);
    }));
    componentList.forEach((compObj) => it(`${compObj.name}: suffix empty string is not there with value`, () => {
        const text = '';
        const { container } = preact.render(jsxRuntime.jsx(compObj.component, { suffix: text, value: "lbs", label: "with suffix" }));
        const inputElement = container.querySelector('input');
        chai.expect(inputElement).not.to.be.null;
        // prefix/suffix *is not there* if it is ''.
        // test when there is a value and there is no focus since that is when a prefix/suffix
        // that isn't the empty string would be there.
        const element = inputElement === null || inputElement === void 0 ? void 0 : inputElement.nextElementSibling;
        chai.expect(element).to.be.null;
    }));
    componentList.forEach((compObj) => it(`${compObj.name}: disabled, prefix is not there no value`, () => {
        const text = '+234';
        const { container, queryAllByText } = preact.render(jsxRuntime.jsx(compObj.component, { prefix: text, isDisabled: true, label: "with suffix" }));
        const inputElement = container.querySelector('input');
        chai.expect(inputElement).not.to.be.null;
        // prefix/suffix *is not there* when there is not a value and there is no focus.
        testPrefixIsNotThere(inputElement, queryAllByText(text).length);
    }));
    componentList.forEach((compObj) => 
    // disabled has no suffix dom.
    it(`${compObj.name}: disabled with value (disabled is text-only)`, () => {
        const text = 'lbs';
        const { container, queryAllByText } = preact.render(jsxRuntime.jsx(compObj.component, { suffix: text, value: "123412", isDisabled: true, label: "with suffix" }));
        const inputElement = container.querySelector('input');
        chai.expect(inputElement).not.to.be.null;
        testSuffixIsNotThere(inputElement, queryAllByText(text).length);
        chai.expect(inputElement === null || inputElement === void 0 ? void 0 : inputElement.value).to.equal(`123412 lbs`);
    }));
    componentList.forEach((compObj) => it(`${compObj.name}: disabled, suffix is not there no value and no focus`, () => {
        const text = 'lbs';
        const { container, queryAllByText } = preact.render(jsxRuntime.jsx(compObj.component, { suffix: text, isDisabled: true, label: "with suffix" }));
        const inputElement = container.querySelector('input');
        chai.expect(inputElement).not.to.be.null;
        // prefix/suffix *is not there* when there is not a value and there is no focus.
        testSuffixIsNotThere(inputElement, queryAllByText(text).length);
    }));
    componentList.forEach((compObj) => it(`${compObj.name}: readonly suffix text`, () => {
        const text = 'lbs';
        const value = '123412';
        const expectedReadonlytext = `${value} ${text}`;
        const { container, queryByText } = preact.render(jsxRuntime.jsx(compObj.component, { suffix: text, value: value, isReadonly: true, label: "with suffix" }));
        const inputElement = container.querySelector('input');
        chai.expect(inputElement).to.be.null;
        // test style
        const foundReadonlyText = queryByText(expectedReadonlytext);
        chai.expect(foundReadonlyText).not.to.be.null;
    }));
    componentList.forEach((compObj) => it(`${compObj.name}: readonly prefix text`, () => {
        const text = '+234';
        const value = '123412';
        const expectedReadonlytext = `${text} ${value}`;
        const { container, queryByText } = preact.render(jsxRuntime.jsx(compObj.component, { prefix: text, value: value, isReadonly: true, label: "with prefix" }));
        const inputElement = container.querySelector('input');
        chai.expect(inputElement).to.be.null;
        // test style
        const foundReadonlyText = queryByText(expectedReadonlytext);
        chai.expect(foundReadonlyText).not.to.be.null;
    }));
    componentList.forEach((compObj) => it(`${compObj.name}: readonly prefix text no value`, () => {
        const text = '+234';
        const unexpectedReadonlytext = text;
        const { container, queryByText } = preact.render(jsxRuntime.jsx(compObj.component, { prefix: text, isReadonly: true, label: "with prefix" }));
        const inputElement = container.querySelector('input');
        chai.expect(inputElement).to.be.null;
        // shouldn't have any text. make sure we do not accidentally render prefix
        const foundReadonlyText = queryByText(unexpectedReadonlytext);
        chai.expect(foundReadonlyText).to.be.null;
    }));
    componentList.forEach((compObj) => it(`${compObj.name}: prefix aria-labelledby, no label`, () => {
        var _a;
        const text = '+234';
        const { container, queryByText } = preact.render(jsxRuntime.jsx(compObj.component, { prefix: text, value: "123412", labelEdge: "none", label: "with prefix" }));
        const inputElement = container.querySelector('input');
        // prefix/suffix *is there* when there is a value and there is no focus.
        // get the prefix dom and get the id from it.
        // test prefixId is there on expected dom
        const prefixDom = queryByText(text);
        chai.expect(prefixDom).not.to.be.null;
        const prefixId = (_a = prefixDom === null || prefixDom === void 0 ? void 0 : prefixDom.parentElement) === null || _a === void 0 ? void 0 : _a.id;
        chai.expect(prefixId === null || prefixId === void 0 ? void 0 : prefixId.endsWith('prefix'), `prefixId ends with 'prefix'`).to.be.true;
        // test input's aria-labelledby includes the prefixId
        const ariaLB = inputElement === null || inputElement === void 0 ? void 0 : inputElement.getAttribute('aria-labelledby');
        chai.expect(ariaLB).not.to.be.null;
        chai.expect(ariaLB === null || ariaLB === void 0 ? void 0 : ariaLB.includes(prefixId)).to.be.true;
        // should be the only one since there is no label.
        chai.expect(ariaLB).to.equal(prefixId);
    }));
    componentList.forEach((compObj) => it(`${compObj.name}: suffix aria-labelledby, no label`, () => {
        var _a;
        const text = 'lbs';
        const { container, queryByText } = preact.render(jsxRuntime.jsx(compObj.component, { suffix: text, value: "123412", labelEdge: "none", label: "with suffix" }));
        const inputElement = container.querySelector('input');
        // prefix/suffix *is there* when there is a value and there is no focus.
        const suffixDom = queryByText(text);
        chai.expect(suffixDom).not.to.be.null;
        const suffixId = (_a = suffixDom === null || suffixDom === void 0 ? void 0 : suffixDom.parentElement) === null || _a === void 0 ? void 0 : _a.id;
        chai.expect(suffixId === null || suffixId === void 0 ? void 0 : suffixId.endsWith('suffix'), `suffixId ends with 'suffix'`).to.be.true;
        const ariaLB = inputElement === null || inputElement === void 0 ? void 0 : inputElement.getAttribute('aria-labelledby');
        chai.expect(ariaLB).not.to.be.null;
        // get suffix dom. get id. get aria-labelledby off of input and see if suffix id is there.
        chai.expect(ariaLB === null || ariaLB === void 0 ? void 0 : ariaLB.includes(suffixId)).to.be.true;
    }));
    componentList.forEach((compObj) => it(`${compObj.name}: suffix aria-labelledby, has label`, () => {
        var _a;
        const text = 'lbs';
        const { container, queryByText } = preact.render(jsxRuntime.jsx(compObj.component, { suffix: text, value: "123412", label: "Weight" }));
        const inputElement = container.querySelector('input');
        const suffixDom = queryByText(text);
        // id is on the div, not the span around the text.
        const suffixId = (_a = suffixDom === null || suffixDom === void 0 ? void 0 : suffixDom.parentElement) === null || _a === void 0 ? void 0 : _a.id;
        const ariaLB = inputElement === null || inputElement === void 0 ? void 0 : inputElement.getAttribute('aria-labelledby');
        // get aria-labelledby off of input and see if suffix id is there, but not first.
        const suffixIndex = ariaLB.indexOf(suffixId);
        chai.expect(suffixIndex).to.not.equal(0);
        chai.expect(suffixIndex).to.not.equal(-1);
    }));
    componentList.forEach((compObj) => 
    // we render both labelId and suffixId in aria-labelledby on input so that the screenreader will read both.
    it(`${compObj.name}: suffix aria-labelledby, has labelid`, () => {
        const text = 'lbs';
        const { container, queryByText } = preact.render(jsxRuntime.jsx(compObj.component, { suffix: text, value: "123412", label: "Weight" }));
        const inputElement = container.querySelector('input');
        const labelDom = queryByText('Weight');
        chai.expect(labelDom === null || labelDom === void 0 ? void 0 : labelDom.tagName.toUpperCase()).equals('LABEL');
        const labelId = labelDom === null || labelDom === void 0 ? void 0 : labelDom.id;
        chai.expect(labelId).to.not.be.undefined;
        chai.expect(labelId).to.not.equal('');
        const ariaLB = inputElement === null || inputElement === void 0 ? void 0 : inputElement.getAttribute('aria-labelledby');
        // get suffix dom. get id. get aria-labelledby off of input and see if suffix id is there.
        // see if label id is there too.
        const labelIdIndex = ariaLB.indexOf(labelId);
        chai.expect(labelIdIndex).to.equal(0);
    }));
    componentList.forEach((compObj) => 
    // we do not render aria-labelledby on the input if there is no prefix or suffix.
    // even if there is a label. the label's for/id combox is enough in that case.
    it(`${compObj.name}: no prefix/suffix, no aria-labelledby, has label`, () => {
        const { container, queryByText } = preact.render(jsxRuntime.jsx(compObj.component, { value: "123412", label: "Weight" }));
        const inputElement = container.querySelector('input');
        const labelDom = queryByText('Weight');
        chai.expect(labelDom === null || labelDom === void 0 ? void 0 : labelDom.tagName.toUpperCase()).equals('LABEL');
        const labelId = labelDom === null || labelDom === void 0 ? void 0 : labelDom.id;
        chai.expect(labelId).to.not.be.undefined;
        chai.expect(labelId).to.not.equal('');
        const ariaLB = inputElement === null || inputElement === void 0 ? void 0 : inputElement.getAttribute('aria-labelledby');
        chai.expect(ariaLB).to.be.null;
    }));
    componentList.forEach((compObj) => 
    // we do not render aria-labelledby on the input if there is no prefix or suffix.
    // even if there is a label. the label's for/id combox is enough in that case.
    it(`${compObj.name}: prefix and suffix, aria-labelledby, no label`, () => {
        var _a, _b;
        const { container, queryByText } = preact.render(jsxRuntime.jsx(compObj.component, { prefix: "+++", suffix: "lbs", value: "123412", labelEdge: "none", label: "with prefix suffix" }));
        const inputElement = container.querySelector('input');
        const suffixDom = queryByText('lbs');
        // id is on the div, not the span around the text.
        const suffixId = (_a = suffixDom === null || suffixDom === void 0 ? void 0 : suffixDom.parentElement) === null || _a === void 0 ? void 0 : _a.id;
        const prefixDom = queryByText('+++');
        // id is on the div, not the span around the text.
        const prefixId = (_b = prefixDom === null || prefixDom === void 0 ? void 0 : prefixDom.parentElement) === null || _b === void 0 ? void 0 : _b.id;
        // get aria-labelledby off of input and see if prefix id is there and suffix id is there,
        // and that there are only two.
        const ariaLB = inputElement === null || inputElement === void 0 ? void 0 : inputElement.getAttribute('aria-labelledby');
        const hasSuffixId = ariaLB.includes(suffixId);
        chai.expect(hasSuffixId).to.be.true;
        const hasPrefixId = ariaLB.includes(prefixId);
        chai.expect(hasPrefixId).to.be.true;
        // splice the string and make sure there are only two.
        const numIds = ariaLB === null || ariaLB === void 0 ? void 0 : ariaLB.trim().split(/\s+/).length;
        chai.expect(numIds).to.equal(2);
    }));
    afterEach(preact.cleanup);
});
// skip the color tests in jest, only run it in karma mocha
if (typeof jest === 'undefined') {
    describe('Form Controls - Prefix/Suffix Color', () => {
        componentList.forEach((compObj) => it(`${compObj.name}: prefix color is same as input text`, () => {
            const text = '+234';
            const { container, queryByText } = preact.render(jsxRuntime.jsx(compObj.component, { prefix: text, value: "123412", label: "with prefix" }));
            const inputElement = container.querySelector('input');
            // test style
            const textColor = window
                .getComputedStyle(queryByText(text))
                .getPropertyValue('color');
            const inputColor = window
                .getComputedStyle(inputElement)
                .getPropertyValue('color');
            chai.expect(textColor).equals(inputColor);
        }));
        componentList.forEach((compObj) => it(`${compObj.name}: suffix color is same as input text`, () => {
            const text = 'lbs';
            const { container, queryByText } = preact.render(jsxRuntime.jsx(compObj.component, { suffix: text, value: "123412", label: "with suffix" }));
            const inputElement = container.querySelector('input');
            // test style
            const textColor = window
                .getComputedStyle(queryByText(text))
                .getPropertyValue('color');
            const inputColor = window
                .getComputedStyle(inputElement)
                .getPropertyValue('color');
            chai.expect(textColor).equals(inputColor);
        }));
        componentList.forEach((compObj) => it(`${compObj.name}: prefix color is not the same as input text when focused`, () => {
            const text = '+234';
            const { container, queryByText } = preact.render(jsxRuntime.jsx(compObj.component, { prefix: text, value: "123412", label: "with prefix" }));
            const inputElement = container.querySelector('input');
            preact.act(() => {
                inputElement === null || inputElement === void 0 ? void 0 : inputElement.focus();
            });
            // test style
            const textColor = window
                .getComputedStyle(queryByText(text))
                .getPropertyValue('color');
            const inputColor = window
                .getComputedStyle(inputElement)
                .getPropertyValue('color');
            chai.expect(textColor).equals(inputColor);
        }));
        componentList.forEach((compObj) => it(`${compObj.name}: suffix color is not the same as input text when focused`, () => {
            const text = 'lbs';
            const { container, queryByText } = preact.render(jsxRuntime.jsx(compObj.component, { suffix: text, value: "123412", label: "with suffix" }));
            const inputElement = container.querySelector('input');
            preact.act(() => {
                inputElement === null || inputElement === void 0 ? void 0 : inputElement.focus();
            });
            // test style
            const textColor = window
                .getComputedStyle(queryByText(text))
                .getPropertyValue('color');
            const inputColor = window
                .getComputedStyle(inputElement)
                .getPropertyValue('color');
            chai.expect(textColor).equals(inputColor);
        }));
        afterEach(preact.cleanup);
    });
}
/*  */
//# sourceMappingURL=FormControlPrefixSuffix.spec.js.map
