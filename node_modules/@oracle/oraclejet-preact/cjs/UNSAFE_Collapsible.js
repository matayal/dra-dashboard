/* @oracle/oraclejet-preact: 14.1.0 */
'use strict';

Object.defineProperty(exports, '__esModule', { value: true });

var jsxRuntime = require('preact/jsx-runtime');
var hooks = require('preact/hooks');
var hooks_UNSAFE_useId = require('./hooks/UNSAFE_useId.js');
var preact = require('preact');
require("identity-obj-proxy");
require('./utils/UNSAFE_classNames.js');
require('./UNSAFE_Flex.js');
require('./UNSAFE_Divider.js');
var UNSAFE_ThemedIcons = require('./index-3651c0e7.js');
var UNSAFE_Icons = require('./index-d5067e50.js');
var hooks_UNSAFE_usePress = require('./hooks/UNSAFE_usePress.js');
var classNames = require('./classNames-55bceee6.js');
var Flex = require('./Flex-b113edd5.js');
var Divider = require('./Divider-333e69aa.js');
require('./hooks/UNSAFE_useAnimation.js');
var useAnimation = require('./useAnimation-576ef8bc.js');
require('./tslib.es6-6f60dd09.js');
require('./utils/UNSAFE_interpolations/dimensions.js');
require('./utils/UNSAFE_arrayUtils.js');
require('./utils/UNSAFE_size.js');
require('./_curry1-f1ebd742.js');
require('./utils/UNSAFE_mergeInterpolations.js');
require('./_curry3-bc6e6a86.js');
require('./_curry2-588f7ddc.js');
require('./_has-2eedb7e0.js');
require('./utils/UNSAFE_interpolations/boxalignment.js');
require('./keys-326d80d5.js');
require('./utils/UNSAFE_interpolations/flexbox.js');
require('./flexbox-6deddb70.js');
require('./utils/UNSAFE_interpolations/flexitem.js');
require('./flexitem-0c1e9a72.js');
require('./UNSAFE_Icon.js');
require('./Icon-c44e10c9.js');
require('./hooks/UNSAFE_useTooltip.js');
require('./UNSAFE_Floating.js');
require('./Floating-48167355.js');
require('preact/compat');
require('./index-55dfe40c.js');
require('./hooks/UNSAFE_useUser.js');
require('./UNSAFE_Environment.js');
require('./UNSAFE_Layer.js');
require('./utils/PRIVATE_floatingUtils.js');
require('./utils/PRIVATE_refUtils.js');
require('./hooks/UNSAFE_useOutsideClick.js');
require('./hooks/UNSAFE_useHover.js');
require('./hooks/UNSAFE_useToggle.js');
require('./hooks/UNSAFE_useFocus.js');
require('./hooks/UNSAFE_useTouch.js');
require('./utils/UNSAFE_mergeProps.js');
require('./hooks/UNSAFE_useTheme.js');

/**
 * Header icon subcomponent
 */
const CollapsibleHeaderIcon = ({ isExpanded, iconPosition }) => {
    const startIcon = iconPosition === 'start' && isExpanded ? UNSAFE_Icons.SvgIcoChevronDown : UNSAFE_ThemedIcons.CollapseIcon;
    const endIcon = iconPosition === 'end' && isExpanded ? UNSAFE_Icons.SvgIcoChevronUp : UNSAFE_Icons.SvgIcoChevronDown;
    const Icon = iconPosition === 'start' ? startIcon : endIcon;
    return jsxRuntime.jsx(Icon, { size: "6x" });
};

const styles$1 = {
  base: "_2jyr9e",
  expanded: "_1ml1kiv",
  disabled: "_1c0td7o",
  divider: "_9a6uct"
};
const childrenStylesBase = {
  base: "_1yoqog3",
  iconStart: "_5obyd7",
  iconEnd: "_1w1udn6"
};
/**
 * Header subcomponent
 */

const CollapsibleHeader = ({
  children,
  id,
  contentId,
  isDisabled,
  isExpanded,
  iconPosition,
  variant = 'basic',
  toggleHandler
}) => {
  const classes = classNames.classNames([styles$1.base, variant === 'horizontal-rule' && styles$1.divider, isExpanded && variant !== 'horizontal-rule' && styles$1.expanded, isDisabled && styles$1.disabled]);
  const childrenClasses = classNames.classNames([childrenStylesBase.base, iconPosition === 'end' && childrenStylesBase.iconEnd, iconPosition === 'start' && childrenStylesBase.iconStart]);
  const pressHandler = hooks.useCallback(event => {
    toggleHandler(event.target);
  }, [toggleHandler]);
  const {
    pressProps
  } = hooks_UNSAFE_usePress.usePress(pressHandler, {
    isDisabled,
    isRepeat: false
  });

  const getHeader = () => jsxRuntime.jsxs(preact.Fragment, {
    children: [iconPosition === 'end' && jsxRuntime.jsx("div", Object.assign({
      className: childrenClasses
    }, {
      children: children
    })), jsxRuntime.jsx(CollapsibleHeaderIcon, {
      iconPosition: iconPosition,
      isExpanded: isExpanded
    }), iconPosition === 'start' && jsxRuntime.jsx("div", Object.assign({
      className: childrenClasses
    }, {
      children: children
    }))]
  });

  return jsxRuntime.jsxs(jsxRuntime.Fragment, {
    children: [jsxRuntime.jsx("div", Object.assign({
      role: 'button',
      "aria-controls": contentId,
      "aria-expanded": isExpanded,
      id: id,
      tabIndex: 0,
      className: classes
    }, pressProps, {
      children: jsxRuntime.jsx(Flex.Flex, Object.assign({
        align: "center",
        justify: iconPosition === 'start' ? 'start' : 'between'
      }, {
        children: getHeader()
      }))
    })), variant === 'horizontal-rule' && jsxRuntime.jsx(Divider.Divider, {})]
  });
};

const styles = "_1ri29hl";
const CollapsibleContent = ({
  children,
  id,
  isExpanded,
  onTransitionEnd
}) => {
  const [state, setState] = hooks.useState(isExpanded ? 'expanding' : 'unmounted');
  /**
   * 1. On initial render, Preact sets style.maxHeight field to 0 or 'none'.
   * 2. During expanding animation, useAnimation hook uses WAAPI to animate the maxHeight out
   *    to the expanded value.
   * 3. On subsequent re-renders, Preact does never updates the style.maxHeight value
   *    because even though we are telling Preact that maxHeight should be 0 or 'none', Preact
   *    considers the maxHeight value is 0 or 'none' as it is not aware that we changed this value
   *    in step 2. So from Preact's perspective there is no difference.
   */

  const contentInitialStyle = hooks.useRef({
    overflowY: 'hidden',
    maxHeight: isExpanded ? 'none' : '0'
  });
  hooks.useEffect(() => {
    // Ignore state update on initial render
    if (state === 'unmounted' && !isExpanded) {
      return;
    }

    setState(isExpanded ? 'expanding' : 'collapsing');
  }, [isExpanded, state]);
  const {
    nodeRef
  } = useAnimation.useAnimation(state, {
    animationStates,
    onAnimationEnd: ({
      animationState
    }) => {
      if (animationState === 'collapsing') {
        setState('unmounted');
      }

      onTransitionEnd === null || onTransitionEnd === void 0 ? void 0 : onTransitionEnd();
    }
  });
  return jsxRuntime.jsx("div", Object.assign({
    className: styles,
    ref: nodeRef,
    id: id,
    tabIndex: -1,
    style: contentInitialStyle.current,
    "aria-hidden": !isExpanded || undefined
  }, {
    children: state !== 'unmounted' && children
  }));
};
/**
 * The transition from collapsed to expanded works as follows:
 * 1. When the component is initially rendered in the collapsed state, we
 *    explicitly set maxHeight and overflowY from "to" configuration.
 * 2. When the expanded prop changes from false to true, we first mount the content children.
 * 3. Once this is mounted we trigger an animation updating animationState value of useAnimationHook.
 * 4. Configuration is represented inside hook. Passed config depends if previous animation was completed or not.
 *    We could check that based on node.style.maxHeight.
 *
 * The transition from expanded to collapsed is similar:
 * 1. We trigger an animation updating animationState value of useAnimationHook.
 * 2. Once animation is completed, with the help of end config,we set max-Height as 'none'.
 *    This will allow us to keep adding content.
 * 3. Once this is done, onAnimationEnd is called(as 'from collapsed to expanded"). Here, content children are unmouunted.
 */

const animationStates = {
  expanding: node => ({
    to: {
      maxHeight: `${node.scrollHeight}px`
    },
    options: {
      duration: 400
    },
    end: {
      maxHeight: 'none'
    }
  }),
  collapsing: node => Object.assign(Object.assign({}, node.style.maxHeight === 'none' && {
    from: {
      maxHeight: `${node.scrollHeight}px`
    }
  }), {
    to: {
      maxHeight: '0'
    },
    options: {
      duration: 400
    }
  })
};

/**
 * A collapsible displays a header that can be expanded to show its content.
 */
const Collapsible = ({ id, header, children, isDisabled = false, isExpanded = false, iconPosition = 'start', variant = 'basic', onToggle, onTransitionEnd }) => {
    const rootRef = hooks.useRef(null);
    const uniqueID = hooks_UNSAFE_useId.useId();
    const headerId = `oj-collapsible-header-${uniqueID}`;
    const contentId = `oj-collapsible-content-${uniqueID}`;
    /**
     * Function handling toggle and invoking callback for collapsing/expanding
     */
    const toggleHandler = hooks.useCallback((target) => {
        if (isDisabled) {
            return;
        }
        onToggle === null || onToggle === void 0 ? void 0 : onToggle({
            value: !isExpanded,
            target
        });
    }, [isDisabled, onToggle, isExpanded]);
    /**
     * Function that is triggerd when animation ends
     */
    const transitionEndHandler = hooks.useCallback(() => {
        onTransitionEnd === null || onTransitionEnd === void 0 ? void 0 : onTransitionEnd({
            value: isExpanded
        });
    }, [onTransitionEnd, isExpanded]);
    return (jsxRuntime.jsxs("div", Object.assign({ id: id, ref: rootRef }, { children: [jsxRuntime.jsx(CollapsibleHeader, Object.assign({ id: headerId, contentId: contentId, toggleHandler: toggleHandler, isDisabled: isDisabled, isExpanded: isExpanded, iconPosition: iconPosition, variant: variant }, { children: header })), jsxRuntime.jsx(CollapsibleContent, Object.assign({ id: contentId, isExpanded: isExpanded, onTransitionEnd: transitionEndHandler }, { children: children }))] })));
};

/**
 * @license
 * Copyright (c) %FIRST_YEAR% %CURRENT_YEAR%, Oracle and/or its affiliates.
 * The Universal Permissive License (UPL), Version 1.0
 * as shown at https://oss.oracle.com/licenses/upl/
 * @ignore
 */

exports.Collapsible = Collapsible;
/*  */
//# sourceMappingURL=UNSAFE_Collapsible.js.map
