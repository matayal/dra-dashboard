/* @oracle/oraclejet-preact: 14.1.0 */
'use strict';

var jsxRuntime = require('preact/jsx-runtime');
var preact = require('preact');
var hooks = require('preact/hooks');
var preact$1 = require('@testing-library/preact');
var chai = require('chai');
var UNSAFE_Layer = require('../../UNSAFE_Layer.js');
var Modal = require('../../Modal-40a059dc.js');
require('preact/compat');
require('../../useModal-0b4e4a2d.js');
require('../../UNSAFE_FocusTrap.js');
require('../../FocusTrap-8af50913.js');
require('../../utils/UNSAFE_classNames.js');
require('../../classNames-55bceee6.js');
require("identity-obj-proxy");
require('../../utils/PRIVATE_tabbableUtils.js');
require('../../_curry1-f1ebd742.js');
require('../../_curry2-588f7ddc.js');
require('../../_curry3-bc6e6a86.js');

const TestDialog = ({ submitButtonRef }) => (jsxRuntime.jsxs(preact.Fragment, { children: [jsxRuntime.jsx("input", { id: "inside_input" }), jsxRuntime.jsx("button", Object.assign({ id: "inside_cancel" }, { children: "Cancel" })), jsxRuntime.jsx("button", Object.assign({ id: "inside_submit", ref: submitButtonRef }, { children: "Submit" }))] }));
const TestComponent = ({ autoFocusTest = false, isOpen = true, restoreFocusTest = false }) => {
    const submitButtonRef = hooks.useRef(null);
    const followButtonRef = hooks.useRef(null);
    let maybeAutoFocusRef = undefined;
    if (autoFocusTest)
        maybeAutoFocusRef = submitButtonRef;
    let maybeRestoreFocusRef = undefined;
    if (restoreFocusTest)
        maybeRestoreFocusRef = followButtonRef;
    return (jsxRuntime.jsxs(UNSAFE_Layer.LayerManager, { children: [jsxRuntime.jsx("button", { children: "Preceding Button" }), jsxRuntime.jsx(Modal.Modal, Object.assign({ autoFocusRef: maybeAutoFocusRef, isOpen: isOpen, restoreFocusRef: maybeRestoreFocusRef }, { children: jsxRuntime.jsx(TestDialog, { submitButtonRef: submitButtonRef }) })), jsxRuntime.jsx("button", Object.assign({ ref: followButtonRef }, { children: "Following Button" }))] }));
};
describe('Test Modal component', () => {
    beforeEach(() => {
        // need this as focus trap expects it to be set, it is used to determine if the tab stop is visible
        Object.defineProperty(HTMLElement.prototype, 'offsetParent', {
            get() {
                return this.parentNode;
            }
        });
    });
    it('renders and sets default focus on first tabbable item', async () => {
        const { getByRole } = preact$1.render(jsxRuntime.jsx(TestComponent, {}));
        const insideInput = getByRole('textbox');
        await preact$1.waitFor(() => {
            chai.expect(document.activeElement).equals(insideInput);
        });
    });
    it('renders and sets initial focus to specified element', async () => {
        const { getByText } = preact$1.render(jsxRuntime.jsx(TestComponent, { autoFocusTest: true }));
        const autofocusButton = getByText('Submit');
        await preact$1.waitFor(() => {
            chai.expect(document.activeElement).equals(autofocusButton);
        });
    });
    it('unmounts and resets focus to original element', async () => {
        const { getByRole, getByText, rerender } = preact$1.render(jsxRuntime.jsx(TestComponent, { isOpen: false }));
        const precedingButton = getByText('Preceding Button');
        // set original focus to button outside focus trap
        precedingButton.focus();
        chai.expect(document.activeElement).equals(precedingButton);
        rerender(jsxRuntime.jsx(TestComponent, { isOpen: true }));
        const insideInput = getByRole('textbox');
        chai.expect(document.activeElement).equals(insideInput);
        rerender(jsxRuntime.jsx(TestComponent, { isOpen: false }));
        await preact$1.waitFor(() => {
            chai.expect(document.activeElement).equals(precedingButton);
        });
    });
    it('unmounts and resets focus to specified element', async () => {
        const { getByRole, getByText, rerender } = preact$1.render(jsxRuntime.jsx(TestComponent, { isOpen: false }));
        const precedingButton = getByText('Preceding Button');
        const followingButton = getByText('Following Button');
        // set original focus to button outside focus trap
        precedingButton.focus();
        chai.expect(document.activeElement).equals(precedingButton);
        rerender(jsxRuntime.jsx(TestComponent, { isOpen: true, restoreFocusTest: true }));
        const insideInput = getByRole('textbox');
        chai.expect(document.activeElement).equals(insideInput);
        rerender(jsxRuntime.jsx(TestComponent, { isOpen: false }));
        await preact$1.waitFor(() => {
            chai.expect(document.activeElement).equals(followingButton);
        });
    });
});
/*  */
//# sourceMappingURL=Modal.spec.js.map
