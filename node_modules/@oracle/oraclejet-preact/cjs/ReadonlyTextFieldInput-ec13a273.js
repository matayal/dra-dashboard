/* @oracle/oraclejet-preact: 14.1.0 */
'use strict';

var tslib_es6 = require('./tslib.es6-6f60dd09.js');
var jsxRuntime = require('preact/jsx-runtime');
var hooks_UNSAFE_useFormContext = require('./hooks/UNSAFE_useFormContext.js');
var hooks_UNSAFE_useTabbableMode = require('./hooks/UNSAFE_useTabbableMode.js');

require('./utils/UNSAFE_classNames.js');
var utils_UNSAFE_interpolations_text = require('./utils/UNSAFE_interpolations/text.js');
var utils_UNSAFE_mergeInterpolations = require('./utils/UNSAFE_mergeInterpolations.js');
var hooks_UNSAFE_useFormFieldContext = require('./hooks/UNSAFE_useFormFieldContext.js');
var FormControlUtils = require('./FormControlUtils-c960c51d.js');
var classNames = require('./classNames-55bceee6.js');

// and the textarea, so the the textarea's focus outline doesn't get truncated.
// The 0.25rem is an aesthetically pleasing amount of margin to make the readonly
// focus ring visible.

const borderToTextAreaContentMargin = '0.25rem';
const readOnlyTextFieldStyles = {
  base: "vblukg",
  textareaBase: "fdlpr5",
  inEnabledFormBase: "_15ub5u3",
  textareaInEnabledFormBase: "ih0sj9",
  inEnabledFormLabelInside: "_1hta94e",
  textareaInEnabledFormLabelInside: "_20ve4c",
  inEnabledFormNoLabelInside: "_1wo2vfg",
  // don't apply this for textarea
  inEnabledFormNoStartContent: "_10ocs2m"
};
function ReadonlyTextFieldInput(_a) {
  var {
    ariaDescribedBy,
    ariaLabel,
    ariaLabelledBy,
    autoFocus,
    as = 'div',
    elementRef,
    hasInsideLabel = false,
    inlineUserAssistance,
    innerReadonlyField,
    rows,
    type,
    value = '',
    variant
  } = _a,
      props = tslib_es6.__rest(_a, ["ariaDescribedBy", "ariaLabel", "ariaLabelledBy", "autoFocus", "as", "elementRef", "hasInsideLabel", "inlineUserAssistance", "innerReadonlyField", "rows", "type", "value", "variant"]);

  const {
    isFormLayout,
    isReadonly: isReadonlyForm
  } = hooks_UNSAFE_useFormContext.useFormContext();
  const {
    isLoading
  } = hooks_UNSAFE_useFormFieldContext.useFormFieldContext();
  const ariaLabelForReadonly = isLoading ? FormControlUtils.getLoadingAriaLabel() : ariaLabel; // get classes for text align

  const interpolations = [...Object.values(utils_UNSAFE_interpolations_text.textInterpolations)];
  const styleInterpolations = utils_UNSAFE_mergeInterpolations.mergeInterpolations(interpolations);
  const {
    class: styleInterpolationClasses
  } = styleInterpolations(props);
  const readonlyDivClasses = classNames.classNames([as !== 'textarea' && 'oj-c-hide-scrollbar', readOnlyTextFieldStyles.base, as === 'textarea' && readOnlyTextFieldStyles.textareaBase, isFormLayout && !isReadonlyForm && readOnlyTextFieldStyles.inEnabledFormBase, variant === 'textarea' && isFormLayout && !isReadonlyForm && readOnlyTextFieldStyles.textareaInEnabledFormBase, isFormLayout && !isReadonlyForm && (hasInsideLabel ? readOnlyTextFieldStyles.inEnabledFormLabelInside : readOnlyTextFieldStyles.inEnabledFormNoLabelInside), variant === 'textarea' && isFormLayout && !isReadonlyForm && hasInsideLabel && readOnlyTextFieldStyles.textareaInEnabledFormLabelInside, variant !== 'textarea' && // not for textarea
  isFormLayout && !isReadonlyForm && readOnlyTextFieldStyles.inEnabledFormNoStartContent, styleInterpolationClasses]); // JET-52914 - Implement Tabbable mode API contract in InputText
  // spread tabbableModeProps on component

  const {
    isTabbable,
    tabbableModeProps
  } = hooks_UNSAFE_useTabbableMode.useTabbableMode();

  if (as === 'input') {
    return jsxRuntime.jsx("input", Object.assign({
      "aria-describedby": ariaDescribedBy,
      "aria-label": ariaLabelForReadonly,
      "aria-labelledby": ariaLabelledBy,
      autofocus: autoFocus,
      class: readonlyDivClasses,
      readonly: true,
      // @ts-ignore
      ref: elementRef,
      type: type,
      value: value
    }, !isTabbable && tabbableModeProps));
  }

  if (as === 'textarea') {
    return jsxRuntime.jsx("textarea", Object.assign({
      "aria-describedby": ariaDescribedBy,
      "aria-label": ariaLabelForReadonly,
      "aria-labelledby": ariaLabelledBy,
      autofocus: autoFocus,
      class: readonlyDivClasses,
      readonly: true,
      // @ts-ignore
      ref: elementRef,
      rows: rows
    }, !isTabbable && tabbableModeProps, {
      children: value
    }));
  }

  return jsxRuntime.jsx("div", Object.assign({
    "aria-describedby": ariaDescribedBy,
    "aria-label": ariaLabelForReadonly,
    "aria-labelledby": ariaLabelledBy,
    "aria-readonly": true,
    autofocus: autoFocus,
    class: readonlyDivClasses,
    // @ts-ignore
    ref: elementRef,
    role: "textbox"
  }, tabbableModeProps, {
    children: value
  }));
}

exports.ReadonlyTextFieldInput = ReadonlyTextFieldInput;
/*  */
//# sourceMappingURL=ReadonlyTextFieldInput-ec13a273.js.map
