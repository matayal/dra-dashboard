/* @oracle/oraclejet-preact: 14.1.0 */
'use strict';

var jsxRuntime = require('preact/jsx-runtime');
var hooks = require('preact/hooks');
require('./PRIVATE_Collection.js');
var hooks_UNSAFE_useViewportIntersect = require('./hooks/UNSAFE_useViewportIntersect.js');
var Collection = require('./Collection-2647e7ee.js');

const isDataStateValid = (dataState) => {
    return dataState && dataState.data && dataState.offset >= 0 && dataState.totalSize >= 0;
};
const DEFAULT_MARGIN = 1;
const DEFAULT_FETCH_SIZE = 25;
const LOADMORE_STYLE_CLASS = 'oj-collection-loadmore';
const LOAD_MORE_SELECTOR = `.${LOADMORE_STYLE_CLASS}`;
/**
 * Component that only render items in the specified viewport.
 * @param props
 */
function LoadMoreCollection({ data, children, viewportConfig, onLoadRange, loadMoreIndicator, suggestions }) {
    const rootRef = hooks.useRef(null);
    const fetchSizeRef = hooks.useRef(-1);
    // detect if viewport has changed and it needs to re-render based on a new range
    hooks_UNSAFE_useViewportIntersect.useViewportIntersect(viewportConfig, DEFAULT_MARGIN, LOAD_MORE_SELECTOR, () => {
        if (data) {
            if (fetchSizeRef.current == null || fetchSizeRef.current <= 0) {
                fetchSizeRef.current = data.totalSize;
            }
            const fetchSize = fetchSizeRef.current && fetchSizeRef.current > 0
                ? fetchSizeRef.current
                : DEFAULT_FETCH_SIZE;
            onLoadRange({
                offset: 0,
                count: data.totalSize + fetchSize
            });
        }
    });
    // override itemRenderer to adjust the index
    const _getItemRenderer = (startIndex) => {
        // returns a new render function
        return (context) => {
            const itemContext = {
                index: startIndex + context.index,
                data: context.data
            };
            return children(itemContext);
        };
    };
    // if DataState is invalid (including not specified), just render blank
    if (!data || !isDataStateValid(data)) {
        return jsxRuntime.jsx("div", { ref: rootRef });
    }
    const dataState = data;
    const rangeData = dataState.data;
    const offset = dataState.offset;
    const endIndex = offset + rangeData.length;
    const itemCount = dataState.totalSize;
    const renderLoadMore = loadMoreIndicator && dataState.sizePrecision === 'atLeast' && endIndex <= itemCount;
    // might need to support elementType prop in the future to allow customization of what
    // type of element to render for the root
    return (jsxRuntime.jsxs("div", Object.assign({ ref: rootRef }, { children: [suggestions, jsxRuntime.jsx(Collection.Collection, Object.assign({ items: rangeData }, { children: _getItemRenderer(offset) })), renderLoadMore && jsxRuntime.jsx("div", Object.assign({ class: LOADMORE_STYLE_CLASS }, { children: loadMoreIndicator }))] })));
}

exports.LoadMoreCollection = LoadMoreCollection;
/*  */
//# sourceMappingURL=LoadMoreCollection-eaa4ed6f.js.map
