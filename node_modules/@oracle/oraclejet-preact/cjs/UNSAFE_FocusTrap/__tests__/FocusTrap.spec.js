/* @oracle/oraclejet-preact: 14.1.0 */
'use strict';

var jsxRuntime = require('preact/jsx-runtime');
var preact = require('preact');
var hooks = require('preact/hooks');
var preact$1 = require('@testing-library/preact');
var userEvent = require('@testing-library/user-event');
var chai = require('chai');
var FocusTrap = require('../../FocusTrap-8af50913.js');
require('preact/compat');
require('../../utils/UNSAFE_classNames.js');
require('../../classNames-55bceee6.js');
require("identity-obj-proxy");
require('../../utils/PRIVATE_tabbableUtils.js');
require('../../_curry1-f1ebd742.js');
require('../../_curry2-588f7ddc.js');
require('../../_curry3-bc6e6a86.js');

function _interopDefaultLegacy (e) { return e && typeof e === 'object' && 'default' in e ? e : { 'default': e }; }

var userEvent__default = /*#__PURE__*/_interopDefaultLegacy(userEvent);

const TestDialog = ({ submitButtonRef }) => (jsxRuntime.jsxs(preact.Fragment, { children: [jsxRuntime.jsx("input", { id: "inside_input" }), jsxRuntime.jsx("button", Object.assign({ id: "inside_cancel" }, { children: "Cancel" })), jsxRuntime.jsx("button", Object.assign({ id: "inside_submit", ref: submitButtonRef }, { children: "Submit" }))] }));
const TestComponent = ({ autoFocusTest = false, isDisabled = false, restoreFocusTest }) => {
    const submitButtonRef = hooks.useRef(null);
    const followButtonRef = hooks.useRef(null);
    let maybeAutoFocusRef = undefined;
    if (autoFocusTest)
        maybeAutoFocusRef = submitButtonRef;
    let maybeRestoreFocusRef = undefined;
    if (restoreFocusTest === true)
        maybeRestoreFocusRef = followButtonRef;
    if (restoreFocusTest === false)
        maybeRestoreFocusRef = false;
    return (jsxRuntime.jsxs(preact.Fragment, { children: [jsxRuntime.jsx("button", { children: "Preceding Button" }), isDisabled ? (jsxRuntime.jsx(TestDialog, { submitButtonRef: submitButtonRef })) : (jsxRuntime.jsx(FocusTrap.FocusTrap, Object.assign({ autoFocusRef: maybeAutoFocusRef, restoreFocusRef: maybeRestoreFocusRef }, { children: jsxRuntime.jsx(TestDialog, { submitButtonRef: submitButtonRef }) }))), jsxRuntime.jsx("button", Object.assign({ ref: followButtonRef }, { children: "Following Button" }))] }));
};
/**
 * Asserting on document.activeElement is bit tricky and varies between jest (JSDOM) and karma-mocha
 * @param HTMLElement
 */
const expectActiveElementToBe = async (element) => {
    if (typeof jest !== typeof undefined) {
        // For jest (JSDOM) tests we need to explicitly wait one tick
        setTimeout(() => {
            chai.expect(document.activeElement).equals(element);
        }, 0);
    }
    else {
        // for karma-mocha, sometimes, we need an await.
        await preact$1.waitFor(() => {
            chai.expect(document.activeElement).equals(element);
        });
    }
};
describe('Test FocusTrap component', () => {
    beforeEach(() => {
        // need this as focus trap expects it to be set, it is used to determine if the tab stop is visible
        Object.defineProperty(HTMLElement.prototype, 'offsetParent', {
            get() {
                return this.parentNode;
            }
        });
    });
    it('renders and sets default focus on first tabbable item', function () {
        const { getByRole } = preact$1.render(jsxRuntime.jsx(TestComponent, {}));
        const insideInput = getByRole('textbox');
        chai.expect(document.activeElement).equals(insideInput);
    });
    it('renders and sets initial focus to specified element', function () {
        const { getByText } = preact$1.render(jsxRuntime.jsx(TestComponent, { autoFocusTest: true }));
        const autofocusButton = getByText('Submit');
        chai.expect(document.activeElement).equals(autofocusButton);
    });
    it('constrains tab behavior', async () => {
        const { getByRole, getByText } = preact$1.render(jsxRuntime.jsx(TestComponent, {}));
        const cancelButton = getByText('Cancel');
        const submitButton = getByText('Submit');
        const insideInput = getByRole('textbox');
        userEvent__default["default"].tab();
        await expectActiveElementToBe(cancelButton);
        userEvent__default["default"].tab();
        await expectActiveElementToBe(submitButton);
        userEvent__default["default"].tab();
        // wrap around forward
        await expectActiveElementToBe(insideInput);
        userEvent__default["default"].tab();
        await expectActiveElementToBe(cancelButton);
        // wrap around backwards
        userEvent__default["default"].tab({ shift: true });
        await expectActiveElementToBe(insideInput);
        userEvent__default["default"].tab({ shift: true });
        await expectActiveElementToBe(submitButton);
    });
    it('unmounts and resets focus to original element', async () => {
        const { getByRole, getByText, rerender } = preact$1.render(jsxRuntime.jsx(TestComponent, { isDisabled: true }));
        const precedingButton = getByText('Preceding Button');
        // set original focus to button outside focus trap
        precedingButton.focus();
        await expectActiveElementToBe(precedingButton);
        rerender(jsxRuntime.jsx(TestComponent, { isDisabled: false }));
        const insideInput = getByRole('textbox');
        await expectActiveElementToBe(insideInput);
        rerender(jsxRuntime.jsx(TestComponent, { isDisabled: true }));
        await expectActiveElementToBe(precedingButton);
    });
    it('unmounts and resets focus to specified element', async () => {
        const { getByRole, getByText, rerender } = preact$1.render(jsxRuntime.jsx(TestComponent, { isDisabled: true, restoreFocusTest: true }));
        const precedingButton = getByText('Preceding Button');
        const followingButton = getByText('Following Button');
        // set original focus to button outside focus trap
        precedingButton.focus();
        await expectActiveElementToBe(precedingButton);
        rerender(jsxRuntime.jsx(TestComponent, { isDisabled: false, restoreFocusTest: true }));
        const insideInput = getByRole('textbox');
        await expectActiveElementToBe(insideInput);
        rerender(jsxRuntime.jsx(TestComponent, { isDisabled: true, restoreFocusTest: true }));
        await expectActiveElementToBe(followingButton);
    });
    it('unmounts and does no focus restore behavior when toggled off', async () => {
        const { getByRole, getByText, rerender } = preact$1.render(jsxRuntime.jsx(TestComponent, { isDisabled: true, restoreFocusTest: false }));
        const defaultActiveElement = document.activeElement;
        const precedingButton = getByText('Preceding Button');
        // set original focus to button outside focus trap
        precedingButton.focus();
        await expectActiveElementToBe(precedingButton);
        rerender(jsxRuntime.jsx(TestComponent, { isDisabled: false, restoreFocusTest: false }));
        const insideInput = getByRole('textbox');
        await expectActiveElementToBe(insideInput);
        rerender(jsxRuntime.jsx(TestComponent, { isDisabled: true, restoreFocusTest: false }));
        await expectActiveElementToBe(defaultActiveElement);
    });
});
/*  */
//# sourceMappingURL=FocusTrap.spec.js.map
