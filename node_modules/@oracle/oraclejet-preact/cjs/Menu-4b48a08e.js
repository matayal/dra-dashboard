/* @oracle/oraclejet-preact: 14.1.0 */
'use strict';

var tslib_es6 = require('./tslib.es6-6f60dd09.js');
var jsxRuntime = require('preact/jsx-runtime');
var UNSAFE_Layer = require('./UNSAFE_Layer.js');
require('./utils/PRIVATE_clientHints.js');
var compat = require('preact/compat');

require('./UNSAFE_Floating.js');
var hooks = require('preact/hooks');
var hooks_PRIVATE_useCollectionFocusRing = require('./hooks/PRIVATE_useCollectionFocusRing.js');
var utils_UNSAFE_mergeProps = require('./utils/UNSAFE_mergeProps.js');
require('./utils/UNSAFE_classNames.js');
var MenuItem = require('./MenuItem-0c819d68.js');
var classNames = require('./classNames-55bceee6.js');
var hooks_UNSAFE_useOutsideClick = require('./hooks/UNSAFE_useOutsideClick.js');
var Floating = require('./Floating-48167355.js');
var useModal = require('./useModal-0b4e4a2d.js');
var clientHints = require('./clientHints-e821b5ee.js');

/**
 * @license
 * Copyright (c) %FIRST_YEAR% %CURRENT_YEAR%, Oracle and/or its affiliates.
 * The Universal Permissive License (UPL), Version 1.0
 * as shown at https://oss.oracle.com/licenses/upl/
 * @ignore
 */
/**
 * Hook for handling current key update due to user interaction including keyboard navigation.
 *
 * @param keyExtractor function to extract the key based on the provided element
 * @param getPrevKey function to get the previous key based on the current key
 * @param getNextKey function to get the next key based on the current key
 * @param getFirstVisibleKey function to get the key of the first available item
 * @param getLastVisibleKey function to get the key of the last available item
 * @param currentKey the current key
 * @param onChange function to invoke if the current key has changed
 * @returns
 */
function useMenuCurrentKey(keyExtractor, getPrevKey, getNextKey, getFirstVisibleKey, getLastVisibleKey, currentKey, onChange) {
    const onKeyDown = hooks.useCallback((event) => {
        if (onChange) {
            // TODO: support horizontal layout on icon menu (left/right arrow key)
            if (event.key === 'ArrowDown' && !event.shiftKey) {
                const nextKey = getNextKey();
                if (nextKey && currentKey != nextKey) {
                    onChange({ value: nextKey });
                }
                event.preventDefault();
            }
            else if (event.key === 'ArrowUp' && !event.shiftKey) {
                const prevKey = getPrevKey();
                if (prevKey && currentKey != prevKey) {
                    onChange({ value: prevKey });
                }
                event.preventDefault();
            }
            else if (event.key === 'Home') {
                const firstKey = getFirstVisibleKey();
                if (firstKey && currentKey != firstKey) {
                    onChange({ value: firstKey });
                }
                event.preventDefault();
            }
            else if (event.key === 'End') {
                const lastKey = getLastVisibleKey();
                if (lastKey && currentKey != lastKey) {
                    onChange({ value: lastKey });
                }
                event.preventDefault();
            }
        }
    }, [currentKey, getNextKey, getPrevKey, onChange, getFirstVisibleKey, getLastVisibleKey]);
    //Capture needed since usePress stop propagation, what produces not triggering this event.
    //We can't stop propagation here, because if we do that, usePress onClick will not be triggered.
    const onClickCapture = hooks.useCallback((event) => {
        if (onChange && !event.shiftKey) {
            const nextKey = keyExtractor(event.target);
            if (nextKey && currentKey != nextKey) {
                onChange({ value: nextKey });
            }
        }
    }, [currentKey, keyExtractor, onChange]);
    const currentKeyProps = onChange == null ? {} : { onClickCapture, onKeyDown };
    return { currentKeyProps };
}

/**
 * @license
 * Copyright (c) %FIRST_YEAR% %CURRENT_YEAR%, Oracle and/or its affiliates.
 * Licensed under The Universal Permissive License (UPL), Version 1.0
 * as shown at https://oss.oracle.com/licenses/upl/
 * @ignore
 */
/**
 * Returns the key from the item element
 */
const getKey = (item) => {
    // Key is set on data-oj-menu-item-key on each menuItem. To get this key from the
    // the actual menuItem we need to do a kebab to camel-case conversion.
    return item.dataset['ojMenuItemKey'];
};
/**
 * A helper function that return the key of the first available item.
 */
const getFirstVisibleKey = (root) => {
    if (root) {
        const firstItem = root.querySelector('[data-oj-menu-item-key]');
        if (firstItem) {
            const key = getKey(firstItem);
            if (key) {
                return key;
            }
        }
    }
    return null;
};
/**
 * A helper function that return the key of the last available item.
 */
const getLastVisibleKey = (root) => {
    if (root) {
        const items = root.querySelectorAll('[data-oj-menu-item-key]');
        const lastItem = items[items.length - 1];
        if (lastItem) {
            const key = getKey(lastItem);
            if (key) {
                return key;
            }
        }
    }
    return null;
};
/**
 * A helper function that returns the key of the previous or the next item
 * given the specified current key
 */
const getPrevNextKey = (root, isPrev, currentKey) => {
    return () => {
        if (root) {
            const items = Array.from(root.querySelectorAll('[data-oj-menu-item-key]'));
            const currentKeyIndex = items.findIndex((item) => getKey(item) === currentKey);
            let nextIndex = currentKeyIndex + (isPrev ? -1 : 1);
            const itemsLastIndex = items.length - 1;
            if (nextIndex < 0) {
                nextIndex = itemsLastIndex;
            }
            if (nextIndex > itemsLastIndex) {
                nextIndex = 0;
            }
            return getKey(items[nextIndex]) || null;
        }
        return null;
    };
};
/**
 * A helper function to get the key from an element
 */
const keyExtractor = (element) => {
    const item = element.closest('[data-oj-menu-item-key]');
    if (item) {
        const key = getKey(item);
        return key === undefined ? null : key;
    }
    return null;
};
/**
 * Function to get the corresponding keyboard behavior to close the menu.
 */
const getKeyboardCloseProps = (onClose) => {
    const onKeyDown = (event) => {
        if (event.key === 'Tab') {
            onClose === null || onClose === void 0 ? void 0 : onClose({ reason: 'dismissed' });
            event.preventDefault(); //TODO: Revisit this since we should let focus be at its natural flow, quick solution for now to focus correct item in main use case
        }
        else if (event.key === 'Escape') {
            onClose === null || onClose === void 0 ? void 0 : onClose({ reason: 'dismissed' });
        }
    };
    return { onKeyDown };
};
/**
 * Function to get the corresponding specific behavior for clicking/touching down menuContainer
 */
const getMenuPointerDown = () => {
    const onPointerDown = (event) => {
        //We just want to prevent default when element that was
        //pressed down was not a menu item. Using this flag removes issues
        //related to focus visibilty on "long press"
        const nextKey = keyExtractor(event.target);
        if (!nextKey) {
            event.preventDefault();
        }
    };
    return { onPointerDown };
};

const styles$2 = {
  menuContainer: "j91n3a",
  dropdownMenuContainer: "_1dohnnf",
  sheetMenuContainer: "_78wq11"
};
const MenuContainer = ({
  children,
  onClose,
  accessibleLabel,
  initialFocus = 'menu',
  display
}) => {
  const menuContainerRef = hooks.useRef(null);
  const initialFocusRef = hooks.useRef(initialFocus);
  const [currentKey, setCurrentKey] = hooks.useState();
  const [possibleFocus, setPossibleFocus] = hooks.useState('pending');
  const changeKey = hooks.useCallback(detail => {
    setCurrentKey(detail.value);
    setPossibleFocus('firstItem');
  }, []);
  const [showFocusRing, focusRingProps] = hooks_PRIVATE_useCollectionFocusRing.useCollectionFocusRing(elem => {
    var _a;

    return !!((_a = menuContainerRef.current) === null || _a === void 0 ? void 0 : _a.contains(elem));
  }, ['ArrowUp', 'ArrowDown'], elem => {
    const nextKey = keyExtractor(elem);
    return !!nextKey;
  });
  const {
    currentKeyProps
  } = useMenuCurrentKey(element => keyExtractor(element), getPrevNextKey(menuContainerRef.current, true, currentKey), getPrevNextKey(menuContainerRef.current, false, currentKey), () => getFirstVisibleKey(menuContainerRef.current), () => getLastVisibleKey(menuContainerRef.current), currentKey, changeKey);
  hooks.useEffect(() => {
    const menuContainer = menuContainerRef.current;

    if (menuContainer) {
      if (initialFocusRef.current === 'menu') {
        // At this point floating has visibility set as hidden, so also menuContainer. Settimeout added so menuContainer
        // is visible at that point and can be focused
        setTimeout(() => {
          menuContainer.focus();
        }, 0);
        setPossibleFocus('menu');
      } else {
        const firstItemKey = getFirstVisibleKey(menuContainerRef.current);

        if (firstItemKey) {
          changeKey({
            value: firstItemKey
          });
        } else {
          setPossibleFocus('menu');
        }
      }
    }
  }, [initialFocusRef, changeKey]); // TODO - Reuse a dropdown component instead of creating floating by ourselves.

  return jsxRuntime.jsx("div", Object.assign({
    ref: menuContainerRef,
    tabIndex: possibleFocus === 'firstItem' ? -1 : 0,
    role: "menu",
    "aria-label": accessibleLabel,
    class: classNames.classNames([styles$2.menuContainer, styles$2[`${display}MenuContainer`]])
  }, utils_UNSAFE_mergeProps.mergeProps(focusRingProps, currentKeyProps, getMenuPointerDown(), getKeyboardCloseProps(onClose)), {
    children: jsxRuntime.jsx(MenuItem.MenuContext.Provider, Object.assign({
      value: {
        onClose,
        currentKey,
        showFocusRing
      }
    }, {
      children: children
    }))
  }));
};

const styles$1 = {
  // TODO: Handle vertical and horizontal overflow. Get rid of maxWidth on a next drop so horizontal and also vertical flow is handled correctly.
  // It's hard to relay just in css, we might need to relay on some kind of observer. Maybe should be handled on Floating/Dropdown component.
  base: "_18mgcg8"
};
const DropdownMenu = _a => {
  var {
    anchorRef,
    onClose
  } = _a,
      dropdownMenuProps = tslib_es6.__rest(_a, ["anchorRef", "onClose"]);

  const floatingRef = compat.useRef(null);
  const useOutsideClickHandler = compat.useCallback(e => {
    onClose === null || onClose === void 0 ? void 0 : onClose({
      reason: 'outsideClick',
      target: e.target
    });
  }, [onClose]);
  hooks_UNSAFE_useOutsideClick.useOutsideClick({
    ref: [floatingRef],
    handler: useOutsideClickHandler
  });
  return jsxRuntime.jsx(Floating.Floating, Object.assign({
    class: styles$1.base,
    ref: floatingRef,
    anchorRef: anchorRef,
    placement: "bottom-start",
    offsetValue: {
      mainAxis: 4,
      crossAxis: 0
    }
  }, {
    children: jsxRuntime.jsx("div", Object.assign({
      style: {
        minWidth: `${anchorRef.current && anchorRef.current.offsetWidth > MENU_MIN_WIDTH ? anchorRef.current.offsetWidth : MENU_MIN_WIDTH}px`
      }
    }, {
      children: jsxRuntime.jsx(MenuContainer, Object.assign({}, Object.assign({
        onClose
      }, dropdownMenuProps), {
        display: "dropdown"
      }))
    }))
  }));
};
const MENU_MIN_WIDTH = 200;

/**
 * @license
 * Copyright (c) %FIRST_YEAR% %CURRENT_YEAR%, Oracle and/or its affiliates.
 * Licensed under The Universal Permissive License (UPL), Version 1.0
 * as shown at https://oss.oracle.com/licenses/upl/
 * @ignore
 */
/*This "private" hook will live until we end up stating a final decision on useSwipe hook.
For that hook to work, element that use it has to set touch-action:none;, since pointer events
are canceled once a touch action is going to be handled by the browser. This works for most
of the components that don't scroll. But if the component scroll, there is a need for the browser to
handle scroll which is imposible with a hook just using pointer events.
*/
function useMenuSwipe(onSwipe, { threshold = 10, maximumTime = 300, tolerance = 50, isDisabled = false } = {
    threshold: 10,
    maximumTime: 300,
    tolerance: 50,
    isDisabled: false
}) {
    const ref = hooks.useRef({
        pointerDownId: 0,
        startTime: null,
        prevpageX: 0,
        prevpageY: 0,
        elementScrollTop: 0
    });
    const clearSwipe = hooks.useCallback(() => {
        ref.current = {
            pointerDownId: null,
            startTime: 0,
            prevpageX: 0,
            prevpageY: 0,
            elementScrollTop: 0
        };
    }, []);
    const onTouchStart = hooks.useCallback((e) => {
        const touchobj = e.changedTouches[0];
        if (!ref.current.pointerDownId) {
            ref.current = {
                pointerDownId: touchobj.identifier,
                startTime: e.timeStamp,
                prevpageX: touchobj.pageX,
                prevpageY: touchobj.pageY,
                elementScrollTop: e.currentTarget.scrollTop
            };
        }
        else {
            clearSwipe();
        }
    }, [clearSwipe]);
    const onTouchEnd = hooks.useCallback((ev) => {
        const touchobj = ev.changedTouches[0];
        if (touchobj.identifier === ref.current.pointerDownId) {
            if (ref.current.startTime && ev.timeStamp - ref.current.startTime < maximumTime) {
                if (touchobj.pageY - ref.current.prevpageY > threshold &&
                    Math.abs(touchobj.pageX - ref.current.prevpageX) <= tolerance &&
                    ref.current.elementScrollTop === 0) {
                    onSwipe === null || onSwipe === void 0 ? void 0 : onSwipe({ direction: 'down' });
                }
            }
        }
        // state would be reset to its original state whether swipe is completed or cancelled
        clearSwipe();
    }, [threshold, onSwipe, clearSwipe, maximumTime, tolerance]);
    const swipeProps = isDisabled
        ? {}
        : {
            /** event handlers to spread on the target element. */
            onTouchStart,
            onTouchEnd,
            ontouchcancel: clearSwipe
        };
    return {
        swipeProps
    };
}

const styles = {
  modalWrapper: "pv4inq",
  modalContainer: "x62vcr",
  sheetMenuContainerWrapper: "_10ke6sd",
  modalBackdrop: "_1w64tom"
};

const ModalWrapper = ({
  children
}) => jsxRuntime.jsx("div", Object.assign({
  class: styles.modalWrapper
}, {
  children: children
}));

const ModalContainer = compat.forwardRef(({
  children
}, ref) => jsxRuntime.jsx("div", Object.assign({
  class: styles.modalContainer,
  ref: ref
}, {
  children: children
}))); //ModalBackdrop on modal folder not setting the style on oj-c enviroment
//Creating it here so we don't see that issue

const ModalBackdrop = () => jsxRuntime.jsx("div", {
  class: styles.modalBackdrop
});

const SheetMenu = _a => {
  var {
    onClose
  } = _a,
      menuProps = tslib_es6.__rest(_a, ["onClose"]);

  hooks.useEffect(() => {
    // We set the overflow body as hidden when mounted and revert to original overflow value when is
    // unmounted. This is done to don't allow backgound being scrolled
    // This will be handled by modal/popup when ready
    const initialOverflow = document.body.style.overflow;
    document.body.style.overflow = 'hidden';
    return () => {
      document.body.style.overflow = initialOverflow;
    };
  }, []);
  const dismissHandler = hooks.useCallback(() => {
    onClose === null || onClose === void 0 ? void 0 : onClose({
      reason: 'dismissed'
    });
  }, [onClose]);
  const {
    modalRef
  } = useModal.useModal({
    isOpen: true,
    onBackdropClick: dismissHandler
  }); //TODO: Use useSwipe when it works on components that could scroll.

  const {
    swipeProps
  } = useMenuSwipe(dismissHandler); // TODO: For now we are mimicking current modal but using a "different position setting" (using absolute positioning instead of flex).
  // Have to use modal/popup component directly instead doing this composition when that component could satisfy our requirments.

  return jsxRuntime.jsxs(ModalWrapper, {
    children: [jsxRuntime.jsx(ModalBackdrop, {}), jsxRuntime.jsx(ModalContainer, Object.assign({
      ref: modalRef
    }, {
      children: jsxRuntime.jsx("div", Object.assign({
        class: styles.sheetMenuContainerWrapper
      }, swipeProps, {
        children: jsxRuntime.jsx(MenuContainer, Object.assign({}, Object.assign(Object.assign({}, menuProps), {
          onClose
        }), {
          display: "sheet"
        }))
      }))
    }))]
  });
};

const { deviceType } = clientHints.getClientHints();
const isMobile = deviceType === 'phone';
const Menu = (_a) => {
    var { isOpen, anchorRef } = _a, menuProps = tslib_es6.__rest(_a, ["isOpen", "anchorRef"]);
    // TODO - Reuse a dropdown component instead of creating floating by ourselves.
    return !isOpen ? null : (jsxRuntime.jsx(UNSAFE_Layer.Layer, Object.assign({ logicalParentRef: anchorRef }, { children: isMobile ? jsxRuntime.jsx(SheetMenu, Object.assign({}, menuProps)) : jsxRuntime.jsx(DropdownMenu, Object.assign({}, Object.assign({ anchorRef }, menuProps))) })));
};

exports.Menu = Menu;
/*  */
//# sourceMappingURL=Menu-4b48a08e.js.map
