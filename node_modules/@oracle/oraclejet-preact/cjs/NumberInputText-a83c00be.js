/* @oracle/oraclejet-preact: 14.1.0 */
'use strict';

var jsxRuntime = require('preact/jsx-runtime');
var preact = require('preact');
var compat = require('preact/compat');
var hooks = require('preact/hooks');
var hooks_UNSAFE_useFocusableTextField = require('./hooks/UNSAFE_useFocusableTextField.js');
var hooks_UNSAFE_useFormContext = require('./hooks/UNSAFE_useFormContext.js');
var hooks_UNSAFE_useFormFieldContext = require('./hooks/UNSAFE_useFormFieldContext.js');
var hooks_UNSAFE_useHover = require('./hooks/UNSAFE_useHover.js');
var hooks_UNSAFE_useTextField = require('./hooks/UNSAFE_useTextField.js');
var UNSAFE_Label = require('./UNSAFE_Label.js');
var hooks_UNSAFE_usePrefixSuffix = require('./hooks/UNSAFE_usePrefixSuffix.js');
var UNSAFE_TextField = require('./UNSAFE_TextField.js');
var UNSAFE_UserAssistance = require('./UNSAFE_UserAssistance.js');
require('./utils/PRIVATE_clientHints.js');
var hooks_UNSAFE_useToggle = require('./hooks/UNSAFE_useToggle.js');
require('./UNSAFE_Button.js');
var UNSAFE_Icons = require('./index-d5067e50.js');
var hooks_UNSAFE_useTabbableMode = require('./hooks/UNSAFE_useTabbableMode.js');
var hooks_UNSAFE_useTranslationBundle = require('./hooks/UNSAFE_useTranslationBundle.js');
var Button = require('./Button-07d97191.js');
var UNSAFE_Grid = require('./UNSAFE_Grid.js');
var hooks_UNSAFE_useCurrentValueReducer = require('./hooks/UNSAFE_useCurrentValueReducer.js');
var ReadonlyTextFieldInput = require('./ReadonlyTextFieldInput-ec13a273.js');
var TextFieldInput = require('./TextFieldInput-c5f861ba.js');
var clientHints = require('./clientHints-e821b5ee.js');

/**
 * A StepButton is used to request a "step up" or "step down" to a value in NumberInputText.
 * @param direction The direction of the step
 * @param isDisabled Whether the button should be disabled
 * @param onStep Handler called when the button is clicked
 * @param variant Represents different visual variants for the button
 */
function StepButton({ direction, isDisabled, onStep, variant }) {
    const translations = hooks_UNSAFE_useTranslationBundle.useTranslationBundle('@oracle/oraclejet-preact');
    const labelIncrease = translations.inputNumber_increase();
    const labelDecrease = translations.inputNumber_decrease();
    const label = direction === 'increase' ? labelIncrease : labelDecrease;
    const handleClick = hooks.useCallback(() => {
        onStep === null || onStep === void 0 ? void 0 : onStep({ direction });
    }, [onStep, direction]);
    const icon = variant === 'arrowup' ? jsxRuntime.jsx(UNSAFE_Icons.SvgIcoChevronUp, {}) : jsxRuntime.jsx(UNSAFE_Icons.SvgIcoChevronDown, {});
    return (jsxRuntime.jsx(hooks_UNSAFE_useTabbableMode.TabbableModeContext.Provider, Object.assign({ value: { isTabbable: false } }, { children: jsxRuntime.jsx(Button.Button, { display: "icons", isDisabled: isDisabled, title: label, onAction: handleClick, startIcon: icon, variant: "borderless" }) })));
}

// TODO: Replace Steppers with Buttonset when it becomes available
function Steppers({ children }) {
    return (jsxRuntime.jsx(UNSAFE_Grid.Grid, Object.assign({ align: "center", gap: "1x", gridTemplateColumns: "1fr 1fr" }, { children: children })));
}

const SPIN_DELAY = 500;
const SPIN_INTERVAL = 40;
/**
 * A hook for using stepping functionality with NumberInputText. Stepping can
 * be accomplished using the step up or down buttons or by pressing the arrow
 * up or arrow down keys. Holding down the buttons or keys produces continuous
 * step events.
 *
 * @param hasSteppers Controls whether the step buttons are shown
 * @param inputRef A ref to the input element
 * @param isStepDownDisabled Controls whether stepping down is disabled
 * @param isStepUpDisabled Controls whether stepping up is disabled
 * @param onSpin Called when a continuous step (aka spin) is requested
 * @param onSpinComplete Called when spinning is complete
 * @param onStep Called when a single step is requested
 * @returns A JSX element which can be placed in the endContent of NumberInputText.
 */
const useSteppers = ({ hasSteppers, inputRef, isStepDownDisabled, isStepUpDisabled, onSpin, onSpinComplete, onStep }) => {
    const { bool: isStarted, setTrue: setStartedTrue, setFalse: setStartedFalse } = hooks_UNSAFE_useToggle.useToggle(false);
    const { bool: isSpinning, setTrue: setSpinningTrue, setFalse: setSpinningFalse } = hooks_UNSAFE_useToggle.useToggle(false);
    const startTimerRef = hooks.useRef(null);
    const spinTimerRef = hooks.useRef(null);
    const directionRef = hooks.useRef('increase');
    const spinCompleteRef = hooks.useRef(false);
    const onKeyDown = hooks.useCallback((event) => {
        if (!(event.key === 'ArrowDown' || event.key === 'ArrowUp')) {
            return;
        }
        // By default, pressing the arrow keys moves the cursor to the
        // beginning or end which we don't want, so call preventDefault.
        // We also want to stop propagation of handled events.
        event.preventDefault();
        event.stopPropagation();
        if (isStarted) {
            // If already started, ignore repeated key down events.
            return;
        }
        if ((event.key === 'ArrowDown' && isStepDownDisabled) ||
            (event.key === 'ArrowUp' && isStepUpDisabled)) {
            // If requested step is disabled, return.
            return;
        }
        directionRef.current = event.key === 'ArrowDown' ? 'decrease' : 'increase';
        setStartedTrue();
        // Do an initial step, which is what oj-input-number did as well.
        onStep === null || onStep === void 0 ? void 0 : onStep({ direction: directionRef.current });
    }, [isStarted, onStep, isStepDownDisabled, isStepUpDisabled, setStartedTrue]);
    const onKeyUp = hooks.useCallback((event) => {
        if (event.key === 'ArrowDown' || event.key === 'ArrowUp') {
            if (isSpinning) {
                // Only want to call onSpinComplete if we were actually spinning.
                spinCompleteRef.current = true;
            }
            setStartedFalse();
            setSpinningFalse();
            event.stopPropagation();
        }
    }, [isSpinning, setStartedFalse, setSpinningFalse]);
    hooks.useEffect(() => {
        if (isStarted && !startTimerRef.current) {
            startTimerRef.current = setTimeout(() => {
                setSpinningTrue();
            }, SPIN_DELAY);
        }
        return () => {
            // Clean up between renders.
            if (startTimerRef.current) {
                clearTimeout(startTimerRef.current);
                startTimerRef.current = null;
            }
        };
    }, [isStarted, setSpinningTrue]);
    hooks.useEffect(() => {
        if (!isSpinning) {
            if (spinTimerRef.current) {
                clearInterval(spinTimerRef.current);
                spinTimerRef.current = null;
            }
        }
        else {
            if (!spinTimerRef.current) {
                spinTimerRef.current = setInterval(() => {
                    // If further spinning is disabled, call setSpinningFalse to
                    // clean up the timer otherwise repeat the step.
                    if ((directionRef.current === 'increase' && isStepUpDisabled) ||
                        (directionRef.current === 'decrease' && isStepDownDisabled)) {
                        setSpinningFalse();
                        spinCompleteRef.current = true;
                    }
                    else {
                        onSpin === null || onSpin === void 0 ? void 0 : onSpin({ direction: directionRef.current });
                    }
                }, SPIN_INTERVAL);
            }
        }
        return () => {
            // Clean up between renders.
            if (spinTimerRef.current) {
                clearInterval(spinTimerRef.current);
                spinTimerRef.current = null;
            }
        };
    }, [isSpinning, isStepDownDisabled, isStepUpDisabled, onSpin, setSpinningFalse]);
    // Only want to run this effect when isSpinning is false and our ref is true.
    // This helps guarantee onSpinComplete is only called once after spinning stops,
    // even if onSpinComplete's identity is changing.
    hooks.useEffect(() => {
        if (!isSpinning && spinCompleteRef.current) {
            spinCompleteRef.current = false;
            onSpinComplete === null || onSpinComplete === void 0 ? void 0 : onSpinComplete();
        }
    }, [isSpinning, onSpinComplete]);
    const handleClick = hooks.useCallback((event) => {
        var _a;
        // When a step button is clicked, set focus to the input.
        (_a = inputRef.current) === null || _a === void 0 ? void 0 : _a.focus();
        onStep === null || onStep === void 0 ? void 0 : onStep(event);
    }, [onStep, inputRef]);
    const handleDisabledMouseDown = hooks.useCallback((event) => {
        // Using preventDefault prevents focus from moving to the body when a disabled stepper is clicked.
        // FIXME: can we handle this use case more generally at the startContent/endContent level in TextFieldContent?
        event.preventDefault();
        event.stopPropagation();
    }, []);
    const steppers = hasSteppers ? (jsxRuntime.jsxs(Steppers, { children: [jsxRuntime.jsx("div", Object.assign({ onMouseDown: (e) => isStepDownDisabled && handleDisabledMouseDown(e), "aria-hidden": "true" }, { children: jsxRuntime.jsx(StepButton, { direction: "decrease", isDisabled: isStepDownDisabled, onStep: handleClick, variant: "arrowdown" }) })), jsxRuntime.jsx("div", Object.assign({ onMouseDown: (e) => isStepUpDisabled && handleDisabledMouseDown(e), "aria-hidden": "true" }, { children: jsxRuntime.jsx(StepButton, { direction: "increase", isDisabled: isStepUpDisabled, onStep: handleClick, variant: "arrowup" }) }))] })) : undefined;
    // stepHandlerProps will be spread onto the parent to handle
    // stepping functionality via the arrow up or down keys.
    const stepHandlerProps = hasSteppers ? { onKeyDown, onKeyUp } : {};
    return { steppers, stepHandlerProps };
};

const NumberInputText = compat.forwardRef(({ ariaDescribedBy, ariaValueMax, ariaValueMin, ariaValueNow, ariaValueText, assistiveText, autoComplete = 'off', autoFocus = false, helpSourceLink, helpSourceText, isDisabled: propIsDisabled, isReadonly: propIsReadonly, isRequired = false, isRequiredShown, isStepDownDisabled: propIsStepDownDisabled, isStepUpDisabled: propIsStepUpDisabled, hasSteppers = false, label, labelEdge: propLabelEdge, labelStartWidth: propLabelStartWidth, messages, placeholder, prefix, suffix, textAlign: propTextAlign, userAssistanceDensity: propUserAssistanceDensity, value, variant = 'default', virtualKeyboard, onInput, onCommit, onSpin, onSpinComplete, onStep }, ref) => {
    const { currentCommitValue, dispatch } = hooks_UNSAFE_useCurrentValueReducer.useCurrentValueReducer({ value });
    const onInputAndDispatch = hooks.useCallback((detail) => {
        dispatch({ type: 'input', payload: detail.value });
        onInput === null || onInput === void 0 ? void 0 : onInput(detail);
    }, [onInput, dispatch]);
    const onCommitAndDispatch = hooks.useCallback((detail) => {
        dispatch({ type: 'commit', payload: detail.value });
        onCommit === null || onCommit === void 0 ? void 0 : onCommit(detail);
    }, [onCommit, dispatch]);
    const { isDisabled: isFormDisabled, isReadonly: isFormReadonly, labelEdge: formLabelEdge, labelStartWidth: formLabelStartWidth, textAlign: formTextAlign, userAssistanceDensity: formUserAssistanceDensity } = hooks_UNSAFE_useFormContext.useFormContext();
    // default to FormContext values if component properties are not specified
    const isDisabled = propIsDisabled !== null && propIsDisabled !== void 0 ? propIsDisabled : isFormDisabled;
    const isReadonly = propIsReadonly !== null && propIsReadonly !== void 0 ? propIsReadonly : isFormReadonly;
    const labelEdge = propLabelEdge !== null && propLabelEdge !== void 0 ? propLabelEdge : formLabelEdge;
    const labelStartWidth = propLabelStartWidth !== null && propLabelStartWidth !== void 0 ? propLabelStartWidth : formLabelStartWidth;
    const textAlign = propTextAlign !== null && propTextAlign !== void 0 ? propTextAlign : formTextAlign;
    const userAssistanceDensity = propUserAssistanceDensity !== null && propUserAssistanceDensity !== void 0 ? propUserAssistanceDensity : formUserAssistanceDensity;
    const { enabledElementRef, focusProps, isFocused, readonlyElementRef } = hooks_UNSAFE_useFocusableTextField.useFocusableTextField({ isDisabled, isReadonly, ref });
    const { hoverProps } = hooks_UNSAFE_useHover.useHover({ isDisabled: isReadonly || isDisabled || false });
    const { baseId, formFieldContext, inputProps, labelProps, textFieldProps, userAssistanceProps } = hooks_UNSAFE_useTextField.useTextField({
        ariaDescribedBy,
        isDisabled,
        isFocused,
        isReadonly,
        labelEdge,
        messages,
        styleVariant: variant,
        value
    });
    // Disable the steppers if the number input is disabled.
    const isStepDownDisabled = isDisabled || propIsStepDownDisabled;
    const isStepUpDisabled = isDisabled || propIsStepUpDisabled;
    // stepHandlerProps contains keyup and keydown handlers
    // for stepping using the arrow up and down keys.
    const { steppers, stepHandlerProps } = useSteppers({
        hasSteppers,
        inputRef: enabledElementRef,
        isStepDownDisabled,
        isStepUpDisabled,
        onSpin,
        onSpinComplete,
        onStep
    });
    const { renderedPrefix, renderedSuffix, text: valuePrefixSuffix, ariaLabelledBy } = hooks_UNSAFE_usePrefixSuffix.usePrefixSuffix({
        baseId,
        hasEndContent: steppers !== undefined,
        hasInsideLabel: label !== undefined && labelEdge === 'inside',
        hasStartContent: false,
        hasValue: formFieldContext.hasValue,
        isDisabled,
        isFocused,
        labelId: labelProps.id,
        prefix,
        suffix,
        value
    });
    const labelComp = labelEdge !== 'none' ? jsxRuntime.jsx(UNSAFE_Label.Label, Object.assign({}, labelProps, { children: label })) : undefined;
    const fieldLabelProps = {
        label: labelEdge !== 'none' ? labelComp : undefined,
        labelEdge: labelEdge !== 'none' ? labelEdge : undefined,
        labelStartWidth: labelEdge !== 'none' ? labelStartWidth : undefined
    };
    const ariaLabel = labelEdge === 'none' ? label : undefined;
    const inlineUserAssistance = isDisabled || isReadonly ? (
    // save space for user assistance if density is 'efficient', even though we don't
    // render user assistance for disabled or readonly fields
    userAssistanceDensity !== 'efficient' ? undefined : (jsxRuntime.jsx(UNSAFE_UserAssistance.InlineUserAssistance, Object.assign({ userAssistanceDensity: userAssistanceDensity }, userAssistanceProps)))) : (jsxRuntime.jsx(UNSAFE_UserAssistance.InlineUserAssistance, Object.assign({ assistiveText: assistiveText, fieldLabel: label, helpSourceLink: helpSourceLink, helpSourceText: helpSourceText, messages: messages, isRequiredShown: isRequiredShown, userAssistanceDensity: userAssistanceDensity }, userAssistanceProps)));
    if (isReadonly) {
        return (jsxRuntime.jsx(hooks_UNSAFE_useFormFieldContext.FormFieldContext.Provider, Object.assign({ value: formFieldContext }, { children: jsxRuntime.jsx(UNSAFE_TextField.ReadonlyTextField, Object.assign({ role: "presentation", inlineUserAssistance: inlineUserAssistance, onBlur: focusProps.onfocusout, onFocus: focusProps.onfocusin }, fieldLabelProps, { children: jsxRuntime.jsx(ReadonlyTextFieldInput.ReadonlyTextFieldInput, { ariaDescribedBy: ariaDescribedBy, ariaLabel: ariaLabel, ariaLabelledBy: labelProps.id, as: "div", autoFocus: autoFocus, elementRef: readonlyElementRef, textAlign: textAlign, value: valuePrefixSuffix, hasInsideLabel: label !== undefined && labelEdge === 'inside' }) })) })));
    }
    // If ariaValueText is the same as ariaValueNow.toString, no need to show it.
    const valueText = ariaValueNow === undefined
        ? ariaValueText
        : ariaValueNow.toString() !== ariaValueText
            ? ariaValueText
            : undefined;
    const mainContent = (jsxRuntime.jsxs(preact.Fragment, { children: [renderedPrefix, jsxRuntime.jsx(TextFieldInput.TextFieldInput, Object.assign({ ariaLabelledBy: ariaLabelledBy, ariaLabel: ariaLabel, ariaValueMax: ariaValueMax, ariaValueMin: ariaValueMin, ariaValueNow: ariaValueNow, ariaValueText: valueText, autoComplete: autoComplete, autoFocus: autoFocus, currentCommitValue: currentCommitValue, hasEndContent: steppers !== undefined, hasInsideLabel: labelComp !== undefined && labelEdge === 'inside', hasPrefix: renderedPrefix !== undefined, hasStartContent: false, hasSuffix: renderedSuffix !== undefined, inputRef: enabledElementRef, isRequired: isRequired, placeholder: placeholder, role: hasSteppers ? 'spinbutton' : undefined, textAlign: textAlign, type: isMobile() ? virtualKeyboard : undefined, value: isDisabled ? valuePrefixSuffix : value, onCommit: onCommitAndDispatch, onInput: onInputAndDispatch }, inputProps, stepHandlerProps)), renderedSuffix] }));
    return (jsxRuntime.jsx(hooks_UNSAFE_useFormFieldContext.FormFieldContext.Provider, Object.assign({ value: formFieldContext }, { children: jsxRuntime.jsx(UNSAFE_TextField.TextField, Object.assign({ endContent: steppers, inlineUserAssistance: inlineUserAssistance, mainContent: mainContent, onBlur: focusProps.onfocusout, onFocus: focusProps.onfocusin }, textFieldProps, fieldLabelProps, hoverProps)) })));
});
/**
 * Helper function to determine whether the current device is a mobile device
 * @returns true if runnning on a mobile device, false otherwise
 */
function isMobile() {
    const deviceType = clientHints.getClientHints().deviceType;
    return deviceType === 'phone' || deviceType === 'tablet';
}

exports.NumberInputText = NumberInputText;
/*  */
//# sourceMappingURL=NumberInputText-a83c00be.js.map
