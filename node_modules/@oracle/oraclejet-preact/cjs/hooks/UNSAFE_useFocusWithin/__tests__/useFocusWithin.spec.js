/* @oracle/oraclejet-preact: 14.1.0 */
'use strict';

var jsxRuntime = require('preact/jsx-runtime');
var useFocusWithin = require('../../../useFocusWithin-145e8682.js');
var preact = require('@testing-library/preact');
var chai = require('chai');
var Sinon = require('sinon');
require('preact/hooks');

function TestComponent(props) {
    const { focusProps, isFocused } = useFocusWithin.useFocusWithin(props);
    return (jsxRuntime.jsxs("div", { children: [jsxRuntime.jsx("div", Object.assign({}, focusProps, { children: jsxRuntime.jsx("input", { id: "insideInput" }) })), isFocused && jsxRuntime.jsx("span", { children: "Focused" }), jsxRuntime.jsx("input", { id: "outsideInput" })] }));
}
describe('useFocusWithin tests', () => {
    // TODO: Figure out why this test is timing out in Jest.
    // it('should correctly set the isFocused boolean', async () => {
    //   const { container } = render(<TestComponent />);
    //   const inputElement = container.querySelector<HTMLInputElement>('#insideInput');
    //   const outerInputElement = container.querySelector<HTMLInputElement>('#outsideInput');
    //   // check that the isFocused is false initially
    //   expect(container.querySelector('span'), 'focused text is not present').be.null;
    //   // focus the input element and check for the flag
    //   inputElement?.focus();
    //   await waitFor(
    //     () => expect(container.querySelector('span'), 'focused text is present').not.be.null
    //   );
    //   // focus outside and check for the flag
    //   outerInputElement?.focus();
    //   await waitForElementToBeRemoved(container.querySelector('span'));
    // });
    it('should call the callbacks correctly', async () => {
        const onFocus = Sinon.spy();
        const onBlur = Sinon.spy();
        const { container } = preact.render(jsxRuntime.jsx(TestComponent, { onFocusWithin: onFocus, onBlurWithin: onBlur }));
        const inputElement = container.querySelector('#insideInput');
        const outerInputElement = container.querySelector('#outsideInput');
        // focus the input element and check for the flag
        inputElement === null || inputElement === void 0 ? void 0 : inputElement.focus();
        await preact.waitFor(() => chai.expect(onFocus.calledOnceWithExactly(Sinon.match({ type: 'focusin' })), 'onFocusWithin called').be
            .true);
        // focus outside and check for the flag
        outerInputElement === null || outerInputElement === void 0 ? void 0 : outerInputElement.focus();
        await preact.waitFor(() => chai.expect(onFocus.calledOnceWithExactly(Sinon.match({ type: 'focusin' })), 'onBlurWithin called').be
            .true);
    });
    it('should not call the callbacks when disabled', async () => {
        const onFocus = Sinon.spy();
        const onBlur = Sinon.spy();
        const { container } = preact.render(jsxRuntime.jsx(TestComponent, { onFocusWithin: onFocus, onBlurWithin: onBlur, isDisabled: true }));
        const inputElement = container.querySelector('#insideInput');
        const outerInputElement = container.querySelector('#outsideInput');
        // focus the input element and check for the flag
        inputElement === null || inputElement === void 0 ? void 0 : inputElement.focus();
        await preact.waitFor(() => chai.expect(onFocus.notCalled, 'onFocusWithin not called').be.true);
        // focus outside and check for the flag
        outerInputElement === null || outerInputElement === void 0 ? void 0 : outerInputElement.focus();
        await preact.waitFor(() => chai.expect(onBlur.notCalled, 'onBlurWithin not called').be.true);
    });
});
/*  */
//# sourceMappingURL=useFocusWithin.spec.js.map
