{"version":3,"file":"FormControlPrefixSuffix.spec.js","sources":["../../../../src/__tests__/FormControls/FormControlPrefixSuffix.spec.tsx"],"sourcesContent":["import { act, cleanup, render } from '@testing-library/preact';\nimport { expect } from 'chai';\nimport { ComponentProps } from 'preact';\nimport { InputText } from '../../UNSAFE_InputText';\nimport { NumberInputText } from '../../UNSAFE_NumberInputText';\n\ntype DemoInputTextProps = Pick<\n  ComponentProps<typeof InputText>,\n  'isDisabled' | 'isReadonly' | 'label' | 'labelEdge' | 'prefix' | 'suffix' | 'value'\n>;\n\nconst noOp = () => {};\n\nfunction DemoInputText({\n  isDisabled,\n  isReadonly,\n  label,\n  labelEdge,\n  prefix,\n  suffix,\n  value\n}: DemoInputTextProps) {\n  return (\n    <>\n      <InputText\n        isDisabled={isDisabled}\n        isReadonly={isReadonly}\n        label={label}\n        labelEdge={labelEdge}\n        onInput={noOp}\n        prefix={prefix}\n        suffix={suffix}\n        value={value}\n      />\n    </>\n  );\n}\n\ntype DemoNumberInputTextProps = Pick<\n  ComponentProps<typeof NumberInputText>,\n  'isDisabled' | 'isReadonly' | 'label' | 'labelEdge' | 'prefix' | 'suffix' | 'value'\n>;\n\nfunction DemoNumberInputText({\n  isDisabled,\n  isReadonly,\n  label,\n  labelEdge,\n  prefix,\n  suffix,\n  value\n}: DemoNumberInputTextProps) {\n  return (\n    <>\n      <NumberInputText\n        isDisabled={isDisabled}\n        isReadonly={isReadonly}\n        label={label}\n        labelEdge={labelEdge}\n        onInput={noOp}\n        prefix={prefix}\n        suffix={suffix}\n        value={value}\n      />\n    </>\n  );\n}\n\nconst componentList: { name: string; component: any }[] = [\n  { name: 'InputText', component: DemoInputText },\n  { name: 'NumberInputText', component: DemoNumberInputText }\n];\n\ndescribe('Form Controls - Prefix/Suffix', () => {\n  function testPrefixIsThere(inputElement: HTMLElement | null, queryTextLength: number) {\n    const element = inputElement?.previousElementSibling;\n    expect(element?.tagName.toUpperCase).not.equal('LABEL');\n    expect(queryTextLength).to.equal(1);\n  }\n\n  function testPrefixIsNotThere(inputElement: HTMLElement | null, queryTextLength: number) {\n    const element = inputElement?.previousElementSibling;\n    expect(element?.tagName.toUpperCase()).equal('LABEL');\n    expect(queryTextLength).to.equal(0);\n  }\n\n  function testSuffixIsThere(inputElement: HTMLElement | null, queryTextLength: number) {\n    const element = inputElement?.nextElementSibling;\n    expect(element).to.be.not.null;\n    expect(queryTextLength).to.equal(1);\n  }\n\n  function testSuffixIsNotThere(inputElement: HTMLElement | null, queryTextLength: number) {\n    const element = inputElement?.nextElementSibling;\n    expect(element).to.be.null;\n    expect(queryTextLength).to.equal(0);\n  }\n\n  componentList.forEach((compObj) =>\n    it(`${compObj.name}: prefix is there with value`, () => {\n      const text = '+234';\n      const { container, queryAllByText } = render(\n        <compObj.component prefix={text} value=\"123412\" label=\"with prefix\" />\n      );\n\n      const inputElement = container.querySelector('input');\n      expect(inputElement).not.to.be.null;\n      // prefix/suffix *is there* when there is a value and there is no focus.\n      testPrefixIsThere(inputElement, queryAllByText(text).length);\n    })\n  );\n\n  componentList.forEach((compObj) =>\n    it(`${compObj.name}: prefix is not there no value and no focus`, () => {\n      const text = '+234';\n      const { container, queryAllByText } = render(\n        <compObj.component prefix={text} label=\"no prefix\" />\n      );\n\n      const inputElement = container.querySelector('input');\n      expect(inputElement).not.to.be.null;\n      // prefix/suffix *is not there* when there is not a value and there is no focus.\n      testPrefixIsNotThere(inputElement, queryAllByText(text).length);\n    })\n  );\n\n  componentList.forEach((compObj) =>\n    it(`${compObj.name}: prefix is there no value and focus`, () => {\n      const text = '+234';\n      const { container, queryAllByText } = render(\n        <compObj.component prefix={text} label=\"with prefix\" />\n      );\n\n      const inputElement = container.querySelector('input');\n      expect(inputElement).not.to.be.null;\n\n      // copied from previous test that says: fireEvent.focus and userEvent.click does not seem to work here\n      act(() => {\n        inputElement?.focus();\n      });\n\n      // prefix/suffix *is there* when there is focus\n      testPrefixIsThere(inputElement, queryAllByText(text).length);\n    })\n  );\n\n  componentList.forEach((compObj) =>\n    it(`${compObj.name}: prefix empty string is not there with value`, () => {\n      const text = '';\n      const { container } = render(\n        <compObj.component prefix={text} value=\"123412\" label=\"no prefix\" />\n      );\n\n      const inputElement = container.querySelector('input');\n      expect(inputElement).not.to.be.null;\n      // prefix/suffix *is not there* if it is ''.\n      // test when there is a value and there is no focus since that is when it would normally be there.\n      const element = inputElement?.previousElementSibling;\n      expect(element?.tagName.toUpperCase()).equal('LABEL');\n    })\n  );\n\n  componentList.forEach((compObj) =>\n    it(`${compObj.name}: suffix is there with value`, () => {\n      const text = 'lbs';\n      const { container, queryAllByText } = render(\n        <compObj.component suffix={text} value=\"123412\" label=\"with suffix\" />\n      );\n\n      const inputElement = container.querySelector('input');\n      expect(inputElement).not.to.be.null;\n      // prefix/suffix *is there* when there is a value and there is no focus.\n      testSuffixIsThere(inputElement, queryAllByText(text).length);\n    })\n  );\n\n  componentList.forEach((compObj) =>\n    it(`${compObj.name}: suffix is not there no value and no focus`, () => {\n      const text = 'lbs';\n      const { container, queryAllByText } = render(\n        <compObj.component suffix={text} label=\"with suffix\" />\n      );\n\n      const inputElement = container.querySelector('input');\n      expect(inputElement).not.to.be.null;\n      // prefix/suffix *is not there* when there is not a value and there is no focus.\n      testSuffixIsNotThere(inputElement, queryAllByText(text).length);\n    })\n  );\n\n  componentList.forEach((compObj) =>\n    it(`${compObj.name}: suffix is there no value and focus`, () => {\n      const text = 'lbs';\n      const { container, queryAllByText } = render(\n        <compObj.component suffix={text} label=\"with suffix\" />\n      );\n\n      const inputElement = container.querySelector('input');\n      expect(inputElement).not.to.be.null;\n\n      // copied from previous test that says: fireEvent.focus and userEvent.click does not seem to work here\n      act(() => {\n        inputElement?.focus();\n      });\n\n      // prefix/suffix *is there* when there is focus\n      testSuffixIsThere(inputElement, queryAllByText(text).length);\n    })\n  );\n\n  componentList.forEach((compObj) =>\n    it(`${compObj.name}: suffix empty string is not there with value`, () => {\n      const text = '';\n      const { container } = render(\n        <compObj.component suffix={text} value=\"lbs\" label=\"with suffix\" />\n      );\n\n      const inputElement = container.querySelector('input');\n      expect(inputElement).not.to.be.null;\n      // prefix/suffix *is not there* if it is ''.\n      // test when there is a value and there is no focus since that is when a prefix/suffix\n      // that isn't the empty string would be there.\n      const element = inputElement?.nextElementSibling;\n      expect(element).to.be.null;\n    })\n  );\n\n  componentList.forEach((compObj) =>\n    it(`${compObj.name}: disabled, prefix is not there no value`, () => {\n      const text = '+234';\n      const { container, queryAllByText } = render(\n        <compObj.component prefix={text} isDisabled={true} label=\"with suffix\" />\n      );\n\n      const inputElement = container.querySelector('input');\n      expect(inputElement).not.to.be.null;\n      // prefix/suffix *is not there* when there is not a value and there is no focus.\n      testPrefixIsNotThere(inputElement, queryAllByText(text).length);\n    })\n  );\n\n  componentList.forEach((compObj) =>\n    // disabled has no suffix dom.\n    it(`${compObj.name}: disabled with value (disabled is text-only)`, () => {\n      const text = 'lbs';\n      const { container, queryAllByText } = render(\n        <compObj.component suffix={text} value=\"123412\" isDisabled={true} label=\"with suffix\" />\n      );\n\n      const inputElement = container.querySelector('input');\n      expect(inputElement).not.to.be.null;\n      testSuffixIsNotThere(inputElement, queryAllByText(text).length);\n      expect(inputElement?.value).to.equal(`123412 lbs`);\n    })\n  );\n\n  componentList.forEach((compObj) =>\n    it(`${compObj.name}: disabled, suffix is not there no value and no focus`, () => {\n      const text = 'lbs';\n      const { container, queryAllByText } = render(\n        <compObj.component suffix={text} isDisabled={true} label=\"with suffix\" />\n      );\n\n      const inputElement = container.querySelector('input');\n      expect(inputElement).not.to.be.null;\n      // prefix/suffix *is not there* when there is not a value and there is no focus.\n      testSuffixIsNotThere(inputElement, queryAllByText(text).length);\n    })\n  );\n\n  componentList.forEach((compObj) =>\n    it(`${compObj.name}: readonly suffix text`, () => {\n      const text = 'lbs';\n      const value = '123412';\n      const expectedReadonlytext = `${value} ${text}`;\n      const { container, queryByText } = render(\n        <compObj.component suffix={text} value={value} isReadonly={true} label=\"with suffix\" />\n      );\n\n      const inputElement = container.querySelector('input');\n      expect(inputElement).to.be.null;\n\n      // test style\n      const foundReadonlyText = queryByText(expectedReadonlytext);\n      expect(foundReadonlyText).not.to.be.null;\n    })\n  );\n\n  componentList.forEach((compObj) =>\n    it(`${compObj.name}: readonly prefix text`, () => {\n      const text = '+234';\n      const value = '123412';\n      const expectedReadonlytext = `${text} ${value}`;\n      const { container, queryByText } = render(\n        <compObj.component prefix={text} value={value} isReadonly={true} label=\"with prefix\" />\n      );\n\n      const inputElement = container.querySelector('input');\n      expect(inputElement).to.be.null;\n\n      // test style\n      const foundReadonlyText = queryByText(expectedReadonlytext);\n      expect(foundReadonlyText).not.to.be.null;\n    })\n  );\n\n  componentList.forEach((compObj) =>\n    it(`${compObj.name}: readonly prefix text no value`, () => {\n      const text = '+234';\n      const unexpectedReadonlytext = text;\n      const { container, queryByText } = render(\n        <compObj.component prefix={text} isReadonly={true} label=\"with prefix\" />\n      );\n\n      const inputElement = container.querySelector('input');\n      expect(inputElement).to.be.null;\n\n      // shouldn't have any text. make sure we do not accidentally render prefix\n      const foundReadonlyText = queryByText(unexpectedReadonlytext);\n      expect(foundReadonlyText).to.be.null;\n    })\n  );\n\n  componentList.forEach((compObj) =>\n    it(`${compObj.name}: prefix aria-labelledby, no label`, () => {\n      const text = '+234';\n      const { container, queryByText } = render(\n        <compObj.component prefix={text} value=\"123412\" labelEdge=\"none\" label=\"with prefix\" />\n      );\n      const inputElement = container.querySelector('input');\n      // prefix/suffix *is there* when there is a value and there is no focus.\n      // get the prefix dom and get the id from it.\n      // test prefixId is there on expected dom\n      const prefixDom = queryByText(text);\n      expect(prefixDom).not.to.be.null;\n      const prefixId = prefixDom?.parentElement?.id;\n      expect(prefixId?.endsWith('prefix'), `prefixId ends with 'prefix'`).to.be.true;\n\n      // test input's aria-labelledby includes the prefixId\n      const ariaLB = inputElement?.getAttribute('aria-labelledby');\n      expect(ariaLB).not.to.be.null;\n      expect(ariaLB?.includes(prefixId as string)).to.be.true;\n      // should be the only one since there is no label.\n      expect(ariaLB).to.equal(prefixId);\n    })\n  );\n\n  componentList.forEach((compObj) =>\n    it(`${compObj.name}: suffix aria-labelledby, no label`, () => {\n      const text = 'lbs';\n      const { container, queryByText } = render(\n        <compObj.component suffix={text} value=\"123412\" labelEdge=\"none\" label=\"with suffix\" />\n      );\n      const inputElement = container.querySelector('input');\n      // prefix/suffix *is there* when there is a value and there is no focus.\n      const suffixDom = queryByText(text);\n      expect(suffixDom).not.to.be.null;\n      const suffixId = suffixDom?.parentElement?.id;\n      expect(suffixId?.endsWith('suffix'), `suffixId ends with 'suffix'`).to.be.true;\n\n      const ariaLB = inputElement?.getAttribute('aria-labelledby');\n      expect(ariaLB).not.to.be.null;\n      // get suffix dom. get id. get aria-labelledby off of input and see if suffix id is there.\n      expect(ariaLB?.includes(suffixId as string)).to.be.true;\n    })\n  );\n\n  componentList.forEach((compObj) =>\n    it(`${compObj.name}: suffix aria-labelledby, has label`, () => {\n      const text = 'lbs';\n      const { container, queryByText } = render(\n        <compObj.component suffix={text} value=\"123412\" label=\"Weight\" />\n      );\n      const inputElement = container.querySelector('input');\n\n      const suffixDom = queryByText(text);\n      // id is on the div, not the span around the text.\n      const suffixId = suffixDom?.parentElement?.id;\n      const ariaLB = inputElement?.getAttribute('aria-labelledby');\n\n      // get aria-labelledby off of input and see if suffix id is there, but not first.\n      const suffixIndex = (ariaLB as string).indexOf(suffixId as string);\n      expect(suffixIndex).to.not.equal(0);\n      expect(suffixIndex).to.not.equal(-1);\n    })\n  );\n\n  componentList.forEach((compObj) =>\n    // we render both labelId and suffixId in aria-labelledby on input so that the screenreader will read both.\n    it(`${compObj.name}: suffix aria-labelledby, has labelid`, () => {\n      const text = 'lbs';\n      const { container, queryByText } = render(\n        <compObj.component suffix={text} value=\"123412\" label=\"Weight\" />\n      );\n      const inputElement = container.querySelector('input');\n\n      const labelDom = queryByText('Weight');\n      expect(labelDom?.tagName.toUpperCase()).equals('LABEL');\n      const labelId = labelDom?.id;\n      expect(labelId).to.not.be.undefined;\n      expect(labelId).to.not.equal('');\n\n      const ariaLB = inputElement?.getAttribute('aria-labelledby');\n      // get suffix dom. get id. get aria-labelledby off of input and see if suffix id is there.\n      // see if label id is there too.\n      const labelIdIndex = (ariaLB as string).indexOf(labelId as string);\n      expect(labelIdIndex).to.equal(0);\n    })\n  );\n\n  componentList.forEach((compObj) =>\n    // we do not render aria-labelledby on the input if there is no prefix or suffix.\n    // even if there is a label. the label's for/id combox is enough in that case.\n    it(`${compObj.name}: no prefix/suffix, no aria-labelledby, has label`, () => {\n      const { container, queryByText } = render(\n        <compObj.component value=\"123412\" label=\"Weight\" />\n      );\n      const inputElement = container.querySelector('input');\n\n      const labelDom = queryByText('Weight');\n      expect(labelDom?.tagName.toUpperCase()).equals('LABEL');\n      const labelId = labelDom?.id;\n      expect(labelId).to.not.be.undefined;\n      expect(labelId).to.not.equal('');\n\n      const ariaLB = inputElement?.getAttribute('aria-labelledby');\n      expect(ariaLB).to.be.null;\n    })\n  );\n\n  componentList.forEach((compObj) =>\n    // we do not render aria-labelledby on the input if there is no prefix or suffix.\n    // even if there is a label. the label's for/id combox is enough in that case.\n    it(`${compObj.name}: prefix and suffix, aria-labelledby, no label`, () => {\n      const { container, queryByText } = render(\n        <compObj.component\n          prefix=\"+++\"\n          suffix=\"lbs\"\n          value=\"123412\"\n          labelEdge=\"none\"\n          label=\"with prefix suffix\"\n        />\n      );\n      const inputElement = container.querySelector('input');\n      const suffixDom = queryByText('lbs');\n      // id is on the div, not the span around the text.\n      const suffixId = suffixDom?.parentElement?.id;\n      const prefixDom = queryByText('+++');\n      // id is on the div, not the span around the text.\n      const prefixId = prefixDom?.parentElement?.id;\n\n      // get aria-labelledby off of input and see if prefix id is there and suffix id is there,\n      // and that there are only two.\n      const ariaLB = inputElement?.getAttribute('aria-labelledby');\n      const hasSuffixId = (ariaLB as string).includes(suffixId as string);\n      expect(hasSuffixId).to.be.true;\n\n      const hasPrefixId = (ariaLB as string).includes(prefixId as string);\n      expect(hasPrefixId).to.be.true;\n\n      // splice the string and make sure there are only two.\n      const numIds = ariaLB?.trim().split(/\\s+/).length;\n      expect(numIds).to.equal(2);\n    })\n  );\n\n  afterEach(cleanup);\n});\n\n// skip the color tests in jest, only run it in karma mocha\nif (typeof jest === 'undefined') {\n  describe('Form Controls - Prefix/Suffix Color', () => {\n    componentList.forEach((compObj) =>\n      it(`${compObj.name}: prefix color is same as input text`, () => {\n        const text = '+234';\n        const { container, queryByText } = render(\n          <compObj.component prefix={text} value=\"123412\" label=\"with prefix\" />\n        );\n\n        const inputElement = container.querySelector('input');\n        // test style\n        const textColor = window\n          .getComputedStyle(queryByText(text) as Element)\n          .getPropertyValue('color');\n        const inputColor = window\n          .getComputedStyle(inputElement as Element)\n          .getPropertyValue('color');\n        expect(textColor).equals(inputColor);\n      })\n    );\n\n    componentList.forEach((compObj) =>\n      it(`${compObj.name}: suffix color is same as input text`, () => {\n        const text = 'lbs';\n        const { container, queryByText } = render(\n          <compObj.component suffix={text} value=\"123412\" label=\"with suffix\" />\n        );\n\n        const inputElement = container.querySelector('input');\n        // test style\n        const textColor = window\n          .getComputedStyle(queryByText(text) as Element)\n          .getPropertyValue('color');\n        const inputColor = window\n          .getComputedStyle(inputElement as Element)\n          .getPropertyValue('color');\n        expect(textColor).equals(inputColor);\n      })\n    );\n\n    componentList.forEach((compObj) =>\n      it(`${compObj.name}: prefix color is not the same as input text when focused`, () => {\n        const text = '+234';\n        const { container, queryByText } = render(\n          <compObj.component prefix={text} value=\"123412\" label=\"with prefix\" />\n        );\n\n        const inputElement = container.querySelector('input');\n        act(() => {\n          inputElement?.focus();\n        });\n        // test style\n        const textColor = window\n          .getComputedStyle(queryByText(text) as Element)\n          .getPropertyValue('color');\n        const inputColor = window\n          .getComputedStyle(inputElement as Element)\n          .getPropertyValue('color');\n        expect(textColor).equals(inputColor);\n      })\n    );\n\n    componentList.forEach((compObj) =>\n      it(`${compObj.name}: suffix color is not the same as input text when focused`, () => {\n        const text = 'lbs';\n        const { container, queryByText } = render(\n          <compObj.component suffix={text} value=\"123412\" label=\"with suffix\" />\n        );\n\n        const inputElement = container.querySelector('input');\n        act(() => {\n          inputElement?.focus();\n        });\n        // test style\n        const textColor = window\n          .getComputedStyle(queryByText(text) as Element)\n          .getPropertyValue('color');\n        const inputColor = window\n          .getComputedStyle(inputElement as Element)\n          .getPropertyValue('color');\n        expect(textColor).equals(inputColor);\n      })\n    );\n\n    afterEach(cleanup);\n  });\n}\n"],"names":["noOp","componentList","name","component","isDisabled","isReadonly","label","labelEdge","prefix","suffix","value","_jsx","_Fragment","children","InputText","onInput","NumberInputText","describe","testPrefixIsThere","inputElement","queryTextLength","element","previousElementSibling","expect","tagName","toUpperCase","not","equal","to","testPrefixIsNotThere","testSuffixIsThere","nextElementSibling","be","null","testSuffixIsNotThere","forEach","compObj","it","text","container","queryAllByText","render","querySelector","length","jsx","act","focus","queryByText","foundReadonlyText","prefixDom","prefixId","_a","parentElement","id","endsWith","true","ariaLB","getAttribute","includes","suffixDom","suffixId","suffixIndex","indexOf","labelDom","equals","labelId","undefined","labelIdIndex","_b","hasSuffixId","hasPrefixId","numIds","trim","split","afterEach","cleanup","jest","textColor","window","getComputedStyle","getPropertyValue","inputColor"],"mappings":"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"}