{"version":3,"file":"Menu-cb21d7c2.js","sources":["../../src/UNSAFE_Menu/menuUtils.ts","../../src/UNSAFE_Menu/MenuContainer.tsx","../../src/UNSAFE_Menu/useMenuCurrentKey.ts","../../src/UNSAFE_Menu/DropdownMenu.tsx","../../src/UNSAFE_Menu/SheetMenu.tsx","../../src/UNSAFE_Menu/useMenuSwipe.ts","../../src/UNSAFE_Menu/Menu.tsx"],"sourcesContent":["/**\n * @license\n * Copyright (c) %FIRST_YEAR% %CURRENT_YEAR%, Oracle and/or its affiliates.\n * Licensed under The Universal Permissive License (UPL), Version 1.0\n * as shown at https://oss.oracle.com/licenses/upl/\n * @ignore\n */\n\nimport { ComponentProps } from 'preact';\n\nimport { Menu } from './Menu';\n\n/**\n * Returns the key from the item element\n */\nconst getKey = (item: HTMLElement) => {\n  // Key is set on data-oj-menu-item-key on each menuItem. To get this key from the\n  // the actual menuItem we need to do a kebab to camel-case conversion.\n  return item.dataset['ojMenuItemKey'];\n};\n\n/**\n * A helper function that return the key of the first available item.\n */\nexport const getFirstVisibleKey = (root: HTMLElement | null) => {\n  if (root) {\n    const firstItem = root.querySelector('[data-oj-menu-item-key]');\n    if (firstItem) {\n      const key = getKey(firstItem as HTMLElement);\n      if (key) {\n        return key;\n      }\n    }\n  }\n  return null;\n};\n\n/**\n * A helper function that return the key of the last available item.\n */\nexport const getLastVisibleKey = (root: HTMLElement | null) => {\n  if (root) {\n    const items = root.querySelectorAll('[data-oj-menu-item-key]');\n    const lastItem = items[items.length - 1];\n    if (lastItem) {\n      const key = getKey(lastItem as HTMLElement);\n      if (key) {\n        return key;\n      }\n    }\n  }\n  return null;\n};\n\n/**\n * A helper function that returns the key of the previous or the next item\n * given the specified current key\n */\nexport const getPrevNextKey = (root: HTMLElement | null, isPrev: boolean, currentKey?: string) => {\n  return (): string | null => {\n    if (root) {\n      const items = Array.from(root.querySelectorAll('[data-oj-menu-item-key]')) as HTMLElement[];\n      const currentKeyIndex = items.findIndex((item) => getKey(item) === currentKey);\n      let nextIndex = currentKeyIndex + (isPrev ? -1 : 1);\n      const itemsLastIndex = items.length - 1;\n      if (nextIndex < 0) {\n        nextIndex = itemsLastIndex;\n      }\n      if (nextIndex > itemsLastIndex) {\n        nextIndex = 0;\n      }\n      return getKey(items[nextIndex]) || null;\n    }\n    return null;\n  };\n};\n\n/**\n * A helper function to get the key from an element\n */\nexport const keyExtractor = (element: HTMLElement): string | null => {\n  const item = element.closest('[data-oj-menu-item-key]');\n  if (item) {\n    const key = getKey(item as HTMLElement);\n    return key === undefined ? null : key;\n  }\n  return null;\n};\n\n/**\n * Function to get the corresponding keyboard behavior to close the menu.\n */\nexport const getKeyboardCloseProps = (onClose: ComponentProps<typeof Menu>['onClose']) => {\n  const onKeyDown = (event: KeyboardEvent) => {\n    if (event.key === 'Tab') {\n      onClose?.({ reason: 'dismissed' });\n      event.preventDefault(); //TODO: Revisit this since we should let focus be at its natural flow, quick solution for now to focus correct item in main use case\n    } else if (event.key === 'Escape') {\n      onClose?.({ reason: 'dismissed' });\n    }\n  };\n  return { onKeyDown };\n};\n\n/**\n * Function to get the corresponding specific behavior for clicking/touching down menuContainer\n */\nexport const getMenuPointerDown = () => {\n  const onPointerDown = (event: PointerEvent) => {\n    //We just want to prevent default when element that was\n    //pressed down was not a menu item. Using this flag removes issues\n    //related to focus visibilty on \"long press\"\n    const nextKey = keyExtractor(event.target as HTMLElement);\n    if (!nextKey) {\n      event.preventDefault();\n    }\n  };\n  return { onPointerDown };\n};\n\nexport type MenuValueUpdateDetail<T> = {\n  previousValue?: T;\n  value: T;\n};\n","/**\n * @license\n * Copyright (c) %FIRST_YEAR% %CURRENT_YEAR%, Oracle and/or its affiliates.\n * Licensed under The Universal Permissive License (UPL), Version 1.0\n * as shown at https://oss.oracle.com/licenses/upl/\n * @ignore\n */\n\nimport { ComponentProps } from 'preact';\nimport { useCallback, useEffect, useRef, useState } from 'preact/hooks';\n\nimport { CurrentKeyDetail } from '../UNSAFE_Collection';\n\nimport { useCollectionFocusRing } from '../hooks/PRIVATE_useCollectionFocusRing';\nimport { mergeProps } from '../utils/UNSAFE_mergeProps';\nimport { cssProps } from '@oracle/oraclejet-cssprops';\nimport { classNames } from '../utils/UNSAFE_classNames';\n\nimport { Menu } from './Menu';\nimport { MenuContext } from './MenuContext';\nimport { useMenuCurrentKey } from './useMenuCurrentKey';\nimport {\n  getPrevNextKey,\n  getFirstVisibleKey,\n  keyExtractor,\n  getLastVisibleKey,\n  getKeyboardCloseProps,\n  getMenuPointerDown\n} from './menuUtils';\n\ntype MenuProps = ComponentProps<typeof Menu>;\n\ntype MenuContainerProps = Omit<MenuProps, 'isOpen' | 'anchorRef'> & {\n  display: 'sheet' | 'dropdown';\n};\n\nconst styles = {\n  menuContainer: cssProps`${{\n    outlineStyle: 'none'\n  }}`,\n  dropdownMenuContainer: cssProps`${{\n    paddingTop: 'var(--oj-c-PRIVATE-DO-NOT-USE-core-spacing-2x)',\n    paddingBottom: 'var(--oj-c-PRIVATE-DO-NOT-USE-core-spacing-2x)'\n  }}`,\n  sheetMenuContainer: cssProps`${{\n    paddingTop: 'var(--oj-c-PRIVATE-DO-NOT-USE-core-spacing-5x)',\n    paddingBottom: 'var(--oj-c-PRIVATE-DO-NOT-USE-core-spacing-2x)'\n  }}`\n};\n\nexport const MenuContainer = ({\n  children,\n  onClose,\n  accessibleLabel,\n  initialFocus = 'menu',\n  display\n}: MenuContainerProps) => {\n  const menuContainerRef = useRef<HTMLDivElement | null>(null);\n  const initialFocusRef = useRef(initialFocus);\n\n  const [currentKey, setCurrentKey] = useState<string | undefined>();\n\n  const [possibleFocus, setPossibleFocus] = useState<'pending' | 'menu' | 'firstItem'>('pending');\n\n  const changeKey = useCallback((detail: CurrentKeyDetail<string>) => {\n    setCurrentKey(detail.value);\n    setPossibleFocus('firstItem');\n  }, []);\n\n  const [showFocusRing, focusRingProps] = useCollectionFocusRing(\n    (elem: Element | null) => {\n      return !!menuContainerRef.current?.contains(elem);\n    },\n    ['ArrowUp', 'ArrowDown'],\n    (elem: Element) => {\n      const nextKey = keyExtractor(elem as HTMLElement);\n      return !!nextKey;\n    }\n  );\n\n  const { currentKeyProps } = useMenuCurrentKey(\n    (element) => keyExtractor(element),\n    getPrevNextKey(menuContainerRef.current, true, currentKey),\n    getPrevNextKey(menuContainerRef.current, false, currentKey),\n    () => getFirstVisibleKey(menuContainerRef.current),\n    () => getLastVisibleKey(menuContainerRef.current),\n    currentKey,\n    changeKey\n  );\n\n  useEffect(() => {\n    const menuContainer = menuContainerRef.current;\n\n    if (menuContainer) {\n      if (initialFocusRef.current === 'menu') {\n        // At this point floating has visibility set as hidden, so also menuContainer. Settimeout added so menuContainer\n        // is visible at that point and can be focused\n        setTimeout(() => {\n          menuContainer.focus();\n        }, 0);\n        setPossibleFocus('menu');\n      } else {\n        const firstItemKey = getFirstVisibleKey(menuContainerRef.current);\n        if (firstItemKey) {\n          changeKey({ value: firstItemKey });\n        } else {\n          setPossibleFocus('menu');\n        }\n      }\n    }\n  }, [initialFocusRef, changeKey]);\n\n  // TODO - Reuse a dropdown component instead of creating floating by ourselves.\n  return (\n    <div\n      ref={menuContainerRef}\n      tabIndex={possibleFocus === 'firstItem' ? -1 : 0}\n      role=\"menu\"\n      aria-label={accessibleLabel}\n      class={classNames([styles.menuContainer, styles[`${display}MenuContainer`]])}\n      {...mergeProps(\n        focusRingProps,\n        currentKeyProps,\n        getMenuPointerDown(),\n        getKeyboardCloseProps(onClose)\n      )}>\n      <MenuContext.Provider\n        value={{\n          onClose,\n          currentKey,\n          showFocusRing\n        }}>\n        {children}\n      </MenuContext.Provider>\n    </div>\n  );\n};\n","/**\n * @license\n * Copyright (c) %FIRST_YEAR% %CURRENT_YEAR%, Oracle and/or its affiliates.\n * The Universal Permissive License (UPL), Version 1.0\n * as shown at https://oss.oracle.com/licenses/upl/\n * @ignore\n */\nimport { useCallback } from 'preact/hooks';\n\nimport { CurrentKeyDetail } from '../UNSAFE_Collection';\n\n/**\n * Hook for handling current key update due to user interaction including keyboard navigation.\n *\n * @param keyExtractor function to extract the key based on the provided element\n * @param getPrevKey function to get the previous key based on the current key\n * @param getNextKey function to get the next key based on the current key\n * @param getFirstVisibleKey function to get the key of the first available item\n * @param getLastVisibleKey function to get the key of the last available item\n * @param currentKey the current key\n * @param onChange function to invoke if the current key has changed\n * @returns\n */\nexport function useMenuCurrentKey(\n  keyExtractor: (element: HTMLElement) => string | null,\n  getPrevKey: () => string | null,\n  getNextKey: () => string | null,\n  getFirstVisibleKey: () => string | null,\n  getLastVisibleKey: () => string | null,\n  currentKey?: string,\n  onChange?: (detail: CurrentKeyDetail<string>) => void\n) {\n  const onKeyDown = useCallback(\n    (event: KeyboardEvent) => {\n      if (onChange) {\n        // TODO: support horizontal layout on icon menu (left/right arrow key)\n        if (event.key === 'ArrowDown' && !event.shiftKey) {\n          const nextKey = getNextKey();\n          if (nextKey && currentKey != nextKey) {\n            onChange({ value: nextKey });\n          }\n          event.preventDefault();\n        } else if (event.key === 'ArrowUp' && !event.shiftKey) {\n          const prevKey = getPrevKey();\n          if (prevKey && currentKey != prevKey) {\n            onChange({ value: prevKey });\n          }\n          event.preventDefault();\n        } else if (event.key === 'Home') {\n          const firstKey = getFirstVisibleKey();\n          if (firstKey && currentKey != firstKey) {\n            onChange({ value: firstKey });\n          }\n          event.preventDefault();\n        } else if (event.key === 'End') {\n          const lastKey = getLastVisibleKey();\n          if (lastKey && currentKey != lastKey) {\n            onChange({ value: lastKey });\n          }\n          event.preventDefault();\n        }\n      }\n    },\n    [currentKey, getNextKey, getPrevKey, onChange, getFirstVisibleKey, getLastVisibleKey]\n  );\n  //Capture needed since usePress stop propagation, what produces not triggering this event.\n  //We can't stop propagation here, because if we do that, usePress onClick will not be triggered.\n  const onClickCapture = useCallback(\n    (event: MouseEvent) => {\n      if (onChange && !event.shiftKey) {\n        const nextKey = keyExtractor(event.target as HTMLElement);\n        if (nextKey && currentKey != nextKey) {\n          onChange({ value: nextKey });\n        }\n      }\n    },\n    [currentKey, keyExtractor, onChange]\n  );\n\n  const currentKeyProps = onChange == null ? {} : { onClickCapture, onKeyDown };\n  return { currentKeyProps };\n}\n","import { ComponentProps, useCallback, useRef } from 'preact/compat';\n\nimport { cssProps } from '@oracle/oraclejet-cssprops';\nimport { Floating } from '../UNSAFE_Floating';\n\nimport { MenuContainer } from './MenuContainer';\nimport { Menu } from './Menu';\nimport { useOutsideClick } from '../hooks/UNSAFE_useOutsideClick';\n\nconst styles = {\n  // TODO: Handle vertical and horizontal overflow. Get rid of maxWidth on a next drop so horizontal and also vertical flow is handled correctly.\n  // It's hard to relay just in css, we might need to relay on some kind of observer. Maybe should be handled on Floating/Dropdown component.\n  base: cssProps`${{\n    maxWidth: '90vw',\n    width: 'max-content',\n    borderRadius: 'var(--oj-c-PRIVATE-DO-NOT-USE-core-border-radius-lg)',\n    boxShadow: 'var(--oj-c-PRIVATE-DO-NOT-USE-core-dropdown-box-shadow)',\n    backgroundColor: 'var(--oj-c-PRIVATE-DO-NOT-USE-core-bg-color-content)'\n  }}`\n};\n\nexport const DropdownMenu = ({\n  anchorRef,\n  onClose,\n  ...dropdownMenuProps\n}: ComponentProps<typeof Menu>) => {\n  const floatingRef = useRef<HTMLElement | null>(null);\n\n  const useOutsideClickHandler = useCallback(\n    (e: MouseEvent) => {\n      onClose?.({ reason: 'outsideClick', target: e.target as Element });\n    },\n    [onClose]\n  );\n\n  useOutsideClick({\n    ref: [floatingRef],\n    handler: useOutsideClickHandler\n  });\n\n  return (\n    <Floating\n      class={styles.base}\n      ref={floatingRef}\n      anchorRef={anchorRef}\n      placement=\"bottom-start\"\n      offsetValue={{\n        mainAxis: 4, //TODO: stable does not have a 4px gap, so we'll need to figure out how to make this themable.\n        crossAxis: 0\n      }}>\n      <div\n        style={{\n          minWidth: `${\n            anchorRef.current && anchorRef.current.offsetWidth > MENU_MIN_WIDTH\n              ? anchorRef.current.offsetWidth\n              : MENU_MIN_WIDTH\n          }px`\n        }}>\n        <MenuContainer {...{ onClose, ...dropdownMenuProps }} display=\"dropdown\" />\n      </div>\n    </Floating>\n  );\n};\n\nconst MENU_MIN_WIDTH = 200;\n","import { ComponentProps } from 'preact';\nimport { forwardRef } from 'preact/compat';\nimport { useCallback, useEffect } from 'preact/hooks';\n\nimport { cssProps } from '@oracle/oraclejet-cssprops';\nimport { useMenuSwipe } from './useMenuSwipe';\nimport useModal from '../UNSAFE_Modal/hooks/useModal';\nimport { HTMLAttributesSignalExcluded } from '../utils/UNSAFE_attributeUtils';\n\nimport { Menu } from './Menu';\nimport { MenuContainer } from './MenuContainer';\n\ntype IntrinsicProps = Pick<HTMLAttributesSignalExcluded<HTMLDivElement>, 'children'>;\n\nconst styles = {\n  modalWrapper: cssProps`${{\n    position: 'fixed',\n    top: 0,\n    bottom: 0,\n    left: 0,\n    right: 0,\n    zIndex: 'var(--oj-c-PRIVATE-DO-NOT-USE-core-z-index-popup)'\n  }}`,\n  modalContainer: cssProps`${{\n    position: 'absolute',\n    top: 0,\n    bottom: 0,\n    left: 0,\n    right: 0\n  }}`,\n  sheetMenuContainerWrapper: cssProps`${{\n    borderRadius: '16px 16px 0 0',\n    backgroundColor: 'var(--oj-c-PRIVATE-DO-NOT-USE-core-bg-color-content)',\n    position: 'absolute',\n    bottom: 0,\n    left: 0,\n    right: 0,\n    maxHeight: 'calc(100% - 96px)',\n    overflowY: 'auto',\n    overscrollBehaviorY: 'contain',\n    touchAction: 'pan-y',\n    userSelect: 'none'\n  }}`,\n  modalBackdrop: cssProps`${{\n    position: 'absolute',\n    top: '0',\n    right: '0',\n    bottom: '0',\n    left: '0',\n    backgroundColor: 'var(--oj-c-PRIVATE-DO-NOT-USE-core-scrim-color)'\n  }}`\n};\n\nconst ModalWrapper = ({ children }: IntrinsicProps) => (\n  <div class={styles.modalWrapper}>{children}</div>\n);\nconst ModalContainer = forwardRef<HTMLDivElement, IntrinsicProps>(({ children }, ref) => (\n  <div class={styles.modalContainer} ref={ref}>\n    {children}\n  </div>\n));\n//ModalBackdrop on modal folder not setting the style on oj-c enviroment\n//Creating it here so we don't see that issue\nconst ModalBackdrop = () => <div class={styles.modalBackdrop} />;\n\nexport const SheetMenu = ({\n  onClose,\n  ...menuProps\n}: Omit<ComponentProps<typeof Menu>, 'anchorRef'>) => {\n  useEffect(() => {\n    // We set the overflow body as hidden when mounted and revert to original overflow value when is\n    // unmounted. This is done to don't allow backgound being scrolled\n    // This will be handled by modal/popup when ready\n    const initialOverflow = document.body.style.overflow;\n    document.body.style.overflow = 'hidden';\n    return () => {\n      document.body.style.overflow = initialOverflow;\n    };\n  }, []);\n\n  const dismissHandler = useCallback(() => {\n    onClose?.({ reason: 'dismissed' });\n  }, [onClose]);\n\n  const { modalRef } = useModal({ isOpen: true, onBackdropClick: dismissHandler });\n  //TODO: Use useSwipe when it works on components that could scroll.\n  const { swipeProps } = useMenuSwipe(dismissHandler);\n\n  // TODO: For now we are mimicking current modal but using a \"different position setting\" (using absolute positioning instead of flex).\n  // Have to use modal/popup component directly instead doing this composition when that component could satisfy our requirments.\n  return (\n    <ModalWrapper>\n      <ModalBackdrop></ModalBackdrop>\n      <ModalContainer ref={modalRef}>\n        <div class={styles.sheetMenuContainerWrapper} {...swipeProps}>\n          <MenuContainer {...{ ...menuProps, onClose }} display=\"sheet\"></MenuContainer>\n        </div>\n      </ModalContainer>\n    </ModalWrapper>\n  );\n};\n","/**\n * @license\n * Copyright (c) %FIRST_YEAR% %CURRENT_YEAR%, Oracle and/or its affiliates.\n * Licensed under The Universal Permissive License (UPL), Version 1.0\n * as shown at https://oss.oracle.com/licenses/upl/\n * @ignore\n */\n\nimport { useRef, useCallback } from 'preact/hooks';\n\n/*\n  threshold: Minimal threshold required before recognizing\n  tolerance: A tolerance value which allows the user to move their finger about a length measured in pixels.\n  This allows the swipe gesture to be triggered more easily since a User might not move their finger\n  in a straight line.\n*/\ntype SwipeOptions = {\n  threshold?: number;\n  maximumTime?: number;\n  tolerance?: number;\n  isDisabled?: boolean;\n};\n\ntype SwipeInfo = {\n  direction: 'down';\n};\n\ntype SwipeState = {\n  pointerDownId: number | null;\n  startTime: number | null;\n  prevpageX: number;\n  prevpageY: number;\n  elementScrollTop: number;\n};\n/*This \"private\" hook will live until we end up stating a final decision on useSwipe hook.\nFor that hook to work, element that use it has to set touch-action:none;, since pointer events\nare canceled once a touch action is going to be handled by the browser. This works for most\nof the components that don't scroll. But if the component scroll, there is a need for the browser to \nhandle scroll which is imposible with a hook just using pointer events.\n*/\nexport function useMenuSwipe(\n  onSwipe: (e: SwipeInfo) => void,\n  { threshold = 10, maximumTime = 300, tolerance = 50, isDisabled = false }: SwipeOptions = {\n    threshold: 10,\n    maximumTime: 300,\n    tolerance: 50,\n    isDisabled: false\n  }\n): { swipeProps: Record<string, any> } {\n  const ref = useRef<SwipeState>({\n    pointerDownId: 0,\n    startTime: null,\n    prevpageX: 0,\n    prevpageY: 0,\n    elementScrollTop: 0\n  });\n\n  const clearSwipe = useCallback(() => {\n    ref.current = {\n      pointerDownId: null,\n      startTime: 0,\n      prevpageX: 0,\n      prevpageY: 0,\n      elementScrollTop: 0\n    };\n  }, []);\n\n  const onTouchStart = useCallback(\n    (e: TouchEvent) => {\n      const touchobj = e.changedTouches[0];\n      if (!ref.current.pointerDownId) {\n        ref.current = {\n          pointerDownId: touchobj.identifier,\n          startTime: e.timeStamp,\n          prevpageX: touchobj.pageX,\n          prevpageY: touchobj.pageY,\n          elementScrollTop: (e.currentTarget as HTMLElement).scrollTop\n        };\n      } else {\n        clearSwipe();\n      }\n    },\n    [clearSwipe]\n  );\n\n  const onTouchEnd = useCallback(\n    (ev: TouchEvent) => {\n      const touchobj = ev.changedTouches[0];\n      if (touchobj.identifier === ref.current.pointerDownId) {\n        if (ref.current.startTime && ev.timeStamp - ref.current.startTime < maximumTime) {\n          if (\n            touchobj.pageY - ref.current.prevpageY > threshold &&\n            Math.abs(touchobj.pageX - ref.current.prevpageX) <= tolerance &&\n            ref.current.elementScrollTop === 0\n          ) {\n            onSwipe?.({ direction: 'down' });\n          }\n        }\n      }\n      // state would be reset to its original state whether swipe is completed or cancelled\n      clearSwipe();\n    },\n    [threshold, onSwipe, clearSwipe, maximumTime, tolerance]\n  );\n\n  const swipeProps = isDisabled\n    ? {}\n    : {\n        /** event handlers to spread on the target element. */\n        onTouchStart,\n        onTouchEnd,\n        ontouchcancel: clearSwipe\n      };\n\n  return {\n    swipeProps\n  };\n}\n","/**\n * @license\n * Copyright (c) %FIRST_YEAR% %CURRENT_YEAR%, Oracle and/or its affiliates.\n * Licensed under The Universal Permissive License (UPL), Version 1.0\n * as shown at https://oss.oracle.com/licenses/upl/\n * @ignore\n */\n\nimport { RefObject, ComponentChildren } from 'preact';\n\nimport { Layer } from '../UNSAFE_Layer';\nimport { getClientHints } from '../utils/PRIVATE_clientHints';\n\nimport { DropdownMenu } from './DropdownMenu';\nimport { SheetMenu } from './SheetMenu';\n\ntype MenuProps = {\n  /**\n   * Trigger element reference\n   */\n  anchorRef: RefObject<HTMLElement>;\n  /**\n   * Set of menu groups or menu items that menu will hold.Even though you could pass other type of children,\n   * is strongly recommended to use MenuItem, menu groups or components that return this type of components\n   * since passing other type of components children produces not desirable behaviors.\n   */\n  children: ComponentChildren;\n  /**\n   * Specifies if menu is opened.\n   */\n  isOpen?: boolean;\n  /**\n   * Property that triggers a callback when menu is supposed to be closed.\n   */\n  onClose?: (detail: CloseDetail) => void;\n  /**\n   * Specifies some screen reader text. Set it to create an accesible menu.\n   */\n  accessibleLabel?: string;\n  /**\n   *  Determines focus behavior when the menu is opened.\n   */\n  initialFocus?: 'menu' | 'firstItem';\n};\n\ntype CloseDetail =\n  | {\n      //dismissed represents dismissing the menu using esc,tap and on mobile swiping and taping backdrop\n      reason: 'dismissed' | 'itemAction';\n    }\n  | {\n      reason: 'outsideClick';\n      target: Element;\n    };\n\nconst { deviceType } = getClientHints();\nconst isMobile = deviceType === 'phone';\nexport const Menu = ({ isOpen, anchorRef, ...menuProps }: MenuProps) => {\n  // TODO - Reuse a dropdown component instead of creating floating by ourselves.\n  return !isOpen ? null : (\n    <Layer logicalParentRef={anchorRef}>\n      {isMobile ? <SheetMenu {...menuProps} /> : <DropdownMenu {...{ anchorRef, ...menuProps }} />}\n    </Layer>\n  );\n};\n"],"names":["getKey","item","dataset","getFirstVisibleKey","root","firstItem","querySelector","key","getPrevNextKey","isPrev","currentKey","items","Array","from","querySelectorAll","nextIndex","findIndex","itemsLastIndex","length","keyExtractor","element","closest","undefined","styles","MenuContainer","children","onClose","accessibleLabel","initialFocus","display","menuContainerRef","useRef","initialFocusRef","changeKey","useCallback","detail","setCurrentKey","value","_a","current","contains","elem","currentKeyProps","getPrevKey","getNextKey","getLastVisibleKey","onChange","onKeyDown","event","shiftKey","firstKey","preventDefault","lastKey","prevKey","nextKey","onClickCapture","target","useMenuCurrentKey","lastItem","menuContainer","firstItemKey","_jsx","Object","assign","ref","tabIndex","possibleFocus","role","class","classNames","mergeProps","focusRingProps","onPointerDown","reason","getKeyboardCloseProps","MenuContext","Provider","DropdownMenu","floatingRef","useOutsideClickHandler","e","useOutsideClick","handler","mainAxis","crossAxis","minWidth","anchorRef","offsetWidth","MENU_MIN_WIDTH","jsx","dropdownMenuProps","ModalWrapper","ModalContainer","forwardRef","ModalBackdrop","SheetMenu","menuProps","__rest","dismissHandler","modalRef","useModal","isOpen","onBackdropClick","onSwipe","threshold","maximumTime","tolerance","isDisabled","pointerDownId","startTime","prevpageX","prevpageY","elementScrollTop","clearSwipe","onTouchStart","touchobj","changedTouches","identifier","timeStamp","pageX","pageY","currentTarget","scrollTop","onTouchEnd","ev","Math","abs","direction","swipeProps","ontouchcancel","_jsxs","deviceType","getClientHints","isMobile","Layer","logicalParentRef"],"mappings":"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"}