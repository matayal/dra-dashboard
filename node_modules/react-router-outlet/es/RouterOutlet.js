import _objectWithoutPropertiesLoose from "@babel/runtime/helpers/esm/objectWithoutPropertiesLoose";
import _extends from "@babel/runtime/helpers/esm/extends";
const _excluded = ["routes", "placeholder"];
import { jsx as _jsx } from "react/jsx-runtime";
import { Suspense } from 'react';
import PropTypes from 'prop-types';
import { Route, Switch, Redirect } from 'react-router-dom';
import isGuarded from './isGuarded';
import isRedirect from './isRedirect';

function resolveFromProps(route, props) {
  const resolveValue = val => typeof val === 'function' ? val(props, route) : val;

  if (isRedirect(route)) {
    return _extends({}, route, {
      redirectTo: resolveValue(route.redirectTo)
    });
  }

  if (isGuarded(route)) return _extends({}, route, {
    fallback: resolveValue(route.fallback)
  });
  return route;
}

export function RouterOutlet(props) {
  const {
    routes,
    placeholder
  } = props,
        outletProps = _objectWithoutPropertiesLoose(props, _excluded);

  const redirectJsx = (route, index) => {
    const r = route;
    return _jsx(Redirect, {
      from: r.path,
      exact: r.exact,
      strict: r.strict,
      to: r.redirectTo,
      push: r.push
    }, index);
  };

  const fallbackJsx = (route, index) => {
    const r = route;
    return _jsx(Redirect, {
      from: r.path,
      exact: r.exact,
      strict: r.strict,
      to: r.fallback,
      push: r.push
    }, index);
  };

  const routeJsx = (route, index) => {
    const r = route;
    return _jsx(Route, {
      path: r.path,
      exact: r.exact,
      strict: r.strict,
      render: () => _jsx(Suspense, {
        fallback: placeholder || _jsx("div", {}),
        children: _jsx(r.component, _extends({}, outletProps, r.componentProps, {
          routes: r.routes
        }))
      })
    }, index);
  };

  return _jsx(Switch, {
    children: routes.map((route, index) => {
      route = resolveFromProps(route, props);
      return isRedirect(route) ? redirectJsx(route, index) : isGuarded(route) && !route.canEnter(props, route) ? fallbackJsx(route, index) : routeJsx(route, index);
    })
  });
}
const routePropType = PropTypes.shape({
  path: PropTypes.oneOfType([PropTypes.string, PropTypes.arrayOf(PropTypes.string)]),
  exact: PropTypes.bool,
  strict: PropTypes.bool,
  component: PropTypes.oneOfType([PropTypes.func, PropTypes.object]),
  data: PropTypes.object,
  componentProps: PropTypes.object,
  canEnter: PropTypes.func,
  fallback: PropTypes.oneOfType([PropTypes.func, PropTypes.string, PropTypes.object]),
  redirectTo: PropTypes.oneOfType([PropTypes.func, PropTypes.string, PropTypes.object]),
  push: PropTypes.bool
});
RouterOutlet.propTypes = {
  routes: PropTypes.arrayOf(routePropType).isRequired,
  placeholder: PropTypes.oneOfType([PropTypes.func, PropTypes.object])
};
export default RouterOutlet;